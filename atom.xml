<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2017-08-03T14:09:13.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>语音识别动手玩</title>
    <link href="http://wdxtub.com/2017/07/10/hands-on-speech-recognition/"/>
    <id>http://wdxtub.com/2017/07/10/hands-on-speech-recognition/</id>
    <published>2017-07-10T09:28:08.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>上周因为工作需要，用 HTML5 + Go 搭了一个简单的语音识别评测的 demo，用户可以直接打开网页 -&gt; 说一句话 -&gt; 查看来自不同服务提供商的语音识别结果（目前是科大讯飞、腾讯 AI 加速器和百度语音三家）。因为之前的项目很少直接跟硬件打交道，所以这次依然是摸着石头过河。好在之前有做过语音识别的项目，所以基本的概念还是懂的（因为涉及到数据格式，不懂的话即使看代码也容易云里雾里）。</p>
<p>俗话说的好，授人以鱼不如授人以渔，这个小项目的代码固然不多，但如何一个人把项目做好可能比源代码本身更重要，所以更多会记录整个项目是如何开展的过程（以及我的思考和选择）。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编码之前的准备工作有很多，从需求分析、技术调研到技术选型，每一步都走好了，项目才能顺利。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在领到一个新任务之后，最重要的工作不是动手，而是弄清楚到底需要做什么。为什么这么说？因为很多时候老大们只是有一个想法想要验证，并不会有一个很清晰的图景，这就需要我们主动沟通，去和老大们一起弄清楚到底需要做一个什么东西，然后才是具体技术方案的选择。</p>
<p>经过和老大的沟通，确定了是要做一个大家都方便访问的评测不同语音识别服务提供商的 demo，老大倾向于做一个页面，只要有浏览器和麦克风就可以体验，至于交互这些只要达到能用的平均线即可。</p>
<h3 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h3><p>因为需要依赖第三方的服务，所以首先要弄清楚第三方提供了什么服务，尤其是具体的接入方式需要特别注意。经过一番搜索和阅读，我得到了下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">提供商\SDK平台</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">android</th>
<th style="text-align:center">Linux(c)</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">REST API</th>
<th style="text-align:center">Windows</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">百度</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">科大</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">腾讯</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
</tbody>
</table>
<p>对应的文档在 </p>
<ul>
<li><a href="http://yuyin.baidu.com/docs" target="_blank" rel="external">百度语音</a> - <a href="http://ai.baidu.com/docs#/ASR-Android-SDK/top" target="_blank" rel="external">文档1</a> <a href="http://yuyin.baidu.com/docs/asr/166" target="_blank" rel="external">文档2</a></li>
<li><a href="http://www.xfyun.cn/services/voicedictation" target="_blank" rel="external">科大讯飞</a> - <a href="http://doc.xfyun.cn/msc_linux/290898" target="_blank" rel="external">Linux 文档</a></li>
<li><a href="http://ai.qq.com/" target="_blank" rel="external">腾讯 AI 加速器</a></li>
</ul>
<p>支持的格式</p>
<ul>
<li>百度 Rest API: 原始 PCM 的录音参数必须符合 8k/16k 采样率、16bit 位深、单声道，支持的压缩格式有：pcm（不压缩）、wav（不压缩，pcm编码）、amr（压缩格式）</li>
<li>腾讯 Rest API: 必须符合16k采样率、16bit采样位数、单声道，语音格式    PCM、WAV、AMR、 SILK</li>
<li>讯飞 SDK: 采样率16KHZ或者8KHZ，单声道，采样精度16bit的PCM或者WAV格式的音频</li>
</ul>
<p>在调研到这些信息之后，我们就可以轻松做出技术选型了。</p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>首先的考虑因素是快速出成果，所以能用 Restful API 就尽量用（毕竟直接对好接口即可）。但是讯飞在这个方面非常不友好，只提供了 Linux C 和 Java 的 SDK，所以得另外想办法处理讯飞这个问题。</p>
<p>注：最快的方法其实是用 android 或 iOS 的 SDK，集成到项目中直接用即可，但因为前面老大已经要求要用 html 方案，因此这些不予考虑（除非 html 做不出来，才弄其他方案）</p>
<p>因为讯飞只提供了 Linux C 的 SDK(Java 我是不太想用的)，所以得想个办法集成到后端(Go)，正当我一筹莫展之际，一个名为 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts</a> 的项目进入了我的眼帘（科大讯飞语音linux在线语音合成后台服务），虽然并不是使用讯飞的语音识别而是语音合成功能，但证明了用 Go 封装讯飞的 C SDK 是可能的。于是我赶紧看了一波代码，并很快完成了用 Go 封装的讯飞语音识别 SDK（也算是给讯飞做了一点微小的工作）。</p>
<p>好，那么现在问题解决，前端 html5 + js，后端 Go + Go 封装的 C SDK，直接在之前为公司开发的深度学习平台上开一个接口即可。</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>准备工作的最后一步就是到各家的开放平台上创建应用，得到我们调用 API 或 SDK 的凭证。百度语音的最好申请，腾讯 AI 加速器的需要申请内测（我们公司有合作所以不用申请），讯飞的需要审核（不然每天只有 500 次）。</p>
<p>创建完成之后把各家的 App ID/APP Key 之类的信息记录下来，后面需要用。</p>
<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>之所以要后端，是因为前端 JS 发请求会遇到跨域的问题，另外后端处理我也更加熟悉（事实证明离开了后端还真不行）</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分的难点在于如何通过浏览器调用麦克风，尤其是在 Chrome 上，要求全程 HTTPS 加密（当然也有另外的办法就是本地打开）。那用其他浏览器可不可以呢？可以！比如 Firefox，但是感觉 Firefox 对 Mac 的麦克风支持的一般，经常出现问题，所以我一直都是用 Chrome 在测试的。</p>
<p>因为毕竟前端写得少，大部分代码都是参照 <a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a> 这篇博客写的。主要是两个文件 <code>index.html</code> 和 <code>recorder.js</code>，接下来分别说明一下。</p>
<p>先说 <code>index.html</code> 的部分，代码不长，主要做的事情就是申请麦克风访问，然后给按钮添加动作，最后就是用 audio 控件来播放音频了。audio 控件还是比较好用的，给出音源地址即可，播放和音量都自带，很省心。我还加了个日志区域方便调试，其他的没什么难度，在此略去不表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>语音识别评测 Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>追一语音识别评测 Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>评测科大讯飞、百度语音与腾讯 AI 加速器的语音识别接口<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>由于 Chrome47 以上以及 QQ 浏览器需要 HTTPS 的支持，请更换至 360、FireFox、Edge 进行体验<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另：IE 和 Safari 全版本不支持录音功能<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span>&gt;</span>录音<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"stop"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span> <span class="attr">disabled</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--&lt;button id="upload" class="ui-btn ui-btn-primary" disabled&gt;上传&lt;/button&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"audio-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>操作日志<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/recorder.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">        function __log(e, data) &#123;</div><div class="line">            log.innerHTML += "\n" + getNowFormatDate() + " " + e + " " + (data || '');</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        function getNowFormatDate() &#123;</div><div class="line">            var date = new Date();</div><div class="line">            var seperator1 = "/";</div><div class="line">            var seperator2 = ":";</div><div class="line">            var month = date.getMonth() + 1;</div><div class="line">            var strDate = date.getDate();</div><div class="line">            if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;</div><div class="line">                month = "0" + month;</div><div class="line">            &#125;</div><div class="line">            if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;</div><div class="line">                strDate = "0" + strDate;</div><div class="line">            &#125;</div><div class="line">            var hours = date.getHours()</div><div class="line">            if (hours &lt; 10) &#123;</div><div class="line">                hours = "0" + hours</div><div class="line">            &#125;</div><div class="line">            var minutes = date.getMinutes()</div><div class="line">            if (minutes &lt; 10) &#123;</div><div class="line">                minutes = "0" + minutes</div><div class="line">            &#125;</div><div class="line">            var seconds = date.getSeconds()</div><div class="line">            if (seconds &lt; 10) &#123;</div><div class="line">                seconds = "0" + seconds</div><div class="line">            &#125;</div><div class="line">            var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate +</div><div class="line">                "-" + hours + seperator2 + minutes + seperator2 + seconds;</div><div class="line">            return currentdate;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        window.onload = function() &#123;</div><div class="line">            var start = document.querySelector('#start');</div><div class="line">            var stop = document.querySelector('#stop');</div><div class="line">            //var upload = document.querySelector('#upload');</div><div class="line">            var download = document.querySelector('#download');</div><div class="line">            var container = document.querySelector('#audio-container');</div><div class="line">            var recorder;</div><div class="line"></div><div class="line">            HZRecorder.get(function(rec) &#123;</div><div class="line">                recorder = rec;</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            start.addEventListener('click', function() &#123;</div><div class="line">                __log("开始录音")</div><div class="line">                this.disabled = true;</div><div class="line">                stop.disabled = false;</div><div class="line">                //upload.disabled = true;</div><div class="line">                var audio = document.querySelectorAll('audio');</div><div class="line">                for (var i = 0; i &lt; audio.length; i++) &#123;</div><div class="line">                    if (!audio[i].paused) &#123;</div><div class="line">                        audio[i].pause();</div><div class="line">                    &#125;</div><div class="line">                    container.removeChild(audio[i]) // 移除之前的录音</div><div class="line">                &#125;</div><div class="line">                recorder.start();</div><div class="line">            &#125;);</div><div class="line">            stop.addEventListener('click', function() &#123;</div><div class="line">                this.disabled = true;</div><div class="line">                start.disabled = false;</div><div class="line">                //upload.disabled = false;</div><div class="line">                recorder.stop();</div><div class="line"></div><div class="line">                var audio = document.createElement('audio');</div><div class="line">                recorder.play(audio)</div><div class="line">                container.appendChild(audio);</div><div class="line"></div><div class="line">                // 下载音频文件</div><div class="line">                // var link = window.document.createElement('a');</div><div class="line">                // var link = document.createElement('a');</div><div class="line">                // link.href = audio.src;</div><div class="line">                // link.download = 'output.wav';</div><div class="line">                // link.click();</div><div class="line"></div><div class="line">                recorder.upload("http://127.0.0.1:8778/v1/api/qq/voice_recog", function(state, e) &#123;</div><div class="line">                    switch (state) &#123;</div><div class="line">                        case 'uploading':</div><div class="line">                            __log("上传中，会在后端进行转码与识别");</div><div class="line">                            break;</div><div class="line">                        case 'ok':</div><div class="line">                            //__log("上传成功");</div><div class="line">                            break;</div><div class="line">                        case 'error':</div><div class="line">                            __log("上传失败");</div><div class="line">                            break;</div><div class="line">                        case 'cancel':</div><div class="line">                            __log("上传被取消");</div><div class="line">                            break;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">            &#125;);</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是 <code>recorder.js</code>（基本是照抄上面提到的原博客），主要做的工作就是处理浏览器采集到的音频信号，编码成 wav。注意这里没有更改采样率（采用默认的 44100），因为直接截取的话音调会有变化，导致识别结果较差。但其他的部分都尽量按照前面提到的标准来弄，即 16 位采样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</div><div class="line">    <span class="comment">//兼容</span></div><div class="line">    <span class="built_in">window</span>.URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</div><div class="line">    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> HZRecorder = <span class="function"><span class="keyword">function</span>(<span class="params">stream, config</span>) </span>&#123;</div><div class="line">        config = config || &#123;&#125;;</div><div class="line">        config.sampleBits = config.sampleBits || <span class="number">16</span>; <span class="comment">//采样数位 8, 16</span></div><div class="line">        config.sampleRate = config.sampleRate || <span class="number">44100</span>; <span class="comment">//采样率 16000（会变慢）</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">new</span>(<span class="built_in">window</span>.webkitAudioContext || <span class="built_in">window</span>.AudioContext)();</div><div class="line">        <span class="keyword">var</span> audioInput = context.createMediaStreamSource(stream);</div><div class="line">        <span class="keyword">var</span> createScript = context.createScriptProcessor || context.createJavaScriptNode;</div><div class="line">        <span class="keyword">var</span> recorder = createScript.apply(context, [<span class="number">4096</span>, <span class="number">1</span>, <span class="number">1</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> audioData = &#123;</div><div class="line">            <span class="attr">size</span>: <span class="number">0</span>, <span class="comment">//录音文件长度</span></div><div class="line">            buffer: [], <span class="comment">//录音缓存</span></div><div class="line">            inputSampleRate: context.sampleRate, <span class="comment">//输入采样率</span></div><div class="line">            inputSampleBits: <span class="number">16</span>, <span class="comment">//输入采样数位 8, 16</span></div><div class="line">            outputSampleRate: config.sampleRate, <span class="comment">//输出采样率</span></div><div class="line">            oututSampleBits: config.sampleBits, <span class="comment">//输出采样数位 8, 16</span></div><div class="line">            input: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.buffer.push(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(data));</div><div class="line">                <span class="keyword">this</span>.size += data.length;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">compress</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//合并压缩</span></div><div class="line">                <span class="comment">//合并</span></div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="keyword">this</span>.size);</div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.buffer.length; i++) &#123;</div><div class="line">                    data.set(<span class="keyword">this</span>.buffer[i], offset);</div><div class="line">                    offset += <span class="keyword">this</span>.buffer[i].length;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//压缩</span></div><div class="line">                <span class="keyword">var</span> compression = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputSampleRate / <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> length = data.length / compression;</div><div class="line">                <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(length);</div><div class="line">                <span class="keyword">var</span> index = <span class="number">0</span>,</div><div class="line">                    j = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (index &lt; length) &#123;</div><div class="line">                    result[index] = data[j];</div><div class="line">                    j += compression;</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">encodeWAV</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> sampleRate = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleRate, <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> sampleBits = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleBits, <span class="keyword">this</span>.oututSampleBits);</div><div class="line">                <span class="keyword">var</span> bytes = <span class="keyword">this</span>.compress();</div><div class="line">                <span class="keyword">var</span> dataLength = bytes.length * (sampleBits / <span class="number">8</span>);</div><div class="line">                <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">44</span> + dataLength);</div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">                <span class="keyword">var</span> channelCount = <span class="number">1</span>; <span class="comment">//单声道</span></div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">var</span> writeString = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">                        data.setUint8(offset + i, str.charCodeAt(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 资源交换文件标识符 </span></div><div class="line">                writeString(<span class="string">'RIFF'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 下个地址开始到文件尾总字节数,即文件大小-8 </span></div><div class="line">                data.setUint32(offset, <span class="number">36</span> + dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// WAV文件标志</span></div><div class="line">                writeString(<span class="string">'WAVE'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形格式标志 </span></div><div class="line">                writeString(<span class="string">'fmt '</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 过滤字节,一般为 0x10 = 16 </span></div><div class="line">                data.setUint32(offset, <span class="number">16</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 格式类别 (PCM形式采样数据) </span></div><div class="line">                data.setUint16(offset, <span class="number">1</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 通道数 </span></div><div class="line">                data.setUint16(offset, channelCount, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 采样率,每秒样本数,表示每个通道的播放速度 </span></div><div class="line">                data.setUint32(offset, sampleRate, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8 </span></div><div class="line">                data.setUint32(offset, channelCount * sampleRate * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8 </span></div><div class="line">                data.setUint16(offset, channelCount * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 每样本数据位数 </span></div><div class="line">                data.setUint16(offset, sampleBits, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 数据标识符 </span></div><div class="line">                writeString(<span class="string">'data'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 采样数据总数,即数据总大小-44 </span></div><div class="line">                data.setUint32(offset, dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 写入采样数据 </span></div><div class="line">                <span class="keyword">if</span> (sampleBits === <span class="number">8</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset++) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        <span class="keyword">var</span> val = s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>;</div><div class="line">                        val = <span class="built_in">parseInt</span>(<span class="number">255</span> / (<span class="number">65535</span> / (val + <span class="number">32768</span>)));</div><div class="line">                        data.setInt8(offset, val, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset += <span class="number">2</span>) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        data.setInt16(offset, s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Blob([data], &#123; <span class="attr">type</span>: <span class="string">'audio/wav'</span> &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">//开始录音</span></div><div class="line">        <span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 需要先清理 buffer</span></div><div class="line">            audioData.size = <span class="number">0</span>;</div><div class="line">            audioData.buffer = [];</div><div class="line">            audioInput.connect(recorder);</div><div class="line">            recorder.connect(context.destination);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//停止</span></div><div class="line">        <span class="keyword">this</span>.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            recorder.disconnect();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取音频文件</span></div><div class="line">        <span class="keyword">this</span>.getBlob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.stop();</div><div class="line">            <span class="keyword">return</span> audioData.encodeWAV();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回放</span></div><div class="line">        <span class="keyword">this</span>.play = <span class="function"><span class="keyword">function</span>(<span class="params">audio</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> blob = <span class="keyword">this</span>.getBlob()</div><div class="line">            audio.src = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">            __log(<span class="string">"录音结束，Wav 大小: "</span> + blob.size + <span class="string">"B Wav 地址: "</span> + audio.src)</div><div class="line">            audio.controls = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//上传</span></div><div class="line">        <span class="keyword">this</span>.upload = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();</div><div class="line">            fd.append(<span class="string">"audioData"</span>, <span class="keyword">this</span>.getBlob());</div><div class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line"></div><div class="line">                    __log(xhr.responseText)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (callback) &#123;</div><div class="line">                xhr.upload.addEventListener(<span class="string">"progress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'uploading'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'ok'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'error'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"abort"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'cancel'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">            xhr.open(<span class="string">"POST"</span>, url);</div><div class="line">            xhr.send(fd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//音频采集</span></div><div class="line">        recorder.onaudioprocess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            audioData.input(e.inputBuffer.getChannelData(<span class="number">0</span>));</div><div class="line">            <span class="comment">//record(e.inputBuffer.getChannelData(0));</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//抛出异常</span></div><div class="line">    HZRecorder.throwError = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">            alert(message);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> message; &#125; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是否支持录音</span></div><div class="line">    HZRecorder.canRecording = (navigator.getUserMedia != <span class="literal">null</span>);</div><div class="line">    <span class="comment">//获取录音机</span></div><div class="line">    HZRecorder.get = <span class="function"><span class="keyword">function</span>(<span class="params">callback, config</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (callback) &#123;</div><div class="line">            <span class="keyword">if</span> (navigator.getUserMedia) &#123;</div><div class="line">                navigator.getUserMedia(&#123; <span class="attr">audio</span>: <span class="literal">true</span> &#125; <span class="comment">//只启用音频</span></div><div class="line">                    ,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</div><div class="line">                        <span class="keyword">var</span> rec = <span class="keyword">new</span> HZRecorder(stream, config);</div><div class="line">                        callback(rec);</div><div class="line">                    &#125;,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">                        <span class="keyword">switch</span> (error.code || error.name) &#123;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PERMISSION_DENIED'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PermissionDeniedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'用户拒绝提供信息。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NOT_SUPPORTED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NotSupportedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'浏览器不支持硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MANDATORY_UNSATISFIED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MandatoryUnsatisfiedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法发现指定的硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">default</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法打开麦克风。异常信息:'</span> + (error.code || error.name));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                HZRecorder.throwErr(<span class="string">'当前浏览器不支持录音功能。'</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">window</span>.HZRecorder = HZRecorder;</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>至此，前端的工作就告一段落，主要工作就是录音，并把 44100Hz 16bit 的 wav 文件上传到后端，并等待后端返回语音识别结果。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>虽然前端做的工作不多，但其实后端要做的也不多，毕竟是调用别人的接口嘛，要再这么麻烦就没有人用啦。所以后端要做的工作主要分两个部分，对于有 Restful API 的服务来说，就是准备数据，对于只有 Linux C SDK 的服务来说，就是用 Go 去调用 C SDK，接下来我们先讲讲共用的部分，然后分别说说不同服务需要注意的地方。</p>
<p>共用的部分就是改变录音的采样率，前面提到浏览器默认的采样率是 44100Hz，我们需要转变成 16000Hz 的，考虑到 44100 并不能整除 16000，所以简单的采样一定会导致频率的变化，但是不用紧张，我们还有两大法宝 <code>ffmpeg</code> 和 <code>sox</code>。转码的命令也很简单，以下两个任选一个即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ffmpeg -i input.wav -ar 16000 output.wav</div><div class="line"><span class="comment"># or</span></div><div class="line">sox input.wav -r 16000 output.wav</div></pre></td></tr></table></figure>
<p>然后我们就要以转码后的 <code>output.wav</code> 为基础，进行下面的操作了。使用 Restful API 需要注意的就是不同平台有不同的加密、验证方式和不同的参数，但无论如何音频文件需要用 Base64 编码，然后只要写一个通用的工具方法即可，这里不多说，主要还是说一下如何去用 Go 调用 C SDK（主要参考的是 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a> 的代码）。</p>
<p>首先就是从讯飞的语音云平台上下载 SDK，然后把 SDK 内的文件放到一个名为 <code>xf</code> 的文件夹中，就叫做 <code>package xf</code> 好了。目录大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">├── README.md</div><div class="line">├── include</div><div class="line">│   ├── convert.h</div><div class="line">│   ├── msp_cmn.h</div><div class="line">│   ├── msp_errors.h</div><div class="line">│   ├── msp_types.h</div><div class="line">│   ├── qise.h</div><div class="line">│   ├── qisr.h</div><div class="line">│   └── qtts.h</div><div class="line">├── libs</div><div class="line">│   ├── x64</div><div class="line">│   │   └── libmsc.so</div><div class="line">│   └── x86</div><div class="line">│       └── libmsc.so</div><div class="line">└── xf.go</div></pre></td></tr></table></figure>
<p>着重讲两个文件，一个是 <code>xf.go</code>（相当于是 C SDK 的 Wrapper），另一个是 <code>convert.h</code>（是参照讯飞的官方例子改的）。我们先来看看 <code>convert.h</code>，实际上就是用 C 来完成语音识别的调用（代码略长，感兴趣的同学估计得慢慢理解）。留意一下 <code>run_iat</code> 这个核心函数的返回值 <code>char *</code>，后面在 <code>xf.go</code> 中有用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qisr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_cmn.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_errors.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFER_SIZE	4096</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_LEN	640 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HINTS_SIZE  100</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">run_iat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* audio_file)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* session_begin_params	=	<span class="string">"sub = iat, domain = iat, language = zh_cn, accent = mandarin, sample_rate = 16000, result_type = plain, result_encoding = utf8"</span>;</div><div class="line">    <span class="keyword">char</span> *retstr = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*		session_id					=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>			rec_result[BUFFER_SIZE]		=	&#123;<span class="string">'\0'</span>&#125;;	</div><div class="line">	<span class="keyword">char</span>			hints[HINTS_SIZE]			=	&#123;<span class="string">'\0'</span>&#125;; <span class="comment">//hints为结束本次会话的原因描述，由用户自定义</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	total_len					=	<span class="number">0</span>; </div><div class="line">	<span class="keyword">int</span>				aud_stat					=	MSP_AUDIO_SAMPLE_CONTINUE ;		<span class="comment">//音频状态</span></div><div class="line">	<span class="keyword">int</span>				ep_stat						=	MSP_EP_LOOKING_FOR_SPEECH;		<span class="comment">//端点检测</span></div><div class="line">	<span class="keyword">int</span>				rec_stat					=	MSP_REC_STATUS_SUCCESS ;			<span class="comment">//识别状态</span></div><div class="line">	<span class="keyword">int</span>				errcode						=	MSP_SUCCESS ;</div><div class="line"></div><div class="line">	FILE*			f_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>*			p_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_count					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_size					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			read_size					=	<span class="number">0</span>;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == audio_file)</div><div class="line">    &#123;</div><div class="line">        retstr = <span class="string">"[Error] 文件名为空"</span>;</div><div class="line">        <span class="keyword">goto</span> iat_exit;</div><div class="line">    &#125;</div><div class="line">		</div><div class="line"></div><div class="line">	f_pcm = fopen(audio_file, <span class="string">"rb"</span>);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == f_pcm) </div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 打开音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nopen [%s] failed! \n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_END);</div><div class="line">	pcm_size = ftell(f_pcm); <span class="comment">//获取音频文件大小 </span></div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_SET);		</div><div class="line"></div><div class="line">	p_pcm = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pcm_size);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == p_pcm)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 无法分配内存"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nout of memory! \n"</span>);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	read_size = fread((<span class="keyword">void</span> *)p_pcm, <span class="number">1</span>, pcm_size, f_pcm); <span class="comment">//读取音频文件内容</span></div><div class="line">	<span class="keyword">if</span> (read_size != pcm_size)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 读取音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nread [%s] error!\n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n开始语音听写 ...\n"</span>);</div><div class="line">	session_id = QISRSessionBegin(<span class="literal">NULL</span>, session_begin_params, &amp;errcode); <span class="comment">//听写不需要语法，第一个参数为NULL</span></div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] QISRSessionBegin 失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRSessionBegin failed! error code:%d\n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">10</span> * FRAME_LEN; <span class="comment">// 每次写入200ms音频(16k，16bit)：1帧音频20ms，10帧=200ms。16k采样率的16位音频，一帧的大小为640Byte</span></div><div class="line">		<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (pcm_size &lt; <span class="number">2</span> * len) </div><div class="line">			len = pcm_size;</div><div class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		aud_stat = MSP_AUDIO_SAMPLE_CONTINUE;</div><div class="line">		<span class="keyword">if</span> (<span class="number">0</span> == pcm_count)</div><div class="line">			aud_stat = MSP_AUDIO_SAMPLE_FIRST;</div><div class="line"></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;"</span>);</div><div class="line">		ret = QISRAudioWrite(session_id, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;p_pcm[pcm_count], len, aud_stat, &amp;ep_stat, &amp;rec_stat);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != ret)</div><div class="line">		&#123;</div><div class="line">            retstr = <span class="string">"[Error] QISRAudioWrite 失败"</span>;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d\n"</span>, ret);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">			</div><div class="line">		pcm_count += (<span class="keyword">long</span>)len;</div><div class="line">		pcm_size  -= (<span class="keyword">long</span>)len;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (MSP_REC_STATUS_SUCCESS == rec_stat) <span class="comment">//已经有部分听写结果</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">			<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">			&#123;</div><div class="line">                retstr = <span class="string">"QISRGetResult failed"</span>;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed! error code: %d\n"</span>, errcode);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">				total_len += rslt_len;</div><div class="line">				<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">					retstr = <span class="string">"[Error] Buffer 太小"</span>;</div><div class="line">                    <span class="keyword">goto</span> iat_exit;</div><div class="line">				&#125;</div><div class="line">				<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (MSP_EP_AFTER_SPEECH == ep_stat)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		usleep(<span class="number">200</span>*<span class="number">1000</span>); <span class="comment">//模拟人说话时间间隙。200ms对应10帧的音频</span></div><div class="line">	&#125;</div><div class="line">	errcode = QISRAudioWrite(session_id, <span class="literal">NULL</span>, <span class="number">0</span>, MSP_AUDIO_SAMPLE_LAST, &amp;ep_stat, &amp;rec_stat);</div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d \n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (MSP_REC_STATUS_COMPLETE != rec_stat) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed, error code: %d\n"</span>, errcode);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">			total_len += rslt_len;</div><div class="line">			<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">		&#125;</div><div class="line">		usleep(<span class="number">150</span>*<span class="number">1000</span>); <span class="comment">//防止频繁占用CPU</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n语音听写结束\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,rec_result);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line"></div><div class="line">    retstr = rec_result;</div><div class="line"></div><div class="line">iat_exit:</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != f_pcm)</div><div class="line">	&#123;</div><div class="line">		fclose(f_pcm);</div><div class="line">		f_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != p_pcm)</div><div class="line">	&#123;	<span class="built_in">free</span>(p_pcm);</div><div class="line">		p_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	QISRSessionEnd(session_id, hints);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> retstr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们来看看对 C SDK 的封装，这里采用了 cgo 的方案，具体的不展开，我们直接上 <code>xf.go</code> 的代码（很短，没想到吧，另外 <code>import &quot;C&quot;</code> 这句和上面的注释之间不能有空行）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> xf</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">#cgo CFLAGS:-g -Wall -I ./include</div><div class="line">#cgo LDFLAGS:-L./lib -lmsc -lrt -ldl -lpthread</div><div class="line"></div><div class="line">#include "convert.h"</div><div class="line"></div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	loginParams := <span class="string">"appid = your_app_id, work_dir = ."</span></div><div class="line">	ret := C.MSPLogin(<span class="literal">nil</span>, <span class="literal">nil</span>, C.CString(loginParams))</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"登录成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logout</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	ret := C.MSPLogout()</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"注销成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpeechToText</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// https://golang.org/cmd/cgo/</span></div><div class="line">	<span class="comment">// 需要在执行前 export LD_LIBRARY_PATH=/usr/local/lib</span></div><div class="line">	<span class="comment">// 如果改动了 c++ 文件，需要改动这个调用 C 的文件，才会进行重新编译，不然一直是老的</span></div><div class="line">	<span class="comment">// 官方例子中是支持 wav 的（不需要转换了）</span></div><div class="line">	<span class="comment">// ffmpeg -i output.wav -f s16be -acodec pcm_s16be output.pcm</span></div><div class="line">	fmt.Println(<span class="string">"004"</span>)</div><div class="line">	retstr := C.run_iat(C.CString(filename))</div><div class="line">	<span class="keyword">return</span> C.GoString(retstr), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 Go 的 <code>string</code> 到 C 的 <code>char*</code> 可以使用 <code>C.CString()</code>，反过来可以使用 <code>C.GoString()</code> 来转换。转换完成之后，把结果返回给前端即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像游戏评测一样，来个打分，满分十分</p>
<ul>
<li>接入方便程度<ul>
<li>腾讯: 9.0</li>
<li>百度: 8.5</li>
<li>讯飞: 5.0</li>
</ul>
</li>
<li>用户体验<ul>
<li>百度: 9.0</li>
<li>腾讯: 8.0</li>
<li>讯飞: 6.0</li>
</ul>
</li>
<li>识别效果（基于小样本的主观判断）<ul>
<li>讯飞: 8.0</li>
<li>百度: 7.5</li>
<li>腾讯: 6.0</li>
</ul>
</li>
</ul>
<p>在这里希望讯飞能够更加互联网/接地气一些，不然用起来真的挺麻烦的（不知道大客户是不是有其他待遇）</p>
<h2 id="附录-音频格式知识"><a href="#附录-音频格式知识" class="headerlink" title="附录: 音频格式知识"></a>附录: 音频格式知识</h2><p>WAV：wav是一种无损的音频文件格式，WAV符合 PIFF(Resource Interchange File Format)规范。所有的WAV都有一个文件头，这个文件头音频流的编码参数。WAV对音频流的编码没有硬性规定，除了PCM之外，还有几乎所有支持ACM规范的编码都可以为WAV的音频流进行编码。</p>
<p>PCM:PCM（Pulse Code Modulation—-脉码调制录音)。所谓PCM录音就是将声音等模拟信号变成符号化的脉冲列，再予以记录。PCM信号是由[1]、[0]等符号构成的数字信号，而未经过任何编码和压缩处理。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的影响效果。</p>
<p>简单来说：wav是一种无损的音频文件格式，pcm是没有压缩的编码方式。</p>
<p>WAV可以使用多种音频编码来压缩其音频流，不过我们常见的都是音频流被PCM编码处理的WAV，但这不表示WAV只能使用PCM编码，MP3编码同样也可以运用在WAV中，和AVI一样，只要安装好了相应的Decode，就可以欣赏这些WAV了。在Windows平台下，基于PCM编码的WAV是被支持得最好的音频格式，所有音频软件都能完美支持，由于本身可以达到较高的音质的要求，因此，WAV也是音乐编辑创作的首选格式，适合保存音乐素材。因此，基于PCM编码的WAV被作为了一种中介的格式，常常使用在其他编码的相互转换之中，例如MP3转换成WMA。<a href="http://blog.csdn.net/u014434080/article/details/53261433" target="_blank" rel="external">来源</a></p>
<p>采样的位数指的是描述数字信号所使用的位数。8 位(8 bit)代表 2 的 8 次方即 256，16 位(16 bit)则代表 2 的 16 次方即 65536 / 1024 = 64K</p>
<p>采样率是一秒钟内对声音信号的采样次数</p>
<p>网络接收一个音频的时长是 20ms, 已知音频采样率是 8kHz，采样的位数是 16bit。<code>[时长]20ms * [采样率]8kHz * [采样的位数]16bit = 320 byte</code></p>
<p>例如，CD 采用16位的采样精度，44.1KHz 的采样频率，为双声道，它每秒所需要的数据量为 <code>16×44100×2÷8＝176400</code> 字节。这样算下来，比特率应该是 1400 多 Kbps，如果采用 MP3、WMA 编码格式，比特率能够更小。<a href="http://www.wuroom.com/post/122/" target="_blank" rel="external">来源</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a></li>
<li><a href="https://www.v2ex.com/t/342898" target="_blank" rel="external">纯 HTML5 实现的录音功能，支持回放和上传</a></li>
<li><a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="Web" scheme="http://wdxtub.com/tags/Web/"/>
    
      <category term="语音" scheme="http://wdxtub.com/tags/%E8%AF%AD%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用操作指南</title>
    <link href="http://wdxtub.com/2017/07/10/linux-operation-guide/"/>
    <id>http://wdxtub.com/2017/07/10/linux-operation-guide/</id>
    <published>2017-07-10T01:04:50.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="压缩解压-tar"><a href="#压缩解压-tar" class="headerlink" title="压缩解压 tar"></a>压缩解压 tar</h2><p>如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 <code>tar</code> 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。</p>
<p>使用 <code>tar</code> 命令只要记得参数是『必选+自选+<code>f</code>』即可，我们先来看看『必选！五选一』:</p>
<ol>
<li><code>-c</code> 意为 create，表示创建压缩包</li>
<li><code>-x</code> 意为 extract，表示解压</li>
<li><code>-t</code> 表示查看内容</li>
<li><code>-r</code> 给压缩包追加文件</li>
<li><code>-u</code> 意为 update，更新压缩包中的文件</li>
</ol>
<p>注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如：</p>
<ul>
<li><code>-z</code> 使用 gzip 属性</li>
<li><code>-j</code> 使用 bz2 属性</li>
<li><code>-Z</code> 使用 compress 属性</li>
<li><code>-v</code> 意为 verbose，显示详细的操作过程</li>
<li><code>-O</code> 将文件输出到标准输出</li>
</ul>
<p>然后最后一个一定要是 <code>f</code> 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 假设我们有很多 .md 文件需要打包，那么可以使用</span></div><div class="line">tar -cf posts.tar *.md <span class="comment"># c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用</span></div><div class="line">tar -rf posts.tar *.txt <span class="comment"># r 是追加文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用</span></div><div class="line">tar -uf post.tar hello.md <span class="comment"># u 是更新</span></div><div class="line"></div><div class="line"><span class="comment"># 压缩好了，我们来看看压缩包的内容，可以使用</span></div><div class="line">tar -tf posts.tar <span class="comment"># t 是列出文件内容</span></div><div class="line"></div><div class="line"><span class="comment"># 把压缩包发送到其他位置之后，需要解压，可以使用</span></div><div class="line">tar -xf posts.tar <span class="comment"># x 是解压</span></div></pre></td></tr></table></figure>
<p>加入自选参数后的用法（要不要加 v 可以看个人喜好）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># tar.gz 相关</span></div><div class="line">tar -czf posts.tar.gz *.md <span class="comment"># 压缩</span></div><div class="line">tar -xzf posts.tar.gz <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.bz2 相关</span></div><div class="line">tar -cjf posts.tar.bz2 *.md <span class="comment"># 压缩</span></div><div class="line">tar -xjf posts.tar.bz2 <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.Z 相关</span></div><div class="line">tar -cZf posts.tar.Z *.md <span class="comment"># 压缩</span></div><div class="line">tar -xZf posts.tar.Z <span class="comment"># 解压</span></div></pre></td></tr></table></figure>
<p>总结一波，遇到不同类型的文件，请用不同的套路来应对：</p>
<ul>
<li><code>*.tar</code> -&gt; <code>tar -xf</code></li>
<li><code>*.tar.gz</code> -&gt; <code>tar -xzf</code></li>
<li><code>*.tar.bz2</code> -&gt; <code>tar -xjf</code></li>
<li><code>*.tar.Z</code> -&gt; <code>tar -xZf</code></li>
<li><code>*.gz</code> -&gt; <code>gzip -d</code></li>
<li><code>*.rar</code> -&gt; <code>unrar e</code></li>
<li><code>*.zip</code> -&gt; <code>unzip</code></li>
</ul>
<h2 id="空间占用-du"><a href="#空间占用-du" class="headerlink" title="空间占用 du"></a>空间占用 du</h2><p>很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 显示当前文件下 Top 10 空间占用的文件/目录，</span></div><div class="line"><span class="comment"># s 表示不显示每个子目录或文件的大小</span></div><div class="line"><span class="comment"># h 表示用更加自然的方式显示（比如 K/M/G 这样）</span></div><div class="line">du -sh * | sort -nr | head</div></pre></td></tr></table></figure>
<h2 id="系统状态-top"><a href="#系统状态-top" class="headerlink" title="系统状态 top"></a>系统状态 top</h2><p>了解系统状态一般少不了 <code>top</code> 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看某用户的进程</span></div><div class="line">top -u wdxtub</div><div class="line"></div><div class="line"><span class="comment"># 进入系统状态显示后，具体值代表的意思是</span></div><div class="line"><span class="comment"># PR    进程优先级，越小优先级越高</span></div><div class="line"><span class="comment"># VIRT  占用的虚拟内存</span></div><div class="line"><span class="comment"># RES   占用的物理内存</span></div><div class="line"><span class="comment"># SHR   占用的共享内存</span></div><div class="line"><span class="comment"># S     进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）</span></div><div class="line"><span class="comment"># TIME+ 进程启动后占用的总 CPU 时间</span></div><div class="line"></div><div class="line"><span class="comment"># 可以按照不同的指标排序显示，按对应键即可</span></div><div class="line"><span class="comment"># P 按照 CPU 使用率排序</span></div><div class="line"><span class="comment"># T 按照 MITE+ 排序</span></div><div class="line"><span class="comment"># M 按内存使用占比排序</span></div></pre></td></tr></table></figure>
<p>其他查看进程相关信息的命令有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看进程内存分布</span></div><div class="line">pmap <span class="_">-d</span> 12345 <span class="comment"># 12345 是进程号</span></div><div class="line"></div><div class="line"><span class="comment"># 按照内存排序，这里的 grep 可以过滤特定的用户</span></div><div class="line">ps <span class="_">-e</span> -o <span class="string">'pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid'</span> | grep wdxtub | sort nrk5</div></pre></td></tr></table></figure>
<h2 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 find"></a>查找 find</h2><p>在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 找出七天前的文件</span></div><div class="line">find / -type f -mtime +7 -print</div><div class="line"><span class="comment"># / 表示从根目录中查找</span></div><div class="line"><span class="comment"># -type f 表示找出系统普通文件，不包含目录</span></div><div class="line"><span class="comment"># -mtime +n 表示寻找 n 天前的数据</span></div><div class="line"><span class="comment"># -print 打印文件名称</span></div><div class="line"></div><div class="line"><span class="comment"># 找出并删除七天前的文件</span></div><div class="line">find /temp/ -type f -mtime +7 -print -exec rm <span class="_">-f</span> &#123;&#125; \;</div><div class="line"><span class="comment"># -exec 表示后面执行系统命令</span></div><div class="line"><span class="comment"># &#123;&#125; 只有该符号能跟在命令你后面</span></div><div class="line"><span class="comment"># \; 结束符号</span></div><div class="line">find /temp/ -type f -mtime +7 -print | xargs rm <span class="_">-f</span></div><div class="line"><span class="comment"># 使用管道和 xargs = -exec</span></div><div class="line"></div><div class="line"><span class="comment"># 查找 /var 下最大的十个文件</span></div><div class="line">find /var -type f -ls | sort -k 7 -r -n | head</div><div class="line"></div><div class="line"><span class="comment"># 查找 /var/log 下大于 5GB 的文件</span></div><div class="line">find /var/<span class="built_in">log</span>/ -type f -size +5120M -exec ls -lh &#123;&#125; \;</div><div class="line"></div><div class="line"><span class="comment"># 找出今天所有文件并将它们拷贝到另一个目录</span></div><div class="line">find /home/wdxtub/ -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;</div></pre></td></tr></table></figure>
<h2 id="远程登录-ssh"><a href="#远程登录-ssh" class="headerlink" title="远程登录 ssh"></a>远程登录 ssh</h2><ul>
<li><code>ssh -vvv username@ip</code> ssh 的 debug 模式</li>
<li><code>ssh -i key.pem username@ip</code> 用 pem key 登录 ssh</li>
</ul>
<h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>这里是一些比较零碎的命令行技巧</p>
<ul>
<li><code>openssl rand -hex n</code> 产生随机的十六进制数，n 是字符数 </li>
<li><code>source /path/to/filename</code> 在当前 shell 里执行一个文件里的命令</li>
<li><code>${variable:0:5}</code> 截取变量的前五个字符</li>
<li><code>wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs</code> 用 wget 抓取完整的网站目录结构，存放到本地目录中</li>
<li><code>mkdir -p /home/wdxtub/{test0,test1,test2}</code> 一次创建多个目录</li>
<li><code>dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img</code> 测试硬盘写入速度</li>
<li><code>hdparm -Tt /dev/sda</code> 测试硬盘读取速度</li>
<li><code>echo -n &quot;test&quot; | md5sum</code> 获取文本的 md5</li>
<li><code>curl -I http://wdxtub.com</code> 获取 HTTP 头信息</li>
<li><code>netstat -tln4 | awk &#39;{print $4}&#39; | cut -f2 -d: | grep -o &#39;[0-9]*&#39;</code> 显示所有 tcp4 监听端口</li>
<li><code>time command</code> 查看命令的运行时间</li>
<li><code>export</code> 查看所有的环境变量</li>
<li><code>cmp file1 file2</code> 文件内容对比</li>
<li><code>cat -n file</code> 内容前面会显示行号</li>
<li><code>lsof -i:22</code> 查看 22 端口现在运行的程序</li>
<li><code>lsof -c abc</code> 显示 abc 进程现在打开的文件</li>
<li><code>lsof -p 12</code> 看进程号为 12 的进程打开了哪些文件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="运维" scheme="http://wdxtub.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>深度学习平台设计指南</title>
    <link href="http://wdxtub.com/2017/06/05/deep-learning-platform-design/"/>
    <id>http://wdxtub.com/2017/06/05/deep-learning-platform-design/</id>
    <published>2017-06-05T01:18:40.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了更好理解深度学习平台的定位和作用，我先来讲两个小故事。</p>
<h3 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h3><p>一位侠客来到大师面前，有气无力地问到：『大师，我已拿到了各种极品装备，本人的属性值也超高，为什么我还是没办法行走江湖呢？』</p>
<p>大师头也不抬说：『因为你都快饿死了，身体已经撑不住，这些属性和装备又有什么用呢？』</p>
<h3 id="故事二"><a href="#故事二" class="headerlink" title="故事二"></a>故事二</h3><p>实验室最新打造了一台号称最智能的汽车，老板和研究组长在发布仪式后一起试乘。汽车开动之后体验了各种智能功能，老板觉得很满意，于是说：『来我们换个档飙一把』。</p>
<p>研究组长面露难色，语音操作车停下，然后下车打开前盖，开始把车里的芯片换成另一个档的芯片，之后再上车、启动。</p>
<p>老板说：『这不行，用户体验智能了，但是车的体验智障了』</p>
<h3 id="阅读理解"><a href="#阅读理解" class="headerlink" title="阅读理解"></a>阅读理解</h3><p>第一个故事说的是深度学习平台的建设一定是要基于公司目前的状况和未来的发展，不然用的技术再先进，没有对业务产生价值，那就是拿公司的未来做慈善了。毕竟公司都倒了，有这么个平台又有什么用呢？</p>
<p>第二个故事说的是深度学习目前落地的一些痛点，因为暂时没有一个成熟的流程体系，从研发到真正应用到产品上，中间的环节繁琐易出错不说，也没有一个统一的管理、监控的最佳实践。虽然交付给用户和客户的产品是『智能』的，但创造智能的过程是『智障』的，所以平台的作用在于探索和规范，把软件工程的成功实践应用到以深度学习为代表的人工智能技术上。</p>
<h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><p>因为深度学习的工程化远不如传统软件成熟，大部分时候小公司的训练流程是这样的：</p>
<ul>
<li>研究人员在本地测试算法</li>
<li>通过 SSH 和各类辅助工具把代码上传到服务器</li>
<li>修改代码进行各类数据配置</li>
<li>进行测试</li>
<li>测试后人工收集结果</li>
</ul>
<p>最开始只有一两台机器，一两张 GPU 卡的时候，这个方案是最简单粗暴，所需要的人工成本也较低。但随着单机多卡甚至多机多卡的全面铺开，随着在线流程和离线机器的不断增加，原来的方法难以为继，需要更有效率且更科学的方式来组织整个从研发到落地低流程，这也正是深度学习平台的价值所在。（感谢炳廷修改错别字）</p>
<h2 id="平台定位"><a href="#平台定位" class="headerlink" title="平台定位"></a>平台定位</h2><p>从前面的故事中我们可以把平台的具体定位细化一下，简单来说是：</p>
<ul>
<li>高效支持业务。提高业务的效率是第一位的<ul>
<li>包括业务的新增、调整、删除</li>
<li>各个步骤都应该是可以配置的，最好有 Web UI 来可视化编辑（避免通过改脚本，因为很容易出错）</li>
</ul>
</li>
<li>高效支持研发。尽量少侵入研发原有的流程，或提供外部工具支持<ul>
<li>研发过程是非结构化、敏捷的，需要有机制把测试好的算法规范化</li>
<li>结果验证和测试的自动化，版本化，便于跟踪对比算法效果</li>
<li>尽量给研发人员最大的自由度的同时，保证系统的鲁棒性</li>
<li>减少不必要的训练，根据业务的需求支持峰谷的利用</li>
</ul>
</li>
<li>连接已有系统。做信息中枢，用统一的架构提高资源利用率和信息的流转速度<ul>
<li>把原来单机的脚本改造成集群操作</li>
<li>利用分布式存储打通各台机器的存储，统一输入与输出</li>
<li>计算资源池化，考虑跨地区，跨云的解决方案</li>
</ul>
</li>
</ul>
<h2 id="需求分解"><a href="#需求分解" class="headerlink" title="需求分解"></a>需求分解</h2><p>不同用户角色对系统的需求也是不一样的，按照通常的分类方法，这里把系统需求以科研、后台、产品、运维四个角度来进行划分，具体如下：</p>
<h3 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h3><p>算法的研发人员最关心的只有一个事情：如何快速测试验证算法，查看算法效果。</p>
<p>在此基础上对其工作流程不能侵入太多，毕竟各有各的工作习惯，不能也没必要做太多要求，只要保证输入、运算和输出的接口一致即可（当然需要一定的修改，尽量简单或提供转换工具）。所以对于科研来说，难点在于如何在整合现有本地和服务器上的训练流程的同时，保持整个逻辑的简洁，并且让每个步骤都可配置。</p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>后台的开发人员最关心的只有一个问题：如何保证服务的高效稳定，如何缩短业务部署上线或做其他调整的时间。</p>
<p>这就意味着能自动化的流程要尽量自动化，因为深度学习平台主要关注于深度学习本身，所以只要和后台系统能够自动对接，并且整个过程可以监控，能够容错（比如自动重试）。这部分其实跟传统的软件工程联系比较紧密，只要有老司机把关，基本问题不大，对好接口即可。（打个小广告，我司来自腾讯的老司机后台团队非常靠谱，有想写 C++ 的同学请联系我）</p>
<p>对于小公司来说，很多时候运维的工作也会逐步转为 DevOps 模式，在我看来，运维的核心就是有一种方法能够清晰快速了解系统的运行状态，出了问题能够在自动修复的基础上进行一定的通知和告警，这些都是能够集成到系统中的。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>产品最关心的是功能和交互是否达到了用户期待以及如何去跟踪各个功能点的表现。</p>
<p>虽说看起来这个跟深度学习关系不大，但实际上产品经理对深度学习（至少是流程）需要有一定的了解，这样才能做到『量体裁衣』，用合适的形式展示最智能的功能给用户提供最完美的体验（无论是 2B 还是 2C 都是如此）。</p>
<p>那么深度学习平台需要提供的是有实效性且可参考的模型训练及测试数据，这样无论是产品经理还是项目经理心理都更有数，在和客户沟通的时候更有把握。说白了这是一个期待值管理的问题，心里有底，自然不一样。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文简单从设计的角度介绍了我对深度学习平台的一些想法（因为是公司的项目，所以只能讲一下思路，具体就不展开了）。感谢 glen 总、杨老师、文博和 jelly 的指导和检查，除了设计指南，之后还会写一下技术实现上的难点和重点，希望大家喜欢。</p>
<hr>
<p>最后依然是一波招聘小广告</p>
<ul>
<li>能力要求：全栈 + Docker + K8S + Tensorflow + Spark</li>
<li>任务目标：搭建深度学习平台，开发深度学习算法</li>
<li>如果不甘心当个螺丝钉，为什么不来一起搞点事情呢？</li>
<li>联系方式：老读者都知道的，这里就不赘述了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="http://wdxtub.com/2017/06/05/k8s-note/"/>
    <id>http://wdxtub.com/2017/06/05/k8s-note/</id>
    <published>2017-06-05T01:06:25.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 开始学习</li>
</ul>
<h2 id="Kubernetes-基础"><a href="#Kubernetes-基础" class="headerlink" title="Kubernetes 基础"></a>Kubernetes 基础</h2><p>先来看一段来自<a href="http://www.paddlepaddle.org/doc_cn/howto/usage/k8s/k8s_basis_cn.html" target="_blank" rel="external">这里</a>的简介（我更新了一下链接）：</p>
<p>Kubernetes 是 Google 开源的容器集群管理系统，其提供应用部署、维护、扩展机制等功能，利用Kubernetes 能方便地管理跨机器运行容器化的应用。Kubernetes 可以在物理机或虚拟机上运行，且支持部署到 AWS，Azure，GCE 等多种公有云环境。介绍分布式训练之前，需要对 Kubernetes 有一个基本的认识，下面先简要介绍一下本文用到的几个 Kubernetes 概念。</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="external">Node</a> 表示一个 Kubernetes 集群中的一个工作节点，这个节点可以是物理机或者虚拟机，Kubernetes 集群就是由 node 节点与 master 节点组成的。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="external">Pod</a> 是一组(一个或多个)容器，pod 是 Kubernetes 的最小调度单元，一个 pod 中的所有容器会被调度到同一个 node 上。Pod 中的容器共享 NET，PID，IPC，UTS 等 Linux namespace。由于容器之间共享 NET namespace，所以它们使用同一个 IP 地址，可以通过 localhost 互相通信。不同 pod 之间可以通过IP地址访问。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="external">Job</a> 描述 Kubernetes 上运行的作业，一次作业称为一个 job，通常每个 job 包括一个或者多个pods，job 启动后会创建这些 pod 并开始执行一个程序，等待这个程序执行成功并返回 0 则成功退出，如果执行失败，也可以配置不同的重试机制。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="external">Volume</a> 存储卷，是 pod 内的容器都可以访问的共享目录，也是容器与 node 之间共享文件的方式，因为容器内的文件都是暂时存在的，当容器因为各种原因被销毁时，其内部的文件也会随之消失。通过 volume，就可以将这些文件持久化存储。Kubernetes 支持多种 volume，例如 hostPath(宿主机目录)，gcePersistentDisk，awsElasticBlockStore等。</li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="external">Namespaces</a> 命名空间，在 kubernetes 中创建的所有资源对象(例如上文的 pod，job)等都属于一个命名空间，在同一个命名空间中，资源对象的名字是唯一的，不同空间的资源名可以重复，命名空间主要为了对象进行逻辑上的分组便于管理。本文只使用了默认命名空间。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolume</a>: 和 <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolumeClaim</a> 结合，将外部的存储服务在 Kubernetes 中描述成为统一的资源形式，便于存储资源管理和 Pod 引用。</li>
</ul>
<p>如果看不懂，也没有关系，接下来会更详细介绍。PS. 官方文档很有灵性，建议有英文阅读能力的同学去通读一遍，这里只是我的一些学习笔记，不如原版这么有逻辑性。</p>
<p>Kubernetes 集群让多台机器像一个单一组件一样运行，但是有一个前提条件，就是应用需要被打包到容器里。打包好之后 Kubernetes 会自动化地以一种高效的形式去调度容器们。一个 Kubernetes 集群有两种类型的资源：</p>
<ul>
<li><strong>Master</strong> 负责调度集群，维护应用状态，扩展应用和滚动更新</li>
<li><strong>Nodes</strong> 负责运行各个应用。每个节点有一个 <code>Kubelet</code>，是在每个节点上的客户端，负责与 master 交流。一个 Kubernetes 集群至少需要 3 个 node。<ul>
<li>如果想要体验一下，可以使用 Minikube，会在单机上创建虚拟机来搭建集群（本文的教程也是用这个来展示的）</li>
</ul>
</li>
</ul>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; minikube version</div><div class="line">minikube version: v0.15.0-katacoda</div><div class="line"></div><div class="line"><span class="comment"># 启动集群</span></div><div class="line">$&gt; minikube start</div><div class="line">Starting <span class="built_in">local</span> Kubernetes cluster...</div><div class="line"></div><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; kubectl version</div><div class="line">Client Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"2017-01-12T04:57:25Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.4"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line">Server Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"1970-01-01T00:00:00Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.1"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># 查看集群状态</span></div><div class="line">$&gt; kubectl cluster-info</div><div class="line">Kubernetes master is running at http://host01:8080</div><div class="line">heapster is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/services/heap</div><div class="line">ster</div><div class="line">kubernetes-dashboard is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/s</div><div class="line">ervices/kubernetes-dashboard</div><div class="line">monitoring-grafana is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/ser</div><div class="line">vices/monitoring-grafana</div><div class="line">monitoring-influxdb is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/se</div><div class="line">rvices/monitoring-influxdb</div><div class="line"></div><div class="line"><span class="comment"># 获取可用的 node</span></div><div class="line">$&gt; kubectl get nodes</div><div class="line">NAME      STATUS    AGE</div><div class="line">host01    Ready     15m</div></pre></td></tr></table></figure>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>Kubernetes 集群启动之后，就可以在这之上部署应用了。部署应用的时候 master 会进行调度并选择合适的 node，启动之后仍旧会继续监控，一旦出问题，就会自动重新启用。</p>
<p>我们可以使用 Kubernetes 命令行工具 <code>Kubectl</code> 通过 Kubernetes API 来管理部署。创建部署的时候需要指定镜像和要运行的副本个数（当然也可以后面更新），然后们就实际来部署一波，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 部署应用</span></div><div class="line">$&gt; kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080</div><div class="line">mp:v1 --port=8080ubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootca</div><div class="line">deployment <span class="string">"kubernetes-bootcamp"</span> created</div><div class="line"></div><div class="line"><span class="comment"># 列出部署</span></div><div class="line">$&gt; kubectl get deployments</div><div class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">kubernetes-bootcamp   1         1         1            1           1m</div><div class="line"></div><div class="line"><span class="comment"># 查看部署</span></div><div class="line"><span class="comment"># 先通过 proxy 连接到正在运行的容器</span></div><div class="line">$&gt; kubectl proxy</div><div class="line">Starting to serve on 127.0.0.1:8001</div><div class="line"></div><div class="line"><span class="comment"># 然后打开一个新 tab，输出 Pod 名字</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-n7q3n</div><div class="line"></div><div class="line"><span class="comment"># 获取这个 pod 的输出</span></div><div class="line">$&gt; curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/<span class="variable">$POD_NAME</span>/</div><div class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-390780338-n7q3n | v=1</div></pre></td></tr></table></figure>
<h3 id="查看应用"><a href="#查看应用" class="headerlink" title="查看应用"></a>查看应用</h3><p>每个应用会在一个 Pod 中运行，一个 Pod 里可以有一个或多个应用（相当于给这些应用创建了一个共有的 localhost 环境，每个 pod 里的网络等环境是共享的）。</p>
<p>每个 Pod 都会运行在一个 Node 上，每个 Node 都由 Master 来管理。其中，每个 Node 都必须要有：</p>
<ul>
<li><code>Kubelet</code>，负责与 Master 通讯，管理 node 上运行的 pods 和 containers</li>
<li>一个容器的 runtime，比如 docker，用来从 registry 拉取镜像，解压与运行应用</li>
</ul>
<p>常用的 <code>kubectl</code> 命令有</p>
<ul>
<li><code>kubectl get</code> 列出所有的资源</li>
<li><code>kubectl describe</code> 显示资源的详细信息</li>
<li><code>kubectl logs</code> 输出一个 pod 中一个 container 的日志</li>
<li><code>kubectl exec</code> 在一个 pod 中的一个 container 中执行命令</li>
</ul>
<p>例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-6b9n3   1/1       Running   0          41m</div><div class="line"></div><div class="line"><span class="comment"># 查看 pods 详细信息</span></div><div class="line"><span class="comment"># 包括 镜像、IP 等各类信息，describe 不仅可以用于 pods，node 和 deployment 都可以</span></div><div class="line">$&gt; kubectl describe pods</div><div class="line">Name:           kubernetes-bootcamp-390780338-6b9n3</div><div class="line">Namespace:      default</div><div class="line">Node:           host01/172.17.0.41</div><div class="line">Start Time:     Mon, 05 Jun 2017 03:05:07 +0000</div><div class="line">Labels:         pod-template-hash=390780338</div><div class="line">                run=kubernetes-bootcamp</div><div class="line">Status:         Running</div><div class="line">IP:             172.18.0.2</div><div class="line">Controllers:    ReplicaSet/kubernetes-bootcamp-390780338</div><div class="line">Containers:</div><div class="line">  kubernetes-bootcamp:</div><div class="line">    Container ID:       docker://9308ecb7bb592255b5fb517ec7caa13703f7b5bb41a24145ba1eeb670693a60d</div><div class="line">    Image:              docker.io/jocatalin/kubernetes-bootcamp:v1</div><div class="line">    Image ID:           docker-pullable://jocatalin/kubernetes-bootcamp@sha256:0d6b8ee63bb5</div><div class="line">7c5f5b6156f446b3bc3b3c143d233037f3a2f00e279c8fcc64af</div><div class="line">    Port:               8080/TCP</div><div class="line">    State:              Running</div><div class="line">      Started:          Mon, 05 Jun 2017 03:05:08 +0000</div><div class="line">    Ready:              True</div><div class="line">    Restart Count:      0</div><div class="line">    Volume Mounts:</div><div class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-74qlr (ro)</div><div class="line">    Environment Variables:      &lt;none&gt;</div><div class="line">Conditions:</div><div class="line">  Type          Status</div><div class="line">  Initialized   True</div><div class="line">  Ready         True</div><div class="line">  PodScheduled  True</div><div class="line">Volumes:</div><div class="line">  default-token-74qlr:</div><div class="line">    Type:       Secret (a volume populated by a Secret)</div><div class="line">    SecretName: default-token-74qlr</div><div class="line">QoS Class:      BestEffort</div><div class="line">Tolerations:    &lt;none&gt;</div><div class="line">Events:</div><div class="line">  FirstSeen     LastSeen        Count   From                    SubObjectPath             Type             Reason          Message</div><div class="line">  ---------     --------        -----   ----                    -------------             -------- ------          -------</div><div class="line">  41m           41m             1       &#123;default-scheduler &#125;                              Normal           Scheduled       Successfully assigned kubernetes-bootcamp-390780338-6b9n3 to host01</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Pulled          Container image <span class="string">"docker.io/jocatalin/kubernetes-bootcamp:v1"</span> already present on machine</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Created         Created container with docker id 9308ecb7bb59; Security:[seccomp=unconfined]</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Started         Started container with docker id 9308ecb7bb</div><div class="line">59</div><div class="line"></div><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-6b9n3</div><div class="line"></div><div class="line"><span class="comment"># 查看 pod 日志</span></div><div class="line">$&gt; kubectl logs <span class="variable">$POD_NAME</span></div><div class="line">Kubernetes Bootcamp App Started At: 2017-06-05T03:05:08.494Z | Running On:  kubernetes-bootcamp-390780338-6b9n3</div></pre></td></tr></table></figure>
<h3 id="使用服务暴露应用"><a href="#使用服务暴露应用" class="headerlink" title="使用服务暴露应用"></a>使用服务暴露应用</h3><p>Pods 是有生命周期的，也有独立的 IP 地址，随着 Pods 的创建与销毁，一个必不可少的工作就是保证各个应用能够感知这种变化。这就要提到 Service 了，Service 是 YAML 或 JSON 定义的由 Pods 通过某种策略的逻辑组合。更重要的是，Pods 的独立 IP 需要通过 Service 暴露到网络中，有以下几种方式：</p>
<ul>
<li><code>ClusterIP</code>(默认)：只在集群内部可见的地址</li>
<li><code>NodePort</code>：可在集群外访问，需要指定端口</li>
<li><code>LoadBalancer</code>：创建一个负载均衡器，IP 是固定的</li>
<li><code>ExternalName</code>：使用任意的名字暴露服务</li>
</ul>
<p>依然是通过实例来感受一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看 pods 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-76skz   1/1       Running   0          6s</div><div class="line"></div><div class="line"><span class="comment"># 查看服务信息</span></div><div class="line">$&gt; kubectl get services</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</div><div class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP   47s</div><div class="line"></div><div class="line"><span class="comment"># 暴露服务</span></div><div class="line">$&gt; kubectl expose deployment/kubernetes-bootcamp --type=<span class="string">"NodePort"</span> --port 8080</div><div class="line">service <span class="string">"kubernetes-bootcamp"</span> exposed</div></pre></td></tr></table></figure>
<h3 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h3><p>当业务流量暴涨，就需要根据需要扩展应用（多几个 pods），具体的原理比较简单，我们直接来看例子：</p>
<p>TODO</p>
<h3 id="更新应用"><a href="#更新应用" class="headerlink" title="更新应用"></a>更新应用</h3><p>滚动更新可以保证 0 停机时间，其实逻辑和前面的扩展差不多，可以认为是用新版本的扩展，也直接来看例子：</p>
<p>TODO</p>
<h2 id="Hello-Minikube"><a href="#Hello-Minikube" class="headerlink" title="Hello Minikube"></a>Hello Minikube</h2><p>一个简单的教程，学习如何把本机的代码转换成 Kubernetes 可以使用的镜像</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hosted solution</p>
<p>turnkey cloud solutions</p>
<p>CentOS Version</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="external">Official Kubernetes Tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="集群" scheme="http://wdxtub.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Kubernetes" scheme="http://wdxtub.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之数据科学】TensorFlow 学习笔记</title>
    <link href="http://wdxtub.com/2017/05/31/tensorflow-learning-note/"/>
    <id>http://wdxtub.com/2017/05/31/tensorflow-learning-note/</id>
    <published>2017-05-31T09:05:32.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 开始更新</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>TensorFlow 是一个基于图计算的通用系统，常常被用于进行机器学习等任务。</p>
<p>TensorFlow 由<strong>张量</strong>(tensor)而得名，张量是多维的数组。一个向量是一维数组，我们称为一阶张量；一个矩阵是二维数组，我们称为二阶张量。名字中的 flow 表示计算的过程是基于图的，数据在图中流动。神经网络的训练和推断包含计算图中许多节点的矩阵计算的传播(propagation)</p>
<p>在 TensorFlow 中搞事的流程大概是：创建张量 -&gt; 添加计算操作 -&gt; 执行。很重要的一点是定义这些操作时，计算并不会立即执行，TensorFlow 在所有的操作添加完成后，会优化计算图，决定如何计算，最后才生成各种数据。正因如此，TensorFlow 中的 tensor 可以看作是一个占位符，等数据到来，然后执行计算。</p>
<p>我们来看看如何用 TensorFlow 做向量相加，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中的操作都需要在 Session 的上下文中进行，Session 本身保存计算图的信息（张量和操作）</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant([<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>])</div><div class="line">    input2 = tf.constant(<span class="number">2.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    input3 = tf.constant(<span class="number">3.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    output = tf.add(tf.add(input1, input2), input3)</div><div class="line">    <span class="comment"># 具体的计算在执行这一句时进行，因为 result 的值需要计算才可以得到，前面都是在定义计算图</span></div><div class="line">    result = output.eval()</div><div class="line">    print(<span class="string">"result: "</span>, result)</div></pre></td></tr></table></figure>
<p>处理完向量，我们来看看矩阵，其实也差不多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 矩阵相加</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant(<span class="number">1.0</span>, shape=[<span class="number">2</span>, <span class="number">3</span>])</div><div class="line">    input2 = tf.constant(np.reshape(np.arange(<span class="number">1.0</span>, <span class="number">7.0</span>, dtype=np.float32), (<span class="number">2</span>, <span class="number">3</span>)))</div><div class="line">    output = tf.add(input1, input2)</div><div class="line">    print(output.eval())</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input_features = tf.constant(np.reshape([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], (<span class="number">1</span>, <span class="number">4</span>)).astype(np.float32))</div><div class="line">    weights = tf.constant(np.random.randn(<span class="number">4</span>, <span class="number">2</span>).astype(np.float32))</div><div class="line">    output = tf.matmul(input_features, weights)</div><div class="line">    print(<span class="string">"Input:"</span>)</div><div class="line">    print(input_features.eval())</div><div class="line">    print(<span class="string">"Weights:"</span>)</div><div class="line">    print(weights.eval())</div><div class="line">    print(<span class="string">"Output:"</span>)</div><div class="line">    print(output.eval())</div></pre></td></tr></table></figure>
<p>前面我们都是用的 constant 常量，接下来我们搞一搞变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#@test &#123;"output": "ignore"&#125;</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置俩变量 total 和 weights，会不停变化</span></div><div class="line">    total = tf.Variable(tf.zeros([<span class="number">1</span>, <span class="number">2</span>]))</div><div class="line">    weights = tf.Variable(tf.random_uniform([<span class="number">1</span>,<span class="number">2</span>]))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化刚才定义的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 更新数值，但是这里并不会真的计算</span></div><div class="line">    update_weights = tf.assign(weigths, tf.random_uniform([<span class="number">1</span>, <span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</div><div class="line">    update_total = tf.assign(total, tf.add(total, weights))</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        <span class="comment"># 这里要先更新 weights 再更新 total</span></div><div class="line">        sess.run(update_weights)</div><div class="line">        sess.run(update_total)</div><div class="line">        </div><div class="line">        print(weights.eval(), total.eval())</div></pre></td></tr></table></figure>
<p>这里我们注意是先建模再计算这个流程即可。</p>
<h2 id="一个简单的神经网络"><a href="#一个简单的神经网络" class="headerlink" title="一个简单的神经网络"></a>一个简单的神经网络</h2><p>我们来构造一个非常简单的神经网络，来计算 x 和 y 这两个变量的线性回归。这个函数会为我们随机生成的带噪声的线性数据找到最合适的  $w_1$ 和 $w_2$，即满足 $y = w_2x+w_1$ 。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 设置带噪声的线性数据</span></div><div class="line">num_examples = <span class="number">50</span></div><div class="line"><span class="comment"># 这里会生成一个完全线性的数据</span></div><div class="line">X = np.array([np.linspace(<span class="number">-2</span>, <span class="number">4</span>, num_examples), np.linspace(<span class="number">-6</span>, <span class="number">6</span>, num_examples)])</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 这里给数据增加噪声</span></div><div class="line">X += np.random.randn(<span class="number">2</span>, num_examples)</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 我们的目标就是通过学习，找到一条拟合曲线，去还原最初的线性数据</span></div><div class="line"><span class="comment"># 把数据分离成 x 和 y</span></div><div class="line">x, y = X</div><div class="line"><span class="comment"># 添加固定为 1 的 bias</span></div><div class="line">x_with_bias = np.array([(<span class="number">1.</span>, a) <span class="keyword">for</span> a <span class="keyword">in</span> x]).astype(np.float32)</div><div class="line"></div><div class="line"><span class="comment"># 用来记录每次迭代的 loss，之后用于展示结果</span></div><div class="line">losses = []</div><div class="line"><span class="comment"># 迭代次数</span></div><div class="line">training_steps = <span class="number">50</span></div><div class="line"><span class="comment"># 学习率，也叫做步长，表示我们在梯度下降时每次迭代所前进的长度，过大则学不到准确的值，过小则训练太慢</span></div><div class="line">learning_rate = <span class="number">0.002</span></div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中所有的代码都需要在 session 中</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置所有的张量，变量和操作</span></div><div class="line">    <span class="comment"># 输入层是 x 值和 bias 节点</span></div><div class="line">    input = tf.constant(x_with_bias)</div><div class="line">    <span class="comment"># target 是 y 的值，需要被调整成正确的尺寸（就是转置一下）</span></div><div class="line">    target = tf.constant(np.transpose([y]).astype(np.float32))</div><div class="line">    <span class="comment"># weights 是变量，每次循环都会变，这里直接随机初始化（高斯分布，均值 0，标准差 0.1）</span></div><div class="line">    weights = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">1</span>], <span class="number">0</span>, <span class="number">0.1</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化所有的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 设置循环中所要做的全部操作</span></div><div class="line">    <span class="comment"># 对于所有的 x，根据现有的 weights 来产生对应的 y 值，也就是计算 y = w2 * x + w1 * bias</span></div><div class="line">    yhat = tf.matmul(input, weights)</div><div class="line">    <span class="comment"># 计算误差，也就是预计的 y 和真实的 y 的区别</span></div><div class="line">    yerror = tf.subtract(yhat, target)</div><div class="line">    <span class="comment"># 我们想要最小化 L2 损失，是误差的平方，会惩罚大误差，放过小误差</span></div><div class="line">    loss = tf.nn.l2_loss(yerror)</div><div class="line">    <span class="comment"># 上面的 loss 函数相当于</span></div><div class="line">    <span class="comment"># loss = 0.5 * tf.reduce_sum(tf.multiply(yerror, yerror))</span></div><div class="line">    </div><div class="line">    <span class="comment"># 执行梯度下降</span></div><div class="line">    <span class="comment"># 更新 weights，比如 weights += grads * learning_rate</span></div><div class="line">    <span class="comment"># 使用偏微分更新 weights</span></div><div class="line">    update_weights = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)</div><div class="line">    <span class="comment"># 上面的梯度下降相当于</span></div><div class="line">    <span class="comment"># gradient = tf.reduce_sum(tf.transpose(tf.multiply(input, yerror)), 1, keep_dims=True)</span></div><div class="line">    <span class="comment"># update_weights = tf.assign_sub(weights, learning_rate * gradient)</span></div><div class="line">    </div><div class="line">    <span class="comment"># 现在我们定义了所有的张量，也初始化了所有操作（每次执行梯度下降优化）</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(training_steps):</div><div class="line">        <span class="comment"># 重复跑，更新变量</span></div><div class="line">        update_weights.run()</div><div class="line">        <span class="comment"># 如果没有用 tf.train.GradientDescentOptimizer，就要用下面的方式</span></div><div class="line">        <span class="comment"># sess.run(update_weights)</span></div><div class="line">        </div><div class="line">        <span class="comment"># 记录每次迭代的 loss</span></div><div class="line">        losses.append(loss.eval())</div><div class="line">    </div><div class="line">    <span class="comment"># 训练结束</span></div><div class="line">    betas = weights.eval()</div><div class="line">    yhat = yhat.eval()</div><div class="line"></div><div class="line"><span class="comment"># 展示训练趋势</span></div><div class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">plt.subplots_adjust(wspace=<span class="number">.3</span>)</div><div class="line">fig.set_size_inches(<span class="number">10</span>, <span class="number">4</span>)</div><div class="line">ax1.scatter(x, y, alpha=<span class="number">.7</span>)</div><div class="line">ax1.scatter(x, np.transpose(yhat)[<span class="number">0</span>], c=<span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">line_x_range = (<span class="number">-4</span>, <span class="number">6</span>)</div><div class="line">ax1.plot(line_x_range, [betas[<span class="number">0</span>] + a * betas[<span class="number">1</span>] <span class="keyword">for</span> a <span class="keyword">in</span> line_x_range], <span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">ax2.plot(range(<span class="number">0</span>, training_steps), losses)</div><div class="line">ax2.set_ylabel(<span class="string">"Loss"</span>)</div><div class="line">ax2.set_xlabel(<span class="string">"Training steps"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="从零开始上手-MNIST-数据集"><a href="#从零开始上手-MNIST-数据集" class="headerlink" title="从零开始上手 MNIST 数据集"></a>从零开始上手 MNIST 数据集</h2><p>这是 Tensorflow 官方 Docker 镜像中的最后一篇教程，主要介绍如何利用 tf 完成手写数字的识别，这里我把 jupyter 的代码稍加改动（并加了些注释），方便大家在本地使用。</p>
<p>注：详细的解释都在注释里了，这里就不再赘述。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> gzip, binascii, struct, numpy</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> six.moves.urllib.request <span class="keyword">import</span> urlretrieve</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># 这里需要翻墙，不然下载巨慢</span></div><div class="line">SOURCE_URL = <span class="string">'http://yann.lecun.com/exdb/mnist/'</span></div><div class="line">WORK_DIRECTORY = <span class="string">"./mnist-data"</span></div><div class="line"></div><div class="line"><span class="comment"># 如果下载好了，那么就不会再次下载</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybe_download</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">"""A helper to download the data files if not present."""</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(WORK_DIRECTORY):</div><div class="line">        os.mkdir(WORK_DIRECTORY)</div><div class="line">    filepath = os.path.join(WORK_DIRECTORY, filename)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath):</div><div class="line">        filepath, _ = urlretrieve(SOURCE_URL + filename, filepath)</div><div class="line">        statinfo = os.stat(filepath)</div><div class="line">        print(<span class="string">'Successfully downloaded'</span>, filename, statinfo.st_size, <span class="string">'bytes.'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Already downloaded'</span>, filename)</div><div class="line">    <span class="keyword">return</span> filepath</div><div class="line"></div><div class="line"><span class="comment"># 这里把所有的训练数据都搞下来</span></div><div class="line">train_data_filename = maybe_download(<span class="string">'train-images-idx3-ubyte.gz'</span>)</div><div class="line">train_labels_filename = maybe_download(<span class="string">'train-labels-idx1-ubyte.gz'</span>)</div><div class="line">test_data_filename = maybe_download(<span class="string">'t10k-images-idx3-ubyte.gz'</span>)</div><div class="line">test_labels_filename = maybe_download(<span class="string">'t10k-labels-idx1-ubyte.gz'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 如果遇到 MacOS 的 Python as a framework 的问题，参考</span></div><div class="line"><span class="comment"># https://stackoverflow.com/questions/29433824/unable-to-import-matplotlib-pyplot-as-plt-in-virtualenv</span></div><div class="line"><span class="comment"># 这里我们先看看数据集里有什么，只是一个展示，并不会对图片进行预处理</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sanity_check</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_data_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'image count'</span>, <span class="string">'rows'</span>, <span class="string">'columns'</span>]:</div><div class="line">            <span class="comment"># struct.unpack reads the binary data provided by f.read.</span></div><div class="line">            <span class="comment"># The format string '&gt;i' decodes a big-endian integer, which</span></div><div class="line">            <span class="comment"># is the encoding of the data.</span></div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        <span class="comment"># Read the first 28x28 set of pixel values. </span></div><div class="line">        <span class="comment"># Each pixel is one byte, [0, 255], a uint8.</span></div><div class="line">        buf = f.read(<span class="number">28</span> * <span class="number">28</span>)</div><div class="line">        image = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    </div><div class="line">        <span class="comment"># Print the first few values of image.</span></div><div class="line">        print(<span class="string">'First 10 pixels:'</span>, image[:<span class="number">10</span>])</div><div class="line"></div><div class="line">        <span class="comment"># We'll show the image and its pixel value histogram side-by-side.</span></div><div class="line">        <span class="comment"># 输出原始图片和直方图，来看看具体的样子</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># To interpret the values as a 28x28 image, we need to reshape</span></div><div class="line">        <span class="comment"># the numpy array, which is one dimensional.</span></div><div class="line">        ax1.imshow(image.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(image, bins=<span class="number">20</span>, range=[<span class="number">0</span>,<span class="number">255</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里是把 [0, 255] 映射到 [-0.5, 0.5] 之后的展示</span></div><div class="line">        <span class="comment"># Let's convert the uint8 image to 32 bit floats and rescale </span></div><div class="line">        <span class="comment"># the values to be centered around 0, between [-0.5, 0.5]. </span></div><div class="line">        <span class="comment"># </span></div><div class="line">        <span class="comment"># We again plot the image and histogram to check that we </span></div><div class="line">        <span class="comment"># haven't mangled the data.</span></div><div class="line">        scaled = image.astype(numpy.float32)</div><div class="line">        scaled = (scaled - (<span class="number">255</span> / <span class="number">2.0</span>)) / <span class="number">255</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        ax1.imshow(scaled.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(scaled, bins=<span class="number">20</span>, range=[<span class="number">-0.5</span>, <span class="number">0.5</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里读取 Label，也是一个测试而已</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_labels_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'label count'</span>]:</div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line"></div><div class="line">        print(<span class="string">'First label:'</span>, struct.unpack(<span class="string">'B'</span>, f.read(<span class="number">1</span>))[<span class="number">0</span>]) </div><div class="line"></div><div class="line"><span class="comment"># 简单显示一下，然后进行之后的步骤</span></div><div class="line">sanity_check()</div><div class="line"></div><div class="line"><span class="comment"># 处理图片数据</span></div><div class="line">IMAGE_SIZE = <span class="number">28</span></div><div class="line">PIXEL_DEPTH = <span class="number">255</span></div><div class="line"></div><div class="line"><span class="comment"># 这个函数会提取并处理数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_data</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the images into a 4D tensor [image index, y, x, channels].</span></div><div class="line">  </div><div class="line">    For MNIST data, the number of channels is always 1.</div><div class="line"></div><div class="line">    Values are rescaled from [0, 255] down to [-0.5, 0.5].</div><div class="line">    """</div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and dimensions; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">16</span>)</div><div class="line"></div><div class="line">        buf = bytestream.read(IMAGE_SIZE * IMAGE_SIZE * num_images)</div><div class="line">        data = numpy.frombuffer(buf, dtype=numpy.uint8).astype(numpy.float32)</div><div class="line">        data = (data - (PIXEL_DEPTH / <span class="number">2.0</span>)) / PIXEL_DEPTH</div><div class="line">        data = data.reshape(num_images, IMAGE_SIZE, IMAGE_SIZE, <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> data</div><div class="line"></div><div class="line">train_data = extract_data(train_data_filename, <span class="number">60000</span>)</div><div class="line">test_data = extract_data(test_data_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这里把处理后的输出展示下</span></div><div class="line">print(<span class="string">'Training data shape'</span>, train_data.shape)</div><div class="line">_, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">ax1.imshow(train_data[<span class="number">0</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">ax2.imshow(train_data[<span class="number">1</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">plt.show()</div><div class="line"></div><div class="line"><span class="comment"># 接下来处理标签，我们需要把类别处理成向量，如果是第二类，那么对应 [0,1,0,...,0]，即第二个位置为 1</span></div><div class="line">NUM_LABELS = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_labels</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the labels into a 1-hot matrix [image index, label index]."""</span></div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and count; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">8</span>)</div><div class="line">        buf = bytestream.read(<span class="number">1</span> * num_images)</div><div class="line">        labels = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    <span class="comment"># Convert to dense 1-hot representation.</span></div><div class="line">    <span class="keyword">return</span> (numpy.arange(NUM_LABELS) == labels[:, <span class="keyword">None</span>]).astype(numpy.float32)</div><div class="line"></div><div class="line">train_labels = extract_labels(train_labels_filename, <span class="number">60000</span>)</div><div class="line">test_labels = extract_labels(test_labels_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 同样测试一下数据</span></div><div class="line">print(<span class="string">'Training labels shape'</span>, train_labels.shape)</div><div class="line">print(<span class="string">'First label vector'</span>, train_labels[<span class="number">0</span>])</div><div class="line">print(<span class="string">'Second label vector'</span>, train_labels[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 这里我们把数据分成训练、测试和验证集</span></div><div class="line">VALIDATION_SIZE = <span class="number">5000</span></div><div class="line"></div><div class="line">validation_data = train_data[:VALIDATION_SIZE, :, :, :]</div><div class="line">validation_labels = train_labels[:VALIDATION_SIZE]</div><div class="line">train_data = train_data[VALIDATION_SIZE:, :, :, :]</div><div class="line">train_labels = train_labels[VALIDATION_SIZE:]</div><div class="line"></div><div class="line">train_size = train_labels.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(<span class="string">'Validation shape'</span>, validation_data.shape)</div><div class="line">print(<span class="string">'Train size'</span>, train_size)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 这里开始定义模型</span></div><div class="line"><span class="comment"># 从原始输入开始，进行卷积(convolution)和池化(max pooling)处理，在全连接层之前会用 ReLU </span></div><div class="line"><span class="comment"># 作为激活函数，最后用 softmax 来处理输出，把类别信息转化成概率，训练的时候使用 Dropout</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># 准备模型可以分三步</span></div><div class="line"><span class="comment"># 1. 定义变量，来保存我们要训练的权重 weights</span></div><div class="line"><span class="comment"># 2. 定义模型的图结构</span></div><div class="line"><span class="comment"># 3. 把模型的图分别用于训练、测试和验证（复制几份）</span></div><div class="line"></div><div class="line"><span class="comment"># 先处理好变量</span></div><div class="line"><span class="comment"># 从效率的角度考虑，我们会把样本分组，这里是一个组的样本数量</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"><span class="comment"># 因为是灰度图，所以只有一个通道 channel</span></div><div class="line">NUM_CHANNELS = <span class="number">1</span></div><div class="line"><span class="comment"># 固定随机种子，保证每次的结果一致（不然没办法验证数据和模型）</span></div><div class="line">SEED = <span class="number">42</span></div><div class="line"></div><div class="line"><span class="comment"># 我们在这里把训练数据和类别标签『喂』给模型，不过这里只是一个占位符(placeholder)</span></div><div class="line"><span class="comment"># 真正训练的时候，这些节点在每一步会获取批量数据</span></div><div class="line">train_data_node = tf.placeholder(</div><div class="line">  tf.float32,</div><div class="line">  shape=(BATCH_SIZE, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS))</div><div class="line">train_labels_node = tf.placeholder(tf.float32,</div><div class="line">                                   shape=(BATCH_SIZE, NUM_LABELS))</div><div class="line"></div><div class="line"><span class="comment"># 对于验证和测试数据，直接保存到一个常量节点里即可（不存在训练的过程，不需要是变量）</span></div><div class="line">validation_data_node = tf.constant(validation_data)</div><div class="line">test_data_node = tf.constant(test_data)</div><div class="line"></div><div class="line"><span class="comment"># 下面的变量保存着所有的需要训练的权重。后面的参数定义了这些变量的初始化条件</span></div><div class="line"><span class="comment"># 用高斯分布初始化卷积的 weights</span></div><div class="line">conv1_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, NUM_CHANNELS, <span class="number">32</span>],  <span class="comment"># 5x5 filter, depth 32.</span></div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 初始的 bias 为 0</span></div><div class="line">conv1_biases = tf.Variable(tf.zeros([<span class="number">32</span>]))</div><div class="line"><span class="comment"># 第二层的卷积权重，32 个输入（对应上面的 32），然后下面是 64 维</span></div><div class="line">conv2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 同理，bias 也是 64 维，但是这里用 0.1</span></div><div class="line">conv2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">64</span>]))</div><div class="line"><span class="comment"># 然后是一个全连接的网络，共 512 维，为什么呢，因为我们有卷积和池化的存在，所以是 32*64/4</span></div><div class="line"><span class="comment"># (?这里我也不是很确定)</span></div><div class="line">fc1_weights = tf.Variable(  <span class="comment"># fully connected, depth 512.</span></div><div class="line">  tf.truncated_normal([IMAGE_SIZE // <span class="number">4</span> * IMAGE_SIZE // <span class="number">4</span> * <span class="number">64</span>, <span class="number">512</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc1_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">512</span>]))</div><div class="line">fc2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">512</span>, NUM_LABELS],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[NUM_LABELS]))</div><div class="line"></div><div class="line">print(<span class="string">'变量设置完毕'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义好了各种需要训练的变量，我们可以在 TensorFlow 图中把这些变量连起来了</span></div><div class="line"><span class="comment"># 这里我们用一个函数来返回我们需要的 tf graph，这里有一个参数来控制是训练还是其他</span></div><div class="line"><span class="comment"># 如果是训练，我们需要使用 dropout</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(data, train=False)</span>:</span></div><div class="line">    <span class="string">"""模型定义"""</span></div><div class="line">    <span class="comment"># 2D 卷积，使用相同 padding，意思是输入的 feature 大小和输出的一致，</span></div><div class="line">    <span class="comment"># strides 是一个四维数组 [image index, y, x, depth]</span></div><div class="line">    conv = tf.nn.conv2d(data,</div><div class="line">                        conv1_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 对卷积和偏置做 ReLU 操作</span></div><div class="line">    <span class="comment"># Bias and rectified linear non-linearity.</span></div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv1_biases))</div><div class="line"></div><div class="line">    <span class="comment"># 池化，这里我们的 pooling window 是 2，每个 stride 是 2</span></div><div class="line">    <span class="comment"># Max pooling. The kernel size spec ksize also follows the layout of</span></div><div class="line">    <span class="comment"># the data. Here we have a pooling window of 2, and a stride of 2.</span></div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line">    conv = tf.nn.conv2d(pool,</div><div class="line">                        conv2_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv2_biases))</div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 把 feature map 转为 2D 矩阵，并传给全连接网络</span></div><div class="line">    pool_shape = pool.get_shape().as_list()</div><div class="line">    reshape = tf.reshape(</div><div class="line">        pool,</div><div class="line">        [pool_shape[<span class="number">0</span>], pool_shape[<span class="number">1</span>] * pool_shape[<span class="number">2</span>] * pool_shape[<span class="number">3</span>]])</div><div class="line">  </div><div class="line">    <span class="comment"># Fully connected layer. Note that the '+' operation automatically</span></div><div class="line">    <span class="comment"># broadcasts the biases.</span></div><div class="line">    hidden = tf.nn.relu(tf.matmul(reshape, fc1_weights) + fc1_biases)</div><div class="line"></div><div class="line">    <span class="comment"># Add a 50% dropout during training only. Dropout also scales</span></div><div class="line">    <span class="comment"># activations such that no rescaling is needed at evaluation time.</span></div><div class="line">    <span class="keyword">if</span> train:</div><div class="line">        hidden = tf.nn.dropout(hidden, <span class="number">0.5</span>, seed=SEED)</div><div class="line">    <span class="keyword">return</span> tf.matmul(hidden, fc2_weights) + fc2_biases</div><div class="line"></div><div class="line"><span class="comment"># 定义了图的基本结构，我们就可以分别为 训练、测试和验证来提取模型了（也会根据不同的类型做一些自定义）</span></div><div class="line"><span class="comment"># train_prediction 保存训练的图，使用 cross-entropy loss 和 weight regularization</span></div><div class="line"><span class="comment"># 我们也会在训练的过程中调整学习率（通过 exponential_decay 操作来完成，会使用 MomentumOptimizer）</span></div><div class="line"></div><div class="line"><span class="comment"># 验证和测试的图比较简单，我们只需要使用验证和测试集作为输入，用 softmax 分类器作为输出</span></div><div class="line"></div><div class="line"><span class="comment"># 训练的计算</span></div><div class="line"><span class="comment"># Training computation: logits + cross-entropy loss.</span></div><div class="line">logits = model(train_data_node, <span class="keyword">True</span>)</div><div class="line">loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(</div><div class="line">  labels=train_labels_node, logits=logits))</div><div class="line"></div><div class="line"><span class="comment"># L2 正则化</span></div><div class="line"><span class="comment"># L2 regularization for the fully connected parameters.</span></div><div class="line">regularizers = (tf.nn.l2_loss(fc1_weights) + tf.nn.l2_loss(fc1_biases) +</div><div class="line">                tf.nn.l2_loss(fc2_weights) + tf.nn.l2_loss(fc2_biases))</div><div class="line"><span class="comment"># Add the regularization term to the loss.</span></div><div class="line">loss += <span class="number">5e-4</span> * regularizers</div><div class="line"></div><div class="line"><span class="comment"># Optimizer: set up a variable that's incremented once per batch and</span></div><div class="line"><span class="comment"># controls the learning rate decay.</span></div><div class="line">batch = tf.Variable(<span class="number">0</span>)</div><div class="line"><span class="comment"># Decay once per epoch, using an exponential schedule starting at 0.01.</span></div><div class="line">learning_rate = tf.train.exponential_decay(</div><div class="line">  <span class="number">0.01</span>,                <span class="comment"># Base learning rate.</span></div><div class="line">  batch * BATCH_SIZE,  <span class="comment"># Current index into the dataset.</span></div><div class="line">  train_size,          <span class="comment"># Decay step.</span></div><div class="line">  <span class="number">0.95</span>,                <span class="comment"># Decay rate.</span></div><div class="line">  staircase=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># Use simple momentum for the optimization.</span></div><div class="line">optimizer = tf.train.MomentumOptimizer(learning_rate,</div><div class="line">                                       <span class="number">0.9</span>).minimize(loss,</div><div class="line">                                                     global_step=batch)</div><div class="line"></div><div class="line"><span class="comment"># Predictions for the minibatch, validation set and test set.</span></div><div class="line">train_prediction = tf.nn.softmax(logits)</div><div class="line"><span class="comment"># We'll compute them only once in a while by calling their &#123;eval()&#125; method.</span></div><div class="line">validation_prediction = tf.nn.softmax(model(validation_data_node))</div><div class="line">test_prediction = tf.nn.softmax(model(test_data_node))</div><div class="line"></div><div class="line"><span class="comment"># 准备好了训练、测试和验证的模型之后，我们就可以来真正执行训练了。</span></div><div class="line"><span class="comment"># 所有的操作都需要在 session 中，在 python 中像是</span></div><div class="line"><span class="comment"># with tf.Session() as s:</span></div><div class="line"><span class="comment"># ...training / test / evaluation loop...</span></div><div class="line"></div><div class="line"><span class="comment"># 但是我们这里想要保持 session 方便我们去探索训练的过程，使用 InteractiveSession</span></div><div class="line"></div><div class="line"><span class="comment"># 我们先创建一个 session 并初始化我们刚才定义的变量</span></div><div class="line">s = tf.InteractiveSession()</div><div class="line"></div><div class="line"><span class="comment"># Use our newly created session as the default for subsequent operations.</span></div><div class="line">s.as_default()</div><div class="line"></div><div class="line"><span class="comment"># 初始化刚才定义的变量</span></div><div class="line">tf.global_variables_initializer().run()</div><div class="line"></div><div class="line"><span class="comment"># 我们现在可以开始训练了，这里我们用 minibatch 的方法（而不是一次只训练一个样本）</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"></div><div class="line"><span class="comment"># 提取第一个 batch 的数据和标签</span></div><div class="line"><span class="comment"># Grab the first BATCH_SIZE examples and labels.</span></div><div class="line">batch_data = train_data[:BATCH_SIZE, :, :, :]</div><div class="line">batch_labels = train_labels[:BATCH_SIZE]</div><div class="line"></div><div class="line"><span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line"><span class="comment"># node in the graph it should be fed to.</span></div><div class="line">feed_dict = &#123;train_data_node: batch_data,</div><div class="line">             train_labels_node: batch_labels&#125;</div><div class="line"></div><div class="line"><span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">_, l, lr, predictions = s.run(</div><div class="line">  [optimizer, loss, learning_rate, train_prediction],</div><div class="line">  feed_dict=feed_dict)</div><div class="line"></div><div class="line">print(predictions[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="comment"># The highest probability in the first entry.</span></div><div class="line">print(<span class="string">'First prediction'</span>, numpy.argmax(predictions[<span class="number">0</span>]))</div><div class="line"></div><div class="line"><span class="comment"># But, predictions is actually a list of BATCH_SIZE probability vectors.</span></div><div class="line">print(predictions.shape)</div><div class="line"></div><div class="line"><span class="comment"># So, we'll take the highest probability for each vector.</span></div><div class="line">print(<span class="string">'All predictions'</span>, numpy.argmax(predictions, <span class="number">1</span>))</div><div class="line"></div><div class="line">print(<span class="string">'Batch labels'</span>, numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"></div><div class="line">correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line">total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(float(correct) / float(total))</div><div class="line"></div><div class="line">confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"><span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">  confusions[predicted, actual] += <span class="number">1</span></div><div class="line"></div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_rate</span><span class="params">(predictions, labels)</span>:</span></div><div class="line">    <span class="string">"""Return the error rate and confusions."""</span></div><div class="line">    correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">    error = <span class="number">100.0</span> - (<span class="number">100</span> * float(correct) / float(total))</div><div class="line"></div><div class="line">    confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">    bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    <span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">        confusions[predicted, actual] += <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> error, confusions</div><div class="line"></div><div class="line"><span class="comment"># 这里训练 n 轮，每轮都是 minibatch</span></div><div class="line">train_round = <span class="number">3</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_round):</div><div class="line">    print(<span class="string">"Training Round "</span>, i+<span class="number">1</span> )</div><div class="line">    <span class="comment"># Train over the first 1/4th of our training set.</span></div><div class="line">    steps = train_size // BATCH_SIZE</div><div class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</div><div class="line">        <span class="comment"># Compute the offset of the current minibatch in the data.</span></div><div class="line">        <span class="comment"># Note that we could use better randomization across epochs.</span></div><div class="line">        offset = (step * BATCH_SIZE) % (train_size - BATCH_SIZE)</div><div class="line">        batch_data = train_data[offset:(offset + BATCH_SIZE), :, :, :]</div><div class="line">        batch_labels = train_labels[offset:(offset + BATCH_SIZE)]</div><div class="line">        <span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line">        <span class="comment"># node in the graph it should be fed to.</span></div><div class="line">        feed_dict = &#123;train_data_node: batch_data,</div><div class="line">                    train_labels_node: batch_labels&#125;</div><div class="line">        <span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">        _, l, lr, predictions = s.run(</div><div class="line">        [optimizer, loss, learning_rate, train_prediction],</div><div class="line">        feed_dict=feed_dict)</div><div class="line">        </div><div class="line">        <span class="comment"># Print out the loss periodically.</span></div><div class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            error, _ = error_rate(predictions, batch_labels)</div><div class="line">            print(<span class="string">'Step %d of %d'</span> % (step, steps))</div><div class="line">            print(<span class="string">'Mini-batch loss: %.5f Error: %.5f Learning rate: %.5f'</span> % (l, error, lr))</div><div class="line">            print(<span class="string">'Validation error: %.1f%%'</span> % error_rate(</div><div class="line">                validation_prediction.eval(), validation_labels)[<span class="number">0</span>])</div><div class="line"></div><div class="line">test_error, confusions = error_rate(test_prediction.eval(), test_labels)</div><div class="line">print(<span class="string">'Test error: %.1f%%'</span> % test_error)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'Actual'</span>)</div><div class="line">plt.ylabel(<span class="string">'Predicted'</span>)</div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, cas <span class="keyword">in</span> enumerate(confusions):</div><div class="line">    <span class="keyword">for</span> j, count <span class="keyword">in</span> enumerate(cas):</div><div class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</div><div class="line">            xoff = <span class="number">.07</span> * len(str(count))</div><div class="line">            plt.text(j-xoff, i+<span class="number">.2</span>, int(count), fontsize=<span class="number">9</span>, color=<span class="string">'white'</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.hist(numpy.argmax(test_labels, <span class="number">1</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="官方文档阅读笔记"><a href="#官方文档阅读笔记" class="headerlink" title="官方文档阅读笔记"></a>官方文档阅读笔记</h2><p>使用 TensorFlow，你必须明白 TensorFlow</p>
<ul>
<li>使用<strong>图</strong>(graph)来表示计算任务</li>
<li>在被称之为<strong>会话</strong>(Session)的<strong>上下文</strong>(context)中执行图</li>
<li>使用 tensor 表示数据</li>
<li>通过<strong>变量</strong>(Variable)维护状态</li>
<li>使用 feed 和 fetch 可以为<strong>任意的操作</strong>(arbitrary operation)赋值或者从其中获取数据</li>
</ul>
<p>TensorFlow 是一个编程系统，使用图来表示计算任务。图中的节点被称之为 op (operation 的缩写)。一个 op 获得 0 个或多个 Tensor，执行计算，产生 0 个或多个 Tensor。每个 Tensor 是一个类型化的多维数组。例如，你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是 <code>[batch, height, width, channels]</code>。</p>
<p>一个 TensorFlow 图描述了计算的过程。为了进行计算，图必须在<strong>会话</strong>里被启动。<strong>会话</strong>将图的 op 分发到诸如 CPU 或 GPU 之类的设备上，同时提供执行 op 的方法。这些方法执行后，将产生的 tensor 返回。在 Python 语言中, 返回的 tensor 是 numpy ndarray 对象；在 C 和 C++ 语言中，返回的 tensor 是 <code>tensorflow::Tensor</code> 实例。</p>
<ul>
<li>计算图<ul>
<li>TensorFlow 程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，op 的执行步骤被描述成一个图。在执行阶段，使用会话执行执行图中的 op。例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练 op。</li>
<li>TensorFlow 支持 C, C++, Python 编程语言。目前，TensorFlow 的 Python 库更加易用，它提供了大量的辅助函数来简化构建图的工作，这些函数尚未被 C 和 C++ 库支持.</li>
<li>三种语言的会话库 (session libraries) 是一致的。</li>
</ul>
</li>
<li>构建图<ul>
<li>构建图的第一步，是创建源 op (source op)。源 op 不需要任何输入，例如<strong>常量</strong>(Constant)。源 op 的输出被传递给其它 op 做运算</li>
<li>Python 库中，op 构造器的返回值代表被构造出的 op 的输出，这些返回值可以传递给其它 op 构造器作为输入</li>
<li>TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了</li>
</ul>
</li>
</ul>
<p>在实现上，TensorFlow 将图形定义转换成分布式执行的操作，以充分利用可用的计算资源(如 CPU 或 GPU). 一般你不需要显式指定使用 CPU 还是 GPU，TensorFlow 能自动检测。如果检测到 GPU，TensorFlow 会尽可能地利用找到的第一个 GPU 来执行操作。</p>
<p>如果机器上有超过一个可用的 GPU，除第一个外的其它 GPU 默认是不参与计算的。为了让 TensorFlow 使用这些 GPU，你必须将 op 明确指派给它们执行。<code>with...Device</code> 语句用来指派特定的 CPU 或 GPU 执行操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">  <span class="keyword">with</span> tf.device(<span class="string">"/gpu:1"</span>):</div><div class="line">    matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</div><div class="line">    matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</div><div class="line">    product = tf.matmul(matrix1, matrix2)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>设备用字符串进行标识。目前支持的设备包括:</p>
<ul>
<li>“/cpu:0”: 机器的 CPU</li>
<li>“/gpu:0”: 机器的第一个 GPU，如果有的话</li>
<li>“/gpu:1”: 机器的第二个 GPU，以此类推</li>
</ul>
<p>具体可见 <a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/how_tos/using_gpu.html" target="_blank" rel="external">使用 GPUs</a></p>
<p>文档的其他部分涉及到具体的算法细节，这里不再深究。</p>
<h2 id="GPU-相关"><a href="#GPU-相关" class="headerlink" title="GPU 相关"></a>GPU 相关</h2><ul>
<li>最合适测试 CUDA 的代码是使用 <code>log_device_placement</code> 参数<ul>
<li><code>sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))</code></li>
<li><code>print sess.run(c)</code></li>
<li>观察日志输出是否有 gpu0, gpu1</li>
</ul>
</li>
<li>检测 GPU 的使用率 <code>nvidia-smi -q -g 0 -d UTILIZATION -1</code></li>
<li><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Nvidia Docker</a><ul>
<li>TODO 需要看如何配置 docker 所能分配的 gpu</li>
</ul>
</li>
<li>tensorflow 在训练时默认占用所有 GPU 的显存，配置的方式有<ul>
<li>构造 <code>tf.Session()</code> 时配置参数（这里是按照百分比来选择），如<ul>
<li><code>gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.333)</code></li>
<li><code>sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</code></li>
<li><code>per_process_gpu_memory_fraction</code> 指定每个 GPU 进程中使用显存的上限，但只能作用于所有 GPU，不能根据不同 GPU 单独配置</li>
</ul>
</li>
<li>设置显存根据需求增长<ul>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.allow_growth=True</code></li>
<li><code>sess = tf.Session(config=config)</code></li>
</ul>
</li>
<li>在执行训练脚本前使用 <code>export CUDA_VISIBLE_DEVICES=1</code> 来限制可见的 GPU 数目，如果是 python 脚本，可以用 <code>CUDA_VISIBLE_DEVICES=1 python my_script.py</code>，如果想用两个卡，则是 <code>CUDA_VISIBLE_DEVICES=0,1</code>，如果禁用 GPU，则是 <code>CUDA_VISIBLE_DEVICES=&quot;&quot;</code><ul>
<li>可以参考 <a href="https://stackoverflow.com/questions/34775522/tensorflow-mutiple-sessions-with-mutiple-gpus" target="_blank" rel="external">Tensorflow multiple sessions with multiple GPUs</a></li>
</ul>
</li>
<li>也可以在 Python 代码中进行设置<ul>
<li><code>import os</code></li>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;</code></li>
</ul>
</li>
<li>如果需要同时限制显存大小，也按需增长，那么可以这样<ul>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0&#39;</code> 指定第一块 GPU 可用</li>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.per_process_gpu_memory_fraction = 0.5</code> 最多只能占用指定 gpu 50% 显存</li>
<li><code>config.gpu_options.allow_growth = True</code> 程序按需申请内存</li>
<li><code>sess = tf.Session(config = config)</code></li>
</ul>
</li>
<li>需要注意的是，虽然代码或配置层面设置了对显存占用百分比阈值，但实际中如果达到了，程序有需要的话还是会突破的，以上的显存限制仅仅为了跑小数据集时避免对显存的浪费</li>
</ul>
</li>
</ul>
<h2 id="Nvidia-Docker"><a href="#Nvidia-Docker" class="headerlink" title="Nvidia Docker"></a>Nvidia Docker</h2><ul>
<li><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Github</a></p>
</li>
<li><p>在 Nvidia Docker 层限制 GPU 资源</p>
<ul>
<li><code>NV_GPU=0,1 nvidia-docker run -it nvidia/cuda nvidia-smi</code></li>
<li>弄清楚 <code>nvidia_uvm</code> 是个啥</li>
<li><code>nvidia-docker</code> 相当于 <code>docker run --device=/dev/nvidiactl --device=/dev/nvidia-utm --device=/dev/nvidia0</code></li>
</ul>
</li>
<li>可以做到资源隔离，具体要测试下，看看提供了什么工具</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/Machine-Learning-Project" target="_blank" rel="external">项目源代码</a></li>
<li><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="external">TensorFlow 官方文档中文版（比较老）</a></li>
<li><a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">Awesome TensorFlow</a></li>
<li><a href="https://github.com/fluxcapacitor/pipeline" target="_blank" rel="external">PipelineIO - 收费</a></li>
<li><a href="https://github.com/polyaxon/polyaxon" target="_blank" rel="external">Polyaxon</a></li>
<li><a href="http://www.cnblogs.com/darkknightzh/p/6591923.html" target="_blank" rel="external">http://www.cnblogs.com/darkknightzh/p/6591923.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23250782" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23250782</a></li>
<li><a href="http://www.cnblogs.com/wangxiaocvpr/p/5902086.html" target="_blank" rel="external">http://www.cnblogs.com/wangxiaocvpr/p/5902086.html</a></li>
<li><a href="http://blog.csdn.net/luodongri/article/details/52596780" target="_blank" rel="external">http://blog.csdn.net/luodongri/article/details/52596780</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="http://wdxtub.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>【科学革命的结构】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/"/>
    <id>http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/</id>
    <published>2017-05-30T23:32:11.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这本书主要是强调范式对于科学的指导作用</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 完成初稿</li>
</ul>
<h2 id="历史的作用"><a href="#历史的作用" class="headerlink" title="历史的作用"></a>历史的作用</h2><p>如果我们主要是寻求和考察那些从科学教科书中得出的、不含历史的旧规老套的问题的回答贰继续使用历史资料的话，那么，新科学观就不可能从历史中产生。</p>
<h2 id="通向常规科学之路"><a href="#通向常规科学之路" class="headerlink" title="通向常规科学之路"></a>通向常规科学之路</h2><p>在本书中，『常规科学』是指坚实地建立在一种或多种过去科学成就基础上的研究，这些科学成就为某个学科共同体在一段时期内公认为是进一步实践的基础。这些著作之所以能起到这样的做用，就在于它们共同具有两个基本特征：</p>
<ul>
<li>它们的成就空前地吸引一批坚定的拥护者，使他们脱离科学活动的其他竞争形式。</li>
<li>这些成就足以无限制地为重新组成的一批实践者留下有待解决的种种问题</li>
</ul>
<p>凡是共有这两个特征的成就，我此后便称之为『范式』，这是一个与『常规科学』密切有关的术语。</p>
<p>一种范式通过革命向另一种范式的过渡便是成熟科学通常的发展模式。</p>
<h2 id="常规科学的本质"><a href="#常规科学的本质" class="headerlink" title="常规科学的本质"></a>常规科学的本质</h2><p>如果不是一门成熟科学的实际实践者，就很少有人会认识到一种范式给人们留下非常多的扫尾工作要做，而完成这些扫尾工作又是多么地令人迷醉。这两个要点人们必须理解到。大多数科学家倾其全部科学生涯所从事的正是这些扫尾工作。这些工作构成了我在这里所称的常规科学。</p>
<h2 id="常规科学即是解谜"><a href="#常规科学即是解谜" class="headerlink" title="常规科学即是解谜"></a>常规科学即是解谜</h2><p>一个科学家必须致力于理解世界，并扩展这种使世界有序化的精度和广度。这种承诺反过来又必定会导致科学家自己或他的同事以丰富的经验细致地考察自然界的某个方面。如果这种考察发现明显的无序(disorder)，那就迫使他精练他的观测技巧，或者迫使他进一步阐明他的理论。</p>
<p>常规科学是一种高度确定性的活动，但它又不必要完全由规则所确定。这就是为什么在本文开始时我引进共有范式而不用共有规则、假定和观点作为常规研究传统连贯性源泉的原因。我认为，规则导源于范式，但即使没有规则，范式仍能指导研究。</p>
<h2 id="反常与科学发现的突破"><a href="#反常与科学发现的突破" class="headerlink" title="反常与科学发现的突破"></a>反常与科学发现的突破</h2><p>在任何一门科学的发展过程中，最先接受的范式，通常会让人感觉到它对于科学研究者容易理解的大多数观察和实验，能给予相当成功的说明。因此，进一步的发展通产高要求建构精巧的装置，发展出一套深奥的词汇和技巧，精练概念，使之不断地减少与它们通常的常识原型(prototypes)之间的相似性。</p>
<h2 id="科学革命的本质与必然性"><a href="#科学革命的本质与必然性" class="headerlink" title="科学革命的本质与必然性"></a>科学革命的本质与必然性</h2><p>科学革命也起源于科学共同体中某一小部分人逐渐感觉到：他们无法利用现有范式有效地探究自然界的某一方面，而以前范式在这方面的研究是起引导作用的。</p>
<p>原则上，只有三类现象可以引发新理论。第一类是那些现存范式已妥为解释的现象，但它们很少成为科学家创建新理论的动机或出发点。第二类现象是指那些其本质已为现有范式所表明，但其细节的理解却有待范式的完善的现象，它们是科学家常规研究的对象。但是这种研究的目的在于完善现有范式，而非发明新范式。只有当这种完善工作失败后，科学家才会遭遇第三类现象，即公认的反常现象，其特征是无法被现有范式同化。只有这类现象才会促成新理论的发明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书主要是强调范式对于科学的指导作用&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="读书" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="科学" scheme="http://wdxtub.com/tags/%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【别让我思考】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/30/dont-make-me-think-clip/"/>
    <id>http://wdxtub.com/2017/05/30/dont-make-me-think-clip/</id>
    <published>2017-05-30T08:45:46.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.30: 完成初稿</li>
</ul>
<h2 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h2><p>Krug 可用性第一定律</p>
<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<h2 id="我们实际上是如何使用-Web-的"><a href="#我们实际上是如何使用-Web-的" class="headerlink" title="我们实际上是如何使用 Web 的"></a>我们实际上是如何使用 Web 的</h2><p>扫描，满意即可，勉强应付</p>
<p>我们一旦发现某个事物能够用（不管有多难用），我们也不太会去找一种更好的方法。，如果偶然发现一种更好的方法，我们会换用这种更好的方法，但很少会主动寻找更好的方法。</p>
<h2 id="广告牌设计-101-法则"><a href="#广告牌设计-101-法则" class="headerlink" title="广告牌设计 101 法则"></a>广告牌设计 101 法则</h2><p>为扫描设计，不为阅读设计</p>
<ul>
<li>在每个页面上建立清楚的视觉层次。</li>
<li>尽量利用习惯用法</li>
<li>把页面划分成明确定义的区域</li>
<li>明显标识可以点击的地方。</li>
<li>最大限度降低干扰</li>
</ul>
<h3 id="建立清楚的视觉层次"><a href="#建立清楚的视觉层次" class="headerlink" title="建立清楚的视觉层次"></a>建立清楚的视觉层次</h3><ul>
<li>越重要的部分越突出</li>
<li>逻辑上相关的部分在视觉上也相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ul>
<h2 id="动物、植物、无机物"><a href="#动物、植物、无机物" class="headerlink" title="动物、植物、无机物"></a>动物、植物、无机物</h2><p>为什么用户喜欢无须思考的选择</p>
<p>如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。</p>
<h2 id="省略不必要的文字"><a href="#省略不必要的文字" class="headerlink" title="省略不必要的文字"></a>省略不必要的文字</h2><p>不要在 Web 上写作的艺术</p>
<ul>
<li>去掉那些没有人会看的文字</li>
<li>欢迎词必须消灭</li>
<li>指示说明必须消灭</li>
</ul>
<h2 id="街头指示牌和面包屑"><a href="#街头指示牌和面包屑" class="headerlink" title="街头指示牌和面包屑"></a>街头指示牌和面包屑</h2><p>设计导航</p>
<p>关于页面名称，需要注意：</p>
<ul>
<li>每个页面都需要一个名称</li>
<li>页面名称要出现在合适的位置</li>
<li>名称要引人注目</li>
<li>名称要和点击的链接一致</li>
</ul>
<h2 id="首先要承认，主页不由你控制"><a href="#首先要承认，主页不由你控制" class="headerlink" title="首先要承认，主页不由你控制"></a>首先要承认，主页不由你控制</h2><p>设计主页</p>
<p>主页要完成的任务：</p>
<ul>
<li>站点的标识和使命</li>
<li>站点层次</li>
<li>搜索</li>
<li>导读</li>
<li>内容更新</li>
<li>友情链接</li>
<li>快捷方式</li>
<li>注册</li>
</ul>
<p>没有什么比得上一个好口号</p>
<ul>
<li>好的口号要清楚、言之有物</li>
<li>不好的口号含混不清</li>
<li>好的口号长度适中</li>
<li>好的口号能表述出网站的特点和显而易见的好处</li>
<li>不好的口号听起来太笼统</li>
<li>好的口号应该有个性、生动，有时候还很俏皮</li>
</ul>
<h2 id="农场主和牧牛人应该是朋友"><a href="#农场主和牧牛人应该是朋友" class="headerlink" title="农场主和牧牛人应该是朋友"></a>农场主和牧牛人应该是朋友</h2><p>为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况</p>
<p>争辩人们喜欢什么既浪费时间又消耗团队的经历，而通过测试将讨论对错转移到什么有效、什么无效上，更容易缓和争论、打破僵局，而且，测试会让我们看到用户的动机、理解、反应的不同，从而让我们不会再坚持认为用户的想法和我们的想法一样</p>
<h2 id="一天-10-美分的可用性测试"><a href="#一天-10-美分的可用性测试" class="headerlink" title="一天 10 美分的可用性测试"></a>一天 10 美分的可用性测试</h2><p>让测试简答 —— 这样你能进行充分的测试</p>
<ul>
<li>如果想建立一个优秀的网站，一定要测试</li>
<li>测试一个用户比不做测试好一倍</li>
<li>在项目中，早点测试一位用户好过最后测试 50 位用户</li>
<li>人们对招募用户代表的重要性估计过高</li>
<li>测试的关键不是要证明什么或者反驳什么，而是了解你的判断力</li>
<li>测试是一个迭代的过程</li>
<li>没有什么比现场用户的反应更重要</li>
</ul>
<h2 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h2><p>为什么你的网站应该让人尊敬</p>
<p>降低好感的几种方式</p>
<ul>
<li>隐藏我想要的信息</li>
<li>因为没有按照你们的方式行事而惩罚我</li>
<li>向我询问不必要的信息</li>
<li>敷衍我，欺骗我</li>
<li>给我设置障碍</li>
<li>你的网站看上去不专业</li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li>知道人们在你网站上想做什么，并让它们明白简单</li>
<li>高速我我想知道的</li>
<li>尽量减少步骤</li>
<li>花点心思</li>
<li>知道我可能有哪些疑问，并且给予解答</li>
<li>为我提供协助，例如打印友好页面</li>
<li>容易从错误中恢复</li>
<li>如有不确定，记得道歉</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="网页" scheme="http://wdxtub.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/27/deep-learning-clip/"/>
    <id>http://wdxtub.com/2017/05/27/deep-learning-clip/</id>
    <published>2017-05-27T00:32:59.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习作为人工智能时代最重要的技术之一，值得每一个 AI 从业者了解和学习，这里是我的读书笔记。</p>
<p>注：本笔记来源于<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="external">这里</a></p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.29: 完成阅读</li>
<li>2017.05.27: 开始阅读</li>
</ul>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><h3 id="数和数组"><a href="#数和数组" class="headerlink" title="数和数组"></a>数和数组</h3><ul>
<li>$\alpha$ 标量（整数或实数）</li>
<li>$\mathbf{\alpha}$ 向量</li>
<li>$A$ 矩阵</li>
<li>$\mathbf{A}$ 张量</li>
<li>$I_n$ n 行 n 列的单位矩阵</li>
<li>$I$ 维度蕴含于上下文的单位矩阵</li>
<li>$e^{(i)}$ 标准基向量 <code>[0,...,0,1,0,...,0]</code>，其中索引 i 处值为 1</li>
<li>$diag(\mathbf{\alpha})$ 对角方阵，其中对角元素由 $\mathbf{\alpha}$ 给定</li>
<li>$\mathrm{a}$ 标量随机变量</li>
<li>$\mathbf{a}$ 向量随机变量</li>
<li>$\mathrm{A}$ 矩阵随机变量</li>
</ul>
<h3 id="集合和图"><a href="#集合和图" class="headerlink" title="集合和图"></a>集合和图</h3><ul>
<li>$\mathbb{A}$ 集合</li>
<li>$\mathbb{R}$ 实数集</li>
<li>${0, 1}$ 包含 0 和 1 的集合</li>
<li>${0,1,\dots ,n}$ 包含 0 和 n 之间的所有整数的集合</li>
<li>$[a,b]$ 包含 a 和 b 的实数区间</li>
<li>$(a,b]$ 不包含 a 但包含 b 的实数区间</li>
<li>$\mathbb{A} \setminus \mathbb{B}$ 差集，即其元素包含于 $\mathbb{A}$ 但不包含于 $\mathbb{B}$</li>
<li>$\zeta$ 图</li>
<li>$Pa_\zeta(x_i )$ 图 $\zeta$ 中的父节点</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人工智能的真正挑战在于解决那些对人来说很容易执行但很难形式化描述的任务，人类往往可以凭借直觉轻易解决。</p>
<p>抽象和形式化的任务对人类而言是最困难的脑力任务之一，但对计算机而言却属于最容易的。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的，因此很难通过形式化的方式表达清除。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。</p>
<p>依靠硬编码的知识体系面对的困难表明，AI 系统需要具备自己获取知识的能力，即从原始数据中提取模式的能力，这种能力被称为机器学习。</p>
<p>在整个计算机科学乃至日常生活中，对表示的依赖都是一个普遍现象。在计算机科学中，如果数据集合被精巧地结构化并被智能地索引，那么诸如搜索之类的操作的处理速度就可以成指数级地加快。</p>
<p>许多人工智能任务都可以通过以下方式解决：先提取一个合适的特征集，然后将这些特征提供给简单的机器学习算法。然而，对于许多任务来说，我们很难知道应该提取哪些特征。</p>
<p>解决这个问题的途径之一是使用机器学习来发掘表示本身，而不仅仅把表示映射到输出，这种方法我们称为<strong>表示学习</strong>(representation learning)。</p>
<p>表示学习算法的典型例子是<strong>自编码器</strong>(autoencoder)。自编码器由一个<strong>编码器</strong>(encoder)和一个<strong>解码器</strong>(decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示，而解码器函数则将这个新的表示转换到原来的形式。我么期望当输入数据经过编码器和解码器之后尽可能多地保留信息，同时希望新的表示有各种号的特性，这也是自编码器的训练目标。为了实现不同的特性，我们可以设计不同形式的自编码器。</p>
<p>当设计特征或设计用于学习特征的算法时，我们的目标通常是分离出能解释观察数据的<strong>变差因素</strong>(factors of variation)。在许多现实的人工智能应用中，困难主要源于多个变差因素同时影响着我们能够观察到的每一个数据。</p>
<p><strong>深度学习</strong>(deep learning)通过其他较简单的表示来表达复杂表示，解决了表示学习中的核心问题。</p>
<p>联结主义的中心思想是，当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元，因为它和计算模型中隐藏单元起着类似的作用。</p>
<p>联结主义潮流的另一个重要成就是反向传播在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及。</p>
<h2 id="概率与信息论"><a href="#概率与信息论" class="headerlink" title="概率与信息论"></a>概率与信息论</h2><p>概率论是用于表示不确定性<strong>声明</strong>(statement)的数学框架。它不仅提供了量化不确定性的方法，也提供了用于导出新的不确定性声明的公里。在人工智能领域，概率论主要有两种用途。首先，概率法则告诉我们 AI 系统如何推理，据此我们设计一些算法来计算或者估算由概率论导出的表达式。其次，我们可以用概率和统计从理论上分析我们提出的 AI 系统的行为。</p>
<p>概率论使我们能够作出不确定的声明以及在不确定性存在的情况下进行推理，而信息论使我们能够量化概率分布中的不确定性总量。</p>
<p>如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用<strong>KL 散度</strong>(Kullback-Leibler(KL) divergence) 来衡量这两个分布的差异。KL 散度有很多有用的性质，最重要的是它是非负的。KL 散度为 0 当且仅当 P 和 Q 在离散型变量的情况下是相同的分布，或者在连续型变量的情况下是『几乎处处』相同的。</p>
<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p>连续数学在数字计算机上的根本困难是，我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时，几乎总会引入一些近似误差。在许多情况下，这仅仅是舍入误差。舍入误差会导致一些问题，特别是当许多操作复合时，即使是理论上可行的算法，如果在设计时没有考虑最小化舍入误差的积累，在实践时也可能会导致算法失效。</p>
<p>一种极具毁灭性的舍入误差是<strong>下溢</strong>(underflow)。当接近零的数被四舍五入为零时发生下溢。许多函数在其参数为零而不是一个很小的正数时才会表现出质的不同。另一个极具破坏力的数值错误形式是<strong>上溢</strong>(overflow)。</p>
<p>必须对上溢和下溢进行数值稳定的一个例子是 <strong>softmax 函数</strong>(softmax function)</p>
<h3 id="基于梯度的优化方法"><a href="#基于梯度的优化方法" class="headerlink" title="基于梯度的优化方法"></a>基于梯度的优化方法</h3><p>大多数深度学习算法都涉及某种形式的优化。我们把要最小化或最大化的函数称为<strong>目标函数</strong>(objective function)或<strong>准则</strong>(criterion)。当我们对其进行最小化时，我们也把它称为<strong>代价函数</strong>(cost function)、<strong>损失函数</strong>(loss function)或<strong>误差函数</strong>(error function)</p>
<p>KKT 方法。这部分数学，如果不想深究，也不需要过分在意</p>
<h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>机器学习本质上属于应用统计学，更多地关注于如何用计算机统计地估计复杂函数，不太关注为这些函数提供置信区间。</p>
<h3 id="促使深度学习发展的挑战"><a href="#促使深度学习发展的挑战" class="headerlink" title="促使深度学习发展的挑战"></a>促使深度学习发展的挑战</h3><p><strong>维数灾难</strong></p>
<p>当数据的维数很高时，很多机器学习问题变得相当困难。这种现象被称为<strong>维数灾难</strong>(curse of dimensionality)。特别值得注意的是，一组变量不同的可能配置数量会随着变量数目的增加贰指数级增长。</p>
<p><strong>局部不变性和平滑正则化</strong></p>
<h2 id="深度前馈网络"><a href="#深度前馈网络" class="headerlink" title="深度前馈网络"></a>深度前馈网络</h2><p><strong>深度前馈网络</strong>(deep feedforward network)，也叫做<strong>前馈神经网络</strong>(feedforward neural network)或者<strong>多层感知机</strong>(multilayer perceptron, MLP)，是典型的深度学习模型。前馈神经网络的目标是近似某个函数 $f^<em>$。例如，对于分类器，$y=f^</em>(\mathbf{x})$ 将输入 $\mathbf{x}$ 映射到一个类别 y。前馈网络定义了一个映射 $y=f(\mathbf{x};\theta)$，并且学习参数 $\theta$ 的值，使它能够得到最佳的函数近似。</p>
<p>这种模型被称为<strong>前向</strong>(feedforward)的，是因为信息留过 $\mathbf{x}$ 的函数，刘静用于定义 $f$ 的中间计算过程，最终到达输出 $y$。在模型的输出和模型本身之间没有<strong>反馈</strong>(feedback)连接。当前馈神经网络被扩展成包含反馈连接时，它们被称为<strong>循环神经网络</strong>(recurrent neural network)。</p>
<p>前馈神经网络被称作<strong>网络</strong>(network)是因为它们通常用许多不同函数复合起来一起表示。该模型与一个有向无环图相关联，而图描述了函数是如何复合在一起的。</p>
<p>网络中的每个隐藏层通常都是向量值的。这些隐藏层的维数决定了模型的<strong>宽度</strong>(width)。向量的每个元素都可以被视为起到类似一个神经元的做用。除了将层想象成向量到向量的单个函数，我们也可以把层想象成由许多并行操作的<strong>单元</strong>(unit)组成，每个单元表示一个向量到标量的函数。每个单元在某种意义上类似一个神经元，它接收的输入来源于许多其他的单元，并计算它自己的激活值。</p>
<h2 id="深度学习中的正则化"><a href="#深度学习中的正则化" class="headerlink" title="深度学习中的正则化"></a>深度学习中的正则化</h2><p>机器学习中的一个核心问题是设计不仅在训练数据上表现好，并且能在新输入上泛化好的算法。在机器学习中，许多策略显式地被设计为减少测试误差（可能会以增大训练误差为代价），这些策略被统称为正则化。事实上，开发更有效的正则化策略已成为本领域的主要研究工作之一。</p>
<p>目前为止，最流行和广泛使用的参数共享出现在应用于计算机视觉的<strong>卷积神经网络</strong>(CNN)中。自然图像有许多统计属性是对转换不变的。相同的特征（具有相同权重的隐藏单元）在输入的不同位置上计算获得。参数共享显著降低了 CNN 模型的参数数量，并显著提高了网络的大小贰不需要相应地增加训练数据。它仍然是将领域知识有效地整合到网络架构的最佳范例之一。</p>
<p><strong>Bagging</strong>(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。</p>
<p><strong>Dropout</strong>(Dropout)提供了正则化一大类模型的方法，计算方便但功能强大。在第一种近似下，Dropout 可以被认为是集成大量深层神经网络的实用 Bagging 方法。Bagging 涉及训练多个模型，并在每个测试样本上评估多个模型。</p>
<p>具体而言，Dropout 训练的集成包括所有从基础网络除去与非输出单元后形成的子网络。在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。参数共享使得在有限可用的内存下表示指数级数量的模型变得可能。在 Bagging 的情况下，每一个模型在其相应训练集上训练到收敛。在 Dropout 情况下，通常大部分模型都没有显式地被训练，因为通常父神经网络会很大，以至于到宇宙毁灭都不可能采样完所有的子网络。取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。</p>
<p>只有极少的训练样本可用时，Dropout 不会很有效。一个关于 Dropout 的重要见解是，通过随机行为训练网络并平均多个随机决定进行预测，实现了一种参数共享的 Bagging 形式。Dropout 不仅仅是训练一个 Bagging 的集成模型，并且是共享隐藏单元的继承模型。这意味着无论其他隐藏单元是否在模型中，每个隐藏单元都必须能够表现良好。隐藏单元必须准备好进行模型之间的交换和互换（有性生殖涉及到两个不同生物体之间交换基因，进化产生的压力使得基因不仅是良好的而且要准备好不同有机体之间的交换。这样的基因和这些特点对环境的变化是非常稳健的，因为它们一定会正确适应任何一个有机体或模型不寻常的特性）。因此 Dropout 正则化每个隐藏单元不仅是一个很好的特征，更要在许多情况下是良好的特征。</p>
<p>Dropout 强大的大部分原因来自施加到隐藏单元的掩码噪声，了解这一事实是重要的。这可以看作是对输入内容的信息高度智能化、自适应破坏的一种形式，而不是对输入原始值的破坏。</p>
<h2 id="深度模型中的优化"><a href="#深度模型中的优化" class="headerlink" title="深度模型中的优化"></a>深度模型中的优化</h2><p>随机梯度下降(SGD)及其变种很可能是一般机器学习中应用最多的优化算法，特别是在深度学习中。按照数据生成分布抽取 m 个小批量（独立同分布的）样本，通过计算它们梯度均值，我们可以得到梯度的无偏估计。SGD 算法中的一个关键参数是学习率。</p>
<p>虽然 SGD 仍然是非常受欢迎的优化方法，但其学习过程有时会很慢。<strong>动量</strong>(momentum)方法可以加速学习，特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。</p>
<h3 id="自适应学习率算法"><a href="#自适应学习率算法" class="headerlink" title="自适应学习率算法"></a>自适应学习率算法</h3><p><strong>AdaGrad</strong></p>
<p>AdaGrad 算法独立地适应所有模型参数的学习率，缩放每个参数反比于其所有梯度历史平方值综合的平方根。</p>
<p><strong>RMSProp</strong></p>
<p>RMSProp 算法修改 AdaGrad 以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。经验上，RMSProp 已被证明是一种有效且实用的深度神经网络优化算法。目前它是深度学习从业者经常采用的优化方法之一。</p>
<p><strong>Adam</strong></p>
<p>Adam 是另一种学习率自适应优化算法。Adam 通常被认为对超参数的选择相当鲁棒，尽管学习率有时需要从建议的默认修改。</p>
<h2 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h2><p><strong>卷积网络</strong>(convolutional network)，也叫做<strong>卷积神经网络</strong>(convolutional neural network, CNN)，是一种专门用来处理具有类似网格结构的数据的神经网络。例如时间序列数据（可以认为是在时间轴上有规律采样形成的一维网格）和图像数据（可以看作是二维的像素网格）。</p>
<p>卷积运算通过三个重要的思想来帮助改进机器学习系统：<strong>稀疏交互</strong>(sparse interactions)、<strong>参数共享</strong>(parameter sharing)、等变表示(equivariant representations)。</p>
<p>池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。例如<strong>最大池化</strong>(max pooling)函数给出相邻矩形区域内的最大值。其他常用的池化函数包括相邻矩形区域内的平均值、$L^2$范数以及基于据中心像素距离的加权平均函数。</p>
<p>不管采用什么样的池化函数，当输入作出少量平移时，池化能够帮助输入的表示近似<strong>不变</strong>(invariant)。因为池化综合了全部邻居的反馈，这使得池化单元少于探测单元成为可能，我们可以通过综合池化区域的 k 个像素的统计特征而不是单个像素来实现。</p>
<p>在很多任务中，池化对于处理不同大小的输入具有重要做用。例如我们想对不同大小的图像进行分类时，分类层的输入必须是固定的大小，而这通常通过调整池化区域的偏置大小来实现。</p>
<p>把卷积神经网络当作一个具有无限强先验的全连接网络来实现会导致极大的计算浪费。但把卷积神经网络想成具有无限强先验的全连接网络可以帮助我们更好地洞察卷积神经网络是如何工作的。</p>
<h2 id="序列建模：循环和递归网络"><a href="#序列建模：循环和递归网络" class="headerlink" title="序列建模：循环和递归网络"></a>序列建模：循环和递归网络</h2><p><strong>循环神经网络</strong>(recurrent neural network) 或 RNN 是一类用于处理序列数据的神经网络。</p>
<p>大多数 RNN 中的计算可以分解成三块参数及其相关的变换：</p>
<ol>
<li>从输入到隐藏状态</li>
<li>从前一隐藏状态到下一隐藏状态，以及</li>
<li>从隐藏状态到输出</li>
</ol>
<h2 id="实践方法论"><a href="#实践方法论" class="headerlink" title="实践方法论"></a>实践方法论</h2><p>要成功地使用深度学习技术，仅仅知道存在哪些算法和解释他们为何有效的原理是不够的。一个优秀的机器学习实践者还需要知道如何针对具体应用挑选一个合适的算法以及如何监控，并根据实验反馈改进机器学习系统。在机器学习系统的日常开发中，实践者需要决定是否收集更多的数据、增加或减少模型容量、添加或删除正则化项、改进模型的优化、改进模型的近似推断或调试模型的软件实现。尝试这些操作都需要大量时间，因此确定正确做法，而不盲目猜测尤为重要。</p>
<p>我们建议参考以下几个实践设计流程：</p>
<ul>
<li>确定目标 - 使用什么样的误差度量，并为此误差度量指定目标值。这些目标和误差度量取决于该应用旨在解决的问题</li>
<li>尽快建立一个端到端的工作流程，包括估计合适的性能度量</li>
<li>搭建系统，并确定性能瓶颈。检查哪个部分的性能差于预期，以及是否是因为过拟合、欠拟合，或者数据或软件缺陷造成的</li>
<li>根据具体观察反复地进行增量式的改动，如收集新数据、调整超参数或改进算法</li>
</ul>
<h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><p>对于大多数应用而言，不可能实现绝对零误差。即使你有无限的训练数据，并且恢复了真正的概率分布，贝叶斯误差仍定义了能达到的最小错误率。这是因为输入特征可能无法包含输出变量的完整信息，或是因为系统可能本质上是随机的。</p>
<p>在现实世界中，一个应用的错误率有必要是安全的、具有成本效益的或吸引消费者的。一旦你确定了想要达到的错误率，那么你的设计将由如何达到这个错误率来指导。</p>
<h3 id="决定是否收集更多数据"><a href="#决定是否收集更多数据" class="headerlink" title="决定是否收集更多数据"></a>决定是否收集更多数据</h3><p>在建立第一个端到端的系统后，就可以度量算法性能并决定如何改进算法。许多机器学习新手都忍不住尝试很多不同的算法。然而，收集更多的数据往往比改进学习算法要有用得多。</p>
<p>怎样判断是否要收集更多的数据？首先，确定训练集上的性能是否可接受。如果模型在训练集上的性能就很差，学习算法都不能在训练集上学习出良好的模型，那么就没必要收集更多的数据。反之，可以尝试增加更多的网络层或每层增加更多的隐藏单元，以增加模型的规模。此外，也可以调整学习率等超参数的措施来改进学习算法。如果更大的模型和仔细调试的优化算法效果不佳，那么问题可能源自训练数据的质量。数据可能含太多噪声，或是可能不包含预测输出所需的正确输入。这意味着我们需要重新开始，收集更干净的数据或是收集特征更丰富的数据集。</p>
<p>如果训练集上的性能是可接受的，那么我们开始度量测试集上的性能。如果测试集上的性能也是可以接受的，那么就顺利完成了。这时主要的考虑是收集更多数据的代价和可行性，其他方法降低误差的代价和可行性，和增加数据数量能否显著提升测试集性能。</p>
<h3 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h3><p>当一个机器学习系统效果不好时，通常很难判断效果不好的原因是算法本身，还是算法实现错误。由于各种原因，机器学习系统很难调试</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="大规模深度学习"><a href="#大规模深度学习" class="headerlink" title="大规模深度学习"></a>大规模深度学习</h3><p>深度学习的基本思想基于联结主义：尽管机器学习模型中单个生物性的神经元或者说是单个特征不是智能的，但是大量的神经元或者特征作用在一起往往能够表现出智能。由于规模的大小对于神经网络来说至关重要，因此深度学习需要高性能的硬件设施和软件实现。</p>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>一直以来，计算机视觉就是深度学习应用中几个最活跃的研究方向之一。因为视觉是一个对人类以及许多动物毫不费力，但对计算机却充满挑战的任务。</p>
<p><strong>预处理</strong></p>
<p>由于原始输入往往已深度学习架构难以表示的形式出现，许多应用领域需要复杂精细的预处理。计算机视觉通常只需要相对少的这种预处理。图像应该被标准化，从而使得它们的像素都在相同并且合理的范围内，比如 [0,1] 或者 [-1,1]。将 [0,1] 中的图像与 [0,255] 中的图像混合通常会导致失败。将图像格式化为相同比例严格上说是唯一一种必要的预处理。许多计算机视觉框架需要标准尺寸的图像，因此必须裁剪或缩放图像以适应该尺寸。</p>
<p><strong>对比度归一化</strong></p>
<p>在许多任务中，对比度是能够安全移除的最为明显的变化源之一。简单地说，对比度指的是图像中亮像素和暗像素之间差异的大小。量化图像对比度有许多方式。在深度学习中，对比度通常指的是图像或图像区域中像素的标准差。</p>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>非常通用的神经网络技术可以成功地应用于自然语言处理。然而，为了实现卓越的性能并扩展到大型应用程序，一些领域特定的策略也很重要。</p>
<p><strong>n-gram</strong></p>
<p><strong>语言模型</strong>(language model)定义了自然语言中标记序列的概率分布。根据模型的设计，标记可以是词、字符、甚至是字节。标记总是离散的实体，最早成功的语言模型基于固定长度序列的标记模型，称为 n-gram。</p>
<p><strong>神经语言模型</strong></p>
<p><strong>神经语言模型</strong>(Neural Language Model, NLM)是一类用来客服维数灾难的语言模型，它使用词的分布式表示对自然语言序列建模。不同于基于类的 n-gram 模型，神经语言模型在能够识别两个相似的词，并且不丧失每个词编码为彼此不同的能力。神经语言模型共享一个词（及其上下文）和其他类似词（和上下文之间）的统计强度。</p>
<p>我们有时将这些词表示为<strong>词嵌入</strong>(word embedding)。在这个解释下，我们将原始符号视为维度等于词表大小的空间中的点。词表示将这些点嵌入到较低维度的特征空间中</p>
<h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>当向用户推荐时，会产生超出普通监督学习范围的问题，并进入强化学习的领域。理论上，许多推荐问题最准确的描述是 contextual bandit。问题是，当我们使用推荐系统收集数据时，我们得到是一个有偏且不完整的用户偏好观：我们只能看到用户对推荐给他们的项目的反应，而不是其他项目。更糟糕的是，如果我们不够小心，即使收集越来越多的数据，我们得到的系统可能会继续选择错误的决定，因为正确的决定最初只有很低的概率：直到学习者选择正确的决定之前，该系统都无法学习正确的决定。这类似于强化学习的情况，其中仅观察到所选动作的奖励。一般来说，强化学习会涉及许多动作和许多奖励的序列。</p>
<p>在一般的强化学习场景中，高奖励或地奖励可能是由最近的动作或很久以前的动作引起的。术语 contextual bandit 指的是在一些输入变量可以通知决定的上下文中采取动作的情况。例如，我们至少知道用户身份，并且我们要选择一个项目。从上下文到动作的映射也称为<strong>策略</strong>(policy)。学习者和数据分布（现在取决于学习者的动作）之间的反馈是强化学习和 bandit 研究的中心问题。</p>
<p>强化学习需要权衡<strong>探索</strong>(exploration)与<strong>开发</strong>(exploitation)。开发指的是从目前学到的最好策略采取动作，也就是我们所知的将获得高奖励的动作。<strong>探索</strong>(exploration)是指采取行动以获得更多的训练数据。</p>
<h3 id="知识表示、推理和回答"><a href="#知识表示、推理和回答" class="headerlink" title="知识表示、推理和回答"></a>知识表示、推理和回答</h3><p>因为使用符号和词嵌入，深度学习方法在语言模型、机器翻译和自然语言处理方面非常成功。这些嵌入表示关于单个词或概念的语义只是。研究前言是为短语或词和事实之间的关系开发嵌入。</p>
<p>一个有趣的研究方向是确定如何训练分布式表示才能捕获两个实体之间的<strong>关系</strong>(relation).</p>
<p>知识库和分布式表示的另一个应用是<strong>词义消岐</strong>(word-sense disambiguation)，这个任务决定在某些语境中词的哪个意义是恰当的。</p>
<p>知识的关系结合一个推理过程和对自然语言的理解可以让我们建立一个一般的问答系统。一般的问答系统必须能够处理输入信息并记住重要的事实，并以之后能检索和推理的方式组织。这热鞥然是一个困难的开放性问题，只能在受限的『玩具』环境下解决。目前，记住和检索特定声明性事实的最佳方法是使用显式记忆机制。记忆网络最开始是被用来解决一个玩具问答任务。Kumar 在 2015 年提出了一种扩展，使用 GRU 循环网络将输入读入存储器并且在给定存储器的内容后产生回答。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习作为人工智能时代最重要的技术之一，值得每一个 AI 从业者了解和学习，这里是我的读书笔记。&lt;/p&gt;
&lt;p&gt;注：本笔记来源于&lt;a href=&quot;https://github.com/exacity/deeplearningbook-chinese&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://wdxtub.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之云计算】壹 云平台初探</title>
    <link href="http://wdxtub.com/2017/05/26/cloud-computing-platform/"/>
    <id>http://wdxtub.com/2017/05/26/cloud-computing-platform/</id>
    <published>2017-05-25T23:10:21.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中最麻烦的往往不是开发本身，而是环境搭建，尤其是调通各种接口和服务。这一讲我会详细介绍如何把云资源用得像自家电脑一样省心。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.26: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>注：待更新完成后列出</p>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解 AWS 和 Azure 的基本概念和使用</li>
<li>掌握基本的 Linux 命令</li>
<li>理解不同配置的应用场景</li>
</ol>
<h2 id="AWS-Amazon-Web-Service"><a href="#AWS-Amazon-Web-Service" class="headerlink" title="AWS - Amazon Web Service"></a>AWS - Amazon Web Service</h2><p>AWS 是目前最广泛应用的云服务，包含各种不同的服务，比如 Amazon Simple Storage Service (S3) 和 Amazon Elastic Compute Cloud (EC2)。更多的信息请参考 <a href="http://aws.amazon.com/" target="_blank" rel="external">AWS 网站</a></p>
<h3 id="AWS-Authentication"><a href="#AWS-Authentication" class="headerlink" title="AWS Authentication"></a>AWS Authentication</h3><p>除了 AWS 本身的帐号外，访问 API 以及各类 AWS 服务需要使用的一对『钥匙』：<strong>AWS Access Key ID</strong> 以及 <strong>AWS Secret Key</strong>。</p>
<p>生成『钥匙』可以按照以下步骤：</p>
<ol>
<li>登录 AWS 账户</li>
<li>在右上角的下拉菜单中选择 Security Credentials (安全证书)<ul>
<li>如果是第一次访问的话会弹出一个提示是继续还是看一下教程，可以根据自己的需要来选择</li>
</ul>
</li>
<li>在 Access Key (访问密钥)那一栏创建一个新的密钥，就会包含 <strong>AWS Access Key ID</strong> 以及 <strong>AWS Secret Key</strong>。</li>
</ol>
<p>注意！AWS 密钥拥有控制 AWS 帐号的完全权限，所以务必要保存在安全的地方，做到以下几点：</p>
<ol>
<li>不要与任何人共享 AWS 密钥</li>
<li>不要在代码中用明文保存密钥</li>
<li>不要把包含 AWS 密钥的代码提交到任何库中</li>
</ol>
<p>比较安全的做法是利用环境变量来保存密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">export</span> AWS_ACCESS_KEY_ID=<span class="string">"YOUR_ACCESS_KEY_HERE"</span></div><div class="line"><span class="built_in">export</span> AWS_SECRET_KEY=<span class="string">"YOUR_SECRET_KEY_HERE"</span></div></pre></td></tr></table></figure>
<p>在代码中就可以使用 <code>System.getenv(&quot;AWS_ACCESS_KEY_ID&quot;)</code> 或者 <code>os.environ[&#39;AWS_ACCESS_KEY_ID&#39;]</code> 来访问，不会出现明文，我在自己电脑里用的名字是：<code>AWSAccessKeyId</code> 和 <code>AWSSecretKey</code></p>
<h3 id="Elastic-Compute-Cloud-EC2"><a href="#Elastic-Compute-Cloud-EC2" class="headerlink" title="Elastic Compute Cloud (EC2)"></a>Elastic Compute Cloud (EC2)</h3><p>简单来说，EC2 提供计算能力。EC2 实例可以被看做是虚拟机或虚拟服务器，有虚拟 CPU，内存，本地存储和网络带宽，当然运行的时候是要花钱的。具体的配置不能够自定义，只能从几个类型中选择：</p>
<ul>
<li><code>t1.micro</code>：1 个虚拟 CPU，1 G 内存，无本地存储，低带宽。这种会提供免费的使用时间，基本也就够用了。</li>
<li><code>m1.small</code></li>
<li><code>m1.large</code></li>
<li><code>c1.xlarge</code></li>
</ul>
<p>具体的类型可以参考亚马逊的<a href="http://aws.amazon.com/ec2/instance-types" target="_blank" rel="external">介绍</a>，这里不一一列举。</p>
<p>花钱也有不同的方式：</p>
<ul>
<li>按需：每个 instance 每小时有固定的价钱</li>
<li>Reserved：预付款模式</li>
<li>Spot Pricing：Bid for unused capacity，给定一个价格，如果浮动到价格以下，那么就帮你开启，并以当时的价格计价</li>
</ul>
<p>instance 的存储会在 Elastic Block Storage(EBS)。</p>
<p>Amazon Machine Image (AMI) = 操作系统 + 软件。</p>
<p>一旦一个 instance 启动之后，就有了一个公网的 IP，可以通过 Security Group 来进行访问，比如 22 端口 SSH，80 端口 HTTP，3306 端口 MySQL。</p>
<p>利用密钥对来访问 EC2 instances。</p>
<p>总结一下，启动一个 instance 有以下几个步骤：</p>
<ol>
<li>选择一个 instance 类型：<code>t1.micro</code></li>
<li>决定一个计价模型：Spot Pricing</li>
<li>选择一个 AMI：Ubuntu AMI</li>
<li>定义一个 Security Group</li>
<li>使用密钥对来连接</li>
</ol>
<h3 id="启动并连接到-instance"><a href="#启动并连接到-instance" class="headerlink" title="启动并连接到 instance"></a>启动并连接到 instance</h3><p><a href="https://youtu.be/z-NoOLk2U-g" target="_blank" rel="external">启动 EC2 instance 视频教程（墙外）</a></p>
<p>具体的步骤如下：</p>
<ol>
<li>进入控制台，选择 EC2 控制面板（地区注意选择弗吉尼亚北部，右上角那里）</li>
<li>点击实例，现在什么都没有，选择创建一个新实例</li>
<li>之后的 project 中会给出 AMI id，可以在社区 AMI 一栏里搜索选择</li>
<li>这里我们选择 Amazon Linux AMI，选择 <code>t2.micro</code></li>
<li>点击下一步进行具体的配置，这里暂时不需要修改</li>
<li>点击下一步选择存储</li>
<li>点击下一步可以给 instance 一些标签，注意格式应该是 <code>Project:&lt;Project Number&gt;</code>，如 <code>Project:0</code> 或 <code>Project:1.1</code> 这样</li>
<li>点击下一步配置 Security Group，这里可以不用修改，但是如果提高安全性的话可以限制可访问的 ip</li>
<li>然后可以查看各种选项</li>
<li>需要选择一个连接的密钥对（也可以在这里创建一个新的），是一个pem 文件，同样注意保存好</li>
<li>这时候就可以启动 instance</li>
</ol>
<p>等待一段时间，启动之后就可以连接到这个 instance，具体的步骤如下：</p>
<ol>
<li>从面板中得到 Public DNS 地址</li>
<li>使用 <code>ssh -i key_file.pem ec2-user@ec2-50-19-54-72-compute-1.amazonaws.com</code> 来进行连接</li>
<li>需要使用 <code>chmod 600 key_file.pem</code> 来修改权限</li>
<li>如果需要 root，直接 <code>sudo</code> 即可</li>
</ol>
<h3 id="Simple-Storage-Service-S3"><a href="#Simple-Storage-Service-S3" class="headerlink" title="Simple Storage Service(S3)"></a>Simple Storage Service(S3)</h3><p>Amazon S3 提供了一个简单的用来存储和访问任何数据的 web 服务接口。可以存储的对象数量是无限的，每个对象都可以通过一个唯一的，由开发者指定的 key 来访问。</p>
<p>和常见的文件系统比较起来，S3 没有文件夹的概念，唯一的容器就是一个 bucket，但是文件名例可以有 <code>/</code> 来标记不同的层级。</p>
<p>可以通过 web 界面，命令行工具和 API 三种方式来访问 S3。假设在 S3 中有一个文件的路径是</p>
<ul>
<li><code>s3://wdxtub/dawang.txt</code></li>
</ul>
<p>那么可以通过以下两种方式用 http 来访问：</p>
<ul>
<li><code>http://s3.amazonaws.com/wdxtub/dawang.txt</code></li>
<li><code>http://wdxtub.s3.amazonaws.com/dawang.txt</code></li>
</ul>
<p>其中 <code>wdxtub</code> 是 bucket 名，必须是全局唯一的。如果想要所有人都能够访问，需要设置一下对应的权限</p>
<p>其他一些常用的工具有：</p>
<ul>
<li>AWS Command Line Tool (aws-cli)<ul>
<li>在 Mac 下可以直接使用 <code>pip install awscli</code> 来进行安装，具体的教程可以参考<a href="https://aws.amazon.com/cn/cli/" target="_blank" rel="external">官方文档</a></li>
</ul>
</li>
<li>CloudWatch<ul>
<li>简单来说，CloudWatch 就是一个监控各种云服务的工具</li>
</ul>
</li>
</ul>
<h3 id="AWS-API"><a href="#AWS-API" class="headerlink" title="AWS API"></a>AWS API</h3><p>AWS 可以通过命令行工具或者 SDK 来访问几乎所有的功能，这一节主要介绍一些最常用的工具和功能。</p>
<p><a href="http://aws.amazon.com/cn/sdk-for-java/" target="_blank" rel="external">Java AWS SDK</a> 包括：</p>
<ul>
<li>AWS Java Library：总而言之就是所需的各种包，网络请求，验证，错误处理等等</li>
<li>样例代码</li>
<li>Eclipse 支持：包含一个插件</li>
</ul>
<p>在<a href="http://aws.amazon.com/tools" target="_blank" rel="external">这里</a>找到对应的工具，找到 SDK 中对应的库。主要过程有三步：</p>
<ol>
<li>用密钥初始化 AWS 连接</li>
<li>使用 API 进行操作</li>
<li>关闭 AWS 连接</li>
</ol>
<p>先下载好 SDK 和 Eclipse 插件（在 eclipse 里安装，Amazon 有给出教程）</p>
<p><strong>Amazon EC2 API</strong></p>
<p>可以通过 API 做这些事情：</p>
<ul>
<li>创建 EC2 密钥对</li>
<li>位实例创建安全组并且打开端口</li>
<li>创建启动停止重启和终止 EC2 实例</li>
</ul>
<p>下面是 Java 和 Python 的代码</p>
<p>Java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Load the Properties File with AWS Credentials</span></div><div class="line">Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">properties.load(RunInstance.class.getResourceAsStream(<span class="string">"/AwsCredentials.properties"</span>));</div><div class="line">BasicAWSCredentials bawsc = <span class="keyword">new</span> BasicAWSCredentials(properties.getProperty(<span class="string">"accessKey"</span>), properties.getProperty(<span class="string">"secretKey"</span>));</div><div class="line"><span class="comment">//Create an Amazon EC2 Client</span></div><div class="line">AmazonEC2Client ec2 = <span class="keyword">new</span> AmazonEC2Client(bawsc);</div><div class="line"><span class="comment">//Create Instance Request</span></div><div class="line">RunInstancesRequest runInstancesRequest = <span class="keyword">new</span> RunInstancesRequest();</div><div class="line"><span class="comment">//Configure Instance Request</span></div><div class="line">runInstancesRequest.withImageId(<span class="string">"ami-3b44d352"</span>)</div><div class="line">.withInstanceType(<span class="string">"t1.micro"</span>)</div><div class="line">.withMinCount(<span class="number">1</span>)</div><div class="line">.withMaxCount(<span class="number">1</span>)</div><div class="line">.withKeyName(<span class="string">"project1_test"</span>)</div><div class="line">.withSecurityGroups(<span class="string">"MySecurityGroup"</span>);</div><div class="line"></div><div class="line"><span class="comment">//Launch Instance</span></div><div class="line">RunInstancesResult runInstancesResult = ec2.runInstances(runInstancesRequest);   </div><div class="line"><span class="comment">//Return the Object Reference of the Instance just Launched</span></div><div class="line">Instance instance=runInstancesResult.getReservation().getInstances().get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> boto.ec2.connection <span class="keyword">import</span> EC2Connection</div><div class="line"></div><div class="line"><span class="comment"># Create a connection</span></div><div class="line">conn = boto.ec2.connect_to_region(<span class="string">"us-east-1"</span>)</div><div class="line"><span class="comment"># Launching instance</span></div><div class="line">reservation = conn.run_instances(<span class="string">"ami-3b44d352"</span>,instance_type = <span class="string">"t1.micro"</span>, </div><div class="line">        key_name = <span class="string">"project1_test"</span>, security_groups = <span class="string">"MySecurityGroup"</span>)</div><div class="line">instance = reservation.instances[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>我们同样可以通过 EC2 的 API 来查看实例的状态，例如类 <code>DescribeInstanceStatusRequest</code> 的状态：</p>
<ul>
<li>Running</li>
<li>Pending</li>
<li>Shutting down 等等</li>
</ul>
<p>更多的文档参考 <a href="http://aws.amazon.com/documentation/sdk-for-java/" target="_blank" rel="external">AWS SDK for Java Documentation</a> <a href="http://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/index.html" target="_blank" rel="external">AWS Java API Reference</a> 和 <a href="http://docs.pythonboto.org/en/latest/" target="_blank" rel="external">boto</a></p>
<h3 id="AWS-CLI"><a href="#AWS-CLI" class="headerlink" title="AWS CLI"></a>AWS CLI</h3><p>我们同样也可以利用命令行来操作 AWS，主页在<a href="http://aws.amazon.com/cn/cli/" target="_blank" rel="external">这里</a>。如果打算使用命令行，那么需要：</p>
<ol>
<li>在实例中下载和安装命令行工具</li>
<li>通过 <code>aws configure</code> 来设置密钥（注意这里地区要选择 us-east-1，<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html" target="_blank" rel="external">参考链接</a>）</li>
</ol>
<p>下面是简单的使用 AWS 命令行工具的视频介绍</p>
<p><a href="https://youtu.be/OSGjoMeHc2A" target="_blank" rel="external">AWS 命令行工具（墙外）</a></p>
<p>启动实例之前先要配置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws configure</div><div class="line">AWS Access Key ID [None]: YOUR AWS ACCESS KEY</div><div class="line">AWS Secret Access Key [None]: YOUR AWS SECRET ACCESS KEY</div><div class="line">Default region name [None]: us-east-1</div><div class="line">Default output format [None]: json</div></pre></td></tr></table></figure>
<p>然后可以用下面的命令来创建安全组，密钥对和角色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws ec2 create-security-group --group-name devenv-sg --description <span class="string">"security group for development environment in EC2"</span></div><div class="line">$ aws ec2 authorize-security-group-ingress --group-name devenv-sg --protocol tcp --port 22 --cidr 0.0.0.0/0</div><div class="line">$ aws ec2 create-key-pair --key-name devenv-key --query <span class="string">'KeyMaterial'</span> --output text &gt; devenv-key.pem</div><div class="line">$ chmod 400 devenv-key.pem</div></pre></td></tr></table></figure>
<p>然后就可以启动并连接实例了，这里需要提供 <code>AMI_ID(ami-xxxxx)</code> 和 安全组(sg-xxxxx)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws ec2 run-instances --image-id YOUR_AMI_ID --security-group-ids SECURITY_GROUP_ID --count 1 --instance-type t2.micro --key-name devenv-key --query <span class="string">'Instances[0].InstanceId'</span></div></pre></td></tr></table></figure>
<p>Amazon CloudWatch 部分之前有介绍过，详细介绍可以查看<a href="http://aws.amazon.com/documentation/cloudwatch/" target="_blank" rel="external">文档</a></p>
<h2 id="Microsoft-Azure"><a href="#Microsoft-Azure" class="headerlink" title="Microsoft Azure"></a>Microsoft Azure</h2><p>简单来说，就是微软提供的云服务，提供 PaaS 和 IaaS 服务，于此同时支持不同的编程语言/工具/框架。可以通过访问 <a href="https://portal.azure.com/" target="_blank" rel="external">Azure Portal</a> 或者 <a href="https://manage.windowsazure.com/" target="_blank" rel="external">Azure Manage</a> 来访问 Azure 控制台，其中 Azure Portal 是一个新的控制台，尽量用这个。需要更多信息，可以查看<a href="https://azure.microsoft.com/en-us/documentation/articles/fundamentals-introduction-to-azure" target="_blank" rel="external">这里</a></p>
<h3 id="Microsoft-Azure-Compute"><a href="#Microsoft-Azure-Compute" class="headerlink" title="Microsoft Azure Compute"></a>Microsoft Azure Compute</h3><p>按照以下步骤来创建一个虚拟机：</p>
<ol>
<li>登录<a href="https://portal.azure.com/" target="_blank" rel="external">Azure Portal</a></li>
<li>新建 -&gt; 计算 -&gt; Ubuntu Server 14.04 LTS，选择 <code>资源管理器</code> 作为 <code>部署模型</code></li>
<li>设置姓名、用户名和密码，新建一个资源组，点击确定</li>
<li>然后在大小选择中点击查看全部，选择 <code>A0 标准</code>，也就是最便宜的那个</li>
<li>后面的大部分内容都可以用默认值，然后点击确定就创建完成了</li>
</ol>
<p>Azure 有两种不同的部署模型：Azure Service Manager(ASM) 和 Azure Resource Manager(ARM)，后者更新也有更好的 API，所以我们尽量用后一种。</p>
<p>注意，在一种模型例部署的资源在另一种里看不到，更多信息可以访问<a href="http://blogs.msdn.com/b/cloud_solution_architect/archive/2015/03/17/rbac-and-the-azure-resource-manager.aspx" target="_blank" rel="external">这里</a></p>
<h3 id="Microsoft-Azure-Storage"><a href="#Microsoft-Azure-Storage" class="headerlink" title="Microsoft Azure Storage"></a>Microsoft Azure Storage</h3><p>类似于 Amazon S3，是一个可拓展的存储系统，有下面四种形态：</p>
<ol>
<li>Azure Blobs，类似 Amazon S3 的对象存储系统</li>
<li>Azure Tables，数据库</li>
<li>Azure Queues，应用的消息队列</li>
<li>Azure Files，文件系统</li>
</ol>
<p>现在我们主要接触一下 Azure Blobs，首先先要建立一个 Azure Storage 账户，按照下面步骤即可：</p>
<ol>
<li>新建 -&gt; 数据+存储器 -&gt; 存储(Storage account)</li>
<li><code>部署模型</code> 选择 <code>资源管理器</code>，然后指定唯一的名字</li>
<li>指定一个现有的资源组（刚才新建的那个就可以），然后在类型里选择 <code>L 本地冗余</code>（最便宜那个）</li>
<li>然后就可以创建了</li>
</ol>
<p>等待一段时间部署，部署完成后就可以通过 Azure 命令行工具来进行访问了。</p>
<h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><p>如果你对前面的命令感觉一头雾水，那么这一节要好好阅读了。下面是一些教程：</p>
<ol>
<li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="external">The Advanced Bash Scripting Guide</a></li>
<li><a href="https://github.com/jlevy/the-art-of-command-line" target="_blank" rel="external">The Art of the Command Line</a> <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="external">中文版本</a></li>
<li><a href="http://www.perl.org/" target="_blank" rel="external">Perl 指南</a></li>
<li><a href="http://www.python.org/" target="_blank" rel="external">Python 指南</a></li>
</ol>
<p>读的时候需要注意下面的内容：</p>
<ol>
<li>脚本语法，本地变量和环境变量</li>
<li>bash 中的 Quoting and back-ticks</li>
<li>利用 unix 管道进行输入输出重定向</li>
<li>使用类似 <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>cut</code> 等等来做基本的文本操作</li>
</ol>
<h3 id="Secure-Shell-SSH"><a href="#Secure-Shell-SSH" class="headerlink" title="Secure Shell(SSH)"></a>Secure Shell(SSH)</h3><p>简单来说 SSH 是一个用来进行安全数据通信、远程登录和远程命令执行的网络协议。</p>
<p>要想让一台服务器支持 SSH，需使用 <code>sudo apt-get install openssh-server</code> 安装服务，对应的配置文件在 <code>/etc/ssh/sshd.config</code> 中。可以使用 <code>sudo /etc/init.d/ssh</code> 或 <code>sudo service sshd [start|stop|restart]</code> 来进行管理。</p>
<p>SSH 支持若干中验证机制。比较常见的是通过密码验证。密码验证的安全性取决于密码的长度和复杂度，由于可以被暴力或者基于字典破解，所以对于公共访问的 EC2 instance 来说是比较危险的。</p>
<p>为此，所有的 EC2 instance 都使用基于公钥加密的 key-based 验证。一对密钥包含公钥和私钥，由数学方式如 RSA/DSA 生成并链接。只知道一个 key 的话，几乎不可能破解另外一个 key。</p>
<p>我们也可以生成自己的密钥对，在 Linux 中，密钥对通常存储在 <code>~/.ssh</code> 目录下，通过下面的代码就可以生成密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Generate a new key with your email id as a label</span></div><div class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"email_id@domain.com"</span></div><div class="line"></div><div class="line"><span class="comment"># Enter the file where you want to save the key: (recommended - choose default)</span></div><div class="line"></div><div class="line"><span class="comment"># You will be asked enter a pass-phrase for your key twice.</span></div><div class="line"><span class="comment"># (Use a strong pass-phrase. Longer pass-phrases are more secure than shorter ones.)</span></div><div class="line"></div><div class="line"><span class="comment"># After you provide the pass-phrase. The console will print the location of the key and the key fingerprint</span></div></pre></td></tr></table></figure>
<p>然后就可以导入这个密钥并用以连接 EC2，具体的做法可以看<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#how-to-generate-your-own-key-and-import-it-to-aws" target="_blank" rel="external">这里</a></p>
<p>举个例子，下面的代码会在远程实例执行 <code>uname -a</code> 命令，这种做法在批量运行远程实例命令的时候非常有用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ssh -i private_key_file.pem some-instance.ec2.amazonaws.com <span class="string">'uname –a'</span></div></pre></td></tr></table></figure>
<p>如果遇到 SSH 的 permission-denied 问题，很可能是由于不正确权限所导致，私钥的 unix permission 为 <code>600</code> 且包含私钥的目录的权限应为 <code>700</code></p>
<p>在执行 SSH 命令时，如果太久没有操作，就会自动断开，执行的脚本也会终止，如果不希望这样，有以下几种方式可以避免 SSH 超时：</p>
<ol>
<li><a href="https://docs.oseems.com/general/application/ssh/disable-timeout" target="_blank" rel="external">关闭 SSH 客户端的超时</a></li>
<li>用 <code>nohup</code> 执行脚本</li>
<li>通过远程屏幕管理(remote sreen management)来保持 terminal sessions</li>
</ol>
<p>通常来说我们用 bash shell 来进行远程操作，但是由于网络的缘故，一旦连接断开，所有已经启动的进程都会被终止。为了避免这种情况，使用 <code>nohup</code> 命令就非常有用了，即使连接断开，仍旧会继续运行命令。</p>
<p>另外一个比较有用的工具是 <code>byobu</code>，是一个多终端管理应用程序，类似于 <code>screen</code> 或者 <code>tmux</code>。</p>
<p>注：<code>byobu</code> 比较炫，但是我个人比较喜欢 tmux，参考 <a href="http://wdxtub.com/2016/03/30/tmux-guide/">tmux 指南</a></p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>用 Ubuntu 的话可以使用强大的 <code>apt-get</code> 来安装软件，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get install emacs</div><div class="line">sudo apt-get install vim</div><div class="line"></div><div class="line">sudo apt-get update <span class="comment"># 用来更新包索引</span></div><div class="line">sudo apt-get upgrade <span class="comment"># 用来更新包</span></div></pre></td></tr></table></figure>
<h3 id="文件所有者和权限"><a href="#文件所有者和权限" class="headerlink" title="文件所有者和权限"></a>文件所有者和权限</h3><p>Linux 的文件权限分为三个用户组：<code>user</code>, <code>group</code> 和 <code>others</code>，每组有三个权限：读(<code>r</code>)，写(<code>w</code>)，执行(<code>x</code>)。我们可以利用 <code>chmod</code> 命令来修改权限，如：<code>chmod 777 filename.txt</code></p>
<p>不用数字的话，可以用字母，<code>chmod u+x filename.txt</code> 这个命令就给 user 添加了执行权限。如果要更改文件所属，使用 <code>chown</code> 命令，具体可以参见 <code>man chown</code></p>
<h3 id="Linux-中的磁盘操作"><a href="#Linux-中的磁盘操作" class="headerlink" title="Linux 中的磁盘操作"></a>Linux 中的磁盘操作</h3><h4 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h4><p>许多 Linux 应用都可以管理磁盘分区，比如说 <code>parted</code> 和 <code>fdisk</code>。<code>fdisk</code> 是比较老的分区管理工具，现在几乎已经被 <code>parted</code> 取代，因为 <code>parted</code> 支持 GUID 分区表以及大于 2TB 的磁盘，所以我们这里使用 <code>parted</code>。</p>
<p><code>parted -l</code> 会列出系统中的所有分区。具体的顺序是按照 <code>/dev</code> 下的顺序。在 EC2 实例中，设备是 <code>dev/xvd**</code>，<code>/dev/xvda1</code> 是操作系统分区，<code>/dev/xvdb</code> 是实例的存储分区，注意 RAMDISK 不会出现在 <code>parted</code> 的输出当中。</p>
<p><code>parted</code> 还可以用来为每个分区设置类型和文件系统，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">parted /dev/xvdX mklabel gpt</div><div class="line">parted /dev/xvdX mkpart db ext4 0% 10G</div></pre></td></tr></table></figure>
<p>如果不加任何参数，<code>parted</code> 就会进入交互模式，这里你可以利用 <code>mkfs</code> 来格式化一个分区，如 <code>mkfs.ext4 /dev/xvdX1</code></p>
<h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><p>在分区和格式化之后，如果想要使用就需要把分区挂载在某个挂载点上，通常来说会挂载在 <code>/mnt</code> 或者 <code>/mount</code> 上，可移除的媒介，例如 USB 和 CDROM，会挂载在 <code>/media</code> 上，当然，你可以把分区挂载在任何地方，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir /storage/mountpoint</div><div class="line">mount /dev/yourdevice /storage/mountpoint</div></pre></td></tr></table></figure>
<h3 id="配置服务和启动"><a href="#配置服务和启动" class="headerlink" title="配置服务和启动"></a>配置服务和启动</h3><p>如果想要开机启动，需要参考应用本身的帮助文档，但是总体来说，服务需要安装在 <code>/etc/init.d</code> 中，这使得这些脚本可以在启动时运行。例如，如果 mysql 脚本在 <code>/etc/init.d</code> 中，那么可以使用这个命令 <code>service mysql [start|stop|restart]</code>。</p>
<p>想要了解更多，请参阅<a href="http://www.tldp.org/HOWTO/HighQuality-Apps-HOWTO/boot.html" target="_blank" rel="external">这里</a></p>
<h2 id="EC2-性能测试"><a href="#EC2-性能测试" class="headerlink" title="EC2 性能测试"></a>EC2 性能测试</h2><p>通常来说在云平台上用来计算的资源叫做虚拟机，也叫实例 instance。不是所有的实例都是一样的，在 AWS 中有一些可以定制的选择，比如说操作系统和硬件配置等等。</p>
<p>这一节的主要任务是了解虚拟机并在上面跑一些应用程序，借此来理解不同配置的不同表现。我们都知道更好的配置就性能更强，但是：</p>
<ul>
<li>更贵的是不是真的更好？</li>
<li>有没有什么办法来测量其性能表现？</li>
<li>性能的差别有多少？</li>
</ul>
<p>这些问题都不简单，但是这一节会给你一点点启发。</p>
<h3 id="启动不同类型的实例"><a href="#启动不同类型的实例" class="headerlink" title="启动不同类型的实例"></a>启动不同类型的实例</h3><p>虽然我们知道有几种不同的配置，但是除了纸面上的差别，真正的性能差别有多少呢？现在我们就来分别测试一下，按照以下步骤进行</p>
<ol>
<li>启动三个分别为 <code>t2.small</code>, <code>t2.medium</code>, <code>t2.large</code> 的实例，硬盘选择 30GB 的 General SSD，镜像选择 Ubuntu Server 14.04 LTS (HVM), General SSD Volume Type (ami-d05e75b8)。这里最好选择 <strong>spot instances</strong>，可以省点钱，更多请查看<a href="https://aws.amazon.com/ec2/spot/" target="_blank" rel="external">这里</a>。如果 spot instances 不可用的话，那么选择 on-demand instances</li>
<li>在启动这些实例的时候，需要指定 <strong>Security Group</strong>，创建允许 HTTP(TCP 端口 80) 和 SSH(TCP 端口 22) 的 security group</li>
<li>同样也需要指定一个已经存在的密钥对文件（或者生成一个）以连接这些实例</li>
<li>启动实例之后，可能需要等待几分钟，在 web 控制台可以查看目前的状况</li>
<li>用 SSH 及 PEM 文件来连接到这些实例。</li>
</ol>
<h3 id="系统性能评测"><a href="#系统性能评测" class="headerlink" title="系统性能评测"></a>系统性能评测</h3><p>我们需要在已经启动的实例中安装性能测评工具。通过这个来评估完成一个任务所需的最佳实例组合以做到多快好省。</p>
<p>虽然云服务提供商是利用虚拟化技术来提供资源，但是需要知道实例的性能一来不是稳定的，二来也不保证达到某个水平。这里我们使用 <code>sysbench</code> 来评估性能，它是一个轻量级跨平台的性能测试软件，能够快速评估 CPU，内存和文件读写性能。</p>
<p>用 <code>ssh -i keyfile.pem ubuntu@dnsaddress</code> 来进行连接</p>
<p>然后执行下面的命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install sysbench</div></pre></td></tr></table></figure>
<p>安装完成之后就可以按照给出的三个配置来进行测试。</p>
<p><strong>CPU 测试</strong></p>
<p>分别在三个不同的机器运行下列命令，统计结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sysbench --num-threads=8 --test=cpu --cpu-max-prime=20000 run</div><div class="line">sysbench --num-threads=1 --test=cpu --cpu-max-prime=40000 run</div><div class="line">sysbench --num-threads=4 --test=cpu --cpu-max-prime=50000 run</div></pre></td></tr></table></figure>
<p>表后面的三列分别是 <code>t2.small</code>, <code>t2.medium</code>, <code>t2.large</code> 的总时间</p>
<table>
<thead>
<tr>
<th style="text-align:center">Max Prime</th>
<th style="text-align:center">Thread</th>
<th style="text-align:center">Time(s)</th>
<th style="text-align:center">Time(m)</th>
<th style="text-align:center">Time(l)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20000</td>
<td style="text-align:center">8</td>
<td style="text-align:center">29.4015s</td>
<td style="text-align:center">14.8129s</td>
<td style="text-align:center">14.8693s </td>
</tr>
<tr>
<td style="text-align:center">40000</td>
<td style="text-align:center">1</td>
<td style="text-align:center">77.7609s</td>
<td style="text-align:center">76.0034s</td>
<td style="text-align:center">77.1984s</td>
</tr>
<tr>
<td style="text-align:center">50000</td>
<td style="text-align:center">4</td>
<td style="text-align:center">104.8054s</td>
<td style="text-align:center">51.5801</td>
<td style="text-align:center">52.4278s</td>
</tr>
</tbody>
</table>
<p>可以看到其实在当前任务下，<code>t2.medium</code> 与 <code>t2.large</code> 的性能差别并不大，就可以根据价格来进行取舍了。</p>
<p><strong>文件 IO 性能测试</strong></p>
<p>AWS 通常会保证 Input/Output Operations per Second (IOPS)。不同的硬盘访问逻辑对性能影响很大（缓存导致），传统的机械硬盘受寻址时间和旋转速度的影响，固态硬盘受驱动和设备控制器的影响。</p>
<p>同样用下面的命令来进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sysbench --test=fileio --file-total-size=20G prepare </div><div class="line"><span class="comment"># 可能需要等待30分钟，使用 byobu / screen / tmux 来保持连接</span></div><div class="line"><span class="comment"># 或者可以在 iterm 设置中 profiles -&gt; sessions -&gt; When idel, send ASCII code</span></div><div class="line"><span class="comment"># 又或者 在客户端的 ~/.ssh/ 文件夹中添加 config 文件，并添加配置： ServerAliveInterval 60 </span></div><div class="line"></div><div class="line">sysbench --test=fileio --file-total-size=20G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">t2.small</th>
<th style="text-align:center">t2.medium</th>
<th style="text-align:center">t2.large</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read(Gb)</td>
<td style="text-align:center">3.8986</td>
<td style="text-align:center">3.9448</td>
<td style="text-align:center">5.6735</td>
</tr>
<tr>
<td style="text-align:center">Written(Gb)</td>
<td style="text-align:center">2.599</td>
<td style="text-align:center">2.6299</td>
<td style="text-align:center">3.7823</td>
</tr>
<tr>
<td style="text-align:center">Total trans(Gb)</td>
<td style="text-align:center">6.4976</td>
<td style="text-align:center">6.5747</td>
<td style="text-align:center">9.4559</td>
</tr>
<tr>
<td style="text-align:center">Speed(Mb/sec)</td>
<td style="text-align:center">22.178</td>
<td style="text-align:center">22.442</td>
<td style="text-align:center">32.276</td>
</tr>
</tbody>
</table>
<p>比较一下表中的数据，是不是随着价格的提高，性能也有对应比例的提高？</p>
<p>可以看到从 small 到 medium 几乎没有提升，但是到 large 就有比较大的提升。</p>
<h3 id="Web-服务器性能测试"><a href="#Web-服务器性能测试" class="headerlink" title="Web 服务器性能测试"></a>Web 服务器性能测试</h3><p>这里我们会在每个实例中安装和部署一个简单的 web 服务器，修改一下主页以便测试和评分。</p>
<p>LAMP = Linux + Apache + MySQL + PHP</p>
<p>用以下命令安装 apache：<code>sudo apt-get install apache2</code>。安装完成之后，用自己的浏览器访问这个实例的地址，应该就可以看到 Apache 的欢迎页面（这里需要在 Security Group 中允许 HTTP 访问）</p>
<p>如果访问 <code>cd /var/www/html</code> 就可以看到有一个 <code>index.html</code> 页面。我们把这个页面的内容替换成：<code>welcome to cloud computing</code> （<code>sudo vim index.html</code> 然后命令模式下 <code>dG</code>），再次访问的时候就可以看到变化了。</p>
<p>然后我们来安装 apachebench，也就是服务器管理器，命令如下：<code>sudo apt-get install apache2-utils</code>。安装完成后，输入 <code>ab</code> 应该能看到命令界面，一个简单的测试命令为：</p>
<p><code>ab -n 1000 -c 100 http://localhost/</code> (一次 1000 个 request，一共 100 次，最后是想要测试的页面)，然后就可以看到各种数据统计。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一节就塞这么多内容，不知道大家是感觉很爽还是亚历山大，总结一下，我们了解了不同云服务提供商的不同特点，也实际接触和操作了一把『云』，其中 Linux 基础是我们必须要掌握的。在云计算愈发普遍的今天，其实国内的很多社区也有出很多配套的教程，大家感兴趣的话，一定会被铺天盖地的广告轰炸的（感谢网友指出错别字）。</p>
<p>俗话说的好，万事开头难，接下来我们就会用一些更加接近实战的例子来与云亲密接触了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://aws.amazon.com/cn/" target="_blank" rel="external">Amazon Web Service</a></li>
<li><a href="https://aws.amazon.com/cn/cli/" target="_blank" rel="external">AWS 命令行界面</a></li>
<li><a href="https://www.azure.cn/" target="_blank" rel="external">Microsoft Azure 中国区</a></li>
<li><a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="external">Microsoft Azure</a></li>
<li><a href="https://www.aliyun.com" target="_blank" rel="external">阿里云</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中最麻烦的往往不是开发本身，而是环境搭建，尤其是调通各种接口和服务。这一讲我会详细介绍如何把云资源用得像自家电脑一样省心。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之云计算】零 系列概览</title>
    <link href="http://wdxtub.com/2017/05/26/cloud-computing-overview/"/>
    <id>http://wdxtub.com/2017/05/26/cloud-computing-overview/</id>
    <published>2017-05-25T22:51:50.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>云计算作为未来的大势所趋，是每个 IT 从业者都需要关注的，这个系列结合我从校园到工作中围绕云计算积攒下来的相关经验，分享给大家。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.26: 完成初稿</li>
</ul>
<h2 id="为什么要写？"><a href="#为什么要写？" class="headerlink" title="为什么要写？"></a>为什么要写？</h2><ul>
<li>云计算涉及的概念较多，很多基础框架不是特别牢固的同学容易顾此失彼，学得很痛苦</li>
<li>原先的 CMU 云计算课程笔记因校方压力下架，一直没有机会重制</li>
<li>结合校园与工作中的经验，更有针对性，更多干货</li>
</ul>
<h2 id="能带给读者什么？"><a href="#能带给读者什么？" class="headerlink" title="能带给读者什么？"></a>能带给读者什么？</h2><ul>
<li>云计算核心组件的理论知识</li>
<li>云计算实战中的小技巧</li>
<li>Linux 运维实战经验</li>
<li>如何利用云计算完成简单服务的搭建</li>
<li>如何优化架构，提升云服务性能</li>
<li>培养朝抵抗力最大的路径走的坚定，学会如何去学习。</li>
</ul>
<p>这也是我写新技术系列的一次尝试，让互联网上高质量的中文内容多一些，再多一些。</p>
<h2 id="有什么局限？"><a href="#有什么局限？" class="headerlink" title="有什么局限？"></a>有什么局限？</h2><ul>
<li>这不是一个可以速成，看看就懂的系列，需要自己动手去实践。话说回来，天底下的真功夫，也没有能够速成的。</li>
<li>工作量比较大，会花费很多实践，需要不断尝试，不断跌倒再爬起，而这正是『深入理解云计算』的必经之路。</li>
<li>需要自行探索的部分很多，我个人的知识体系并不完备，欢迎大家在评论中各抒己见，让这个系列更加完美。</li>
</ul>
<p>在这个快节奏的时代，慢一点，再慢一点。</p>
<h2 id="主要写什么？"><a href="#主要写什么？" class="headerlink" title="主要写什么？"></a>主要写什么？</h2><ul>
<li>从基本概念入手，辅以图片，尽量用具体实例阐述推导和思考的过程，不用『显然』偷懒，不用『易知』搪塞。</li>
<li>逆推设计过程，还原具体情境，为什么会有不同的设计不同的系统，寻找『三江源』。</li>
<li>理论结合实践，深入浅出介绍云计算，包括：云设施，虚拟化，云存储，编程模型等等</li>
</ul>
<p>对自己的要求是写作的时候，细致一点，再细致一点。</p>
<p>注：主要在 Amazon Web Services 和 Microsoft Azure 上试验，后面会加上国内的云服务</p>
<h2 id="不会写什么？"><a href="#不会写什么？" class="headerlink" title="不会写什么？"></a>不会写什么？</h2><ul>
<li>不会重复网上已有的教程与概念，这个系列并不是一个资料汇总，而应该是『学习伴侣』，有自己的思考，再来看看我的思考和大家的思考，这样才是最高效的学习。</li>
<li>不会大段贴代码，这个系列并不是一个手把手帮读者完成任务的系列，而是授人以渔的系列</li>
<li>不会详述只需要简单搜索就可以找到答案的问题，希望能专注于那些『不懂甚至不知道如何搜索』的问题，并以此鼓励大家培养自己主动探索解决问题的能力</li>
</ul>
<p>对读者的要求是学习的时候，走一步，再走一步。</p>
<h2 id="具体编排"><a href="#具体编排" class="headerlink" title="具体编排"></a>具体编排</h2><p>注：这部分可能会不断变化</p>
<ul>
<li><a href="">壹 云计算平台初探</a><ul>
<li>云平台入门与 Linux 基础(cc2345678)</li>
</ul>
</li>
<li><a href="">贰 编程模型与资源调度</a><ul>
<li>串行、并行、自动扩展(cc9 10 11)</li>
</ul>
</li>
<li><a href="">叁 负载均衡与缓存</a><ul>
<li>为什么需要负载均衡，缓存是如何提高服务效率(cc12 cc13)</li>
</ul>
</li>
<li><a href="">肆 分布式存储那些事儿</a><ul>
<li>不同存储方式与分布方式、一致性</li>
</ul>
</li>
<li><a href="">伍 OLAP 与 OLDP</a><ul>
<li>思想、套路与实战</li>
</ul>
</li>
</ul>
<h2 id="细节知识点"><a href="#细节知识点" class="headerlink" title="细节知识点"></a>细节知识点</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>解释云计算的<strong>核心概念</strong></p>
<ol>
<li>解释什么是『云计算』</li>
<li>云计算历史介绍，了解动机与演变</li>
<li>列举云计算中重要的技术，并讨论其特点</li>
<li>了解云的优势与劣势</li>
<li>了解云对商业和云服务提供商的经济利益和风险</li>
<li>联系云架构的不同层级并区分不同的服务模型</li>
<li>定义 SLAs 和 SLOs 并说明其重要性</li>
<li>列举和解释云安全的各类威胁</li>
<li>给出常见的云服务提供商与其云架构</li>
</ol>
<h3 id="云设施"><a href="#云设施" class="headerlink" title="云设施"></a>云设施</h3><p>通过在<strong>云设施</strong>上应用基础概念来理解性能，效率和花费之间的权衡，并以此去思考如何建立起健壮，有弹性和高效的数据中心</p>
<ol>
<li>描述数据中心的演化并给出现代数据中心的架构</li>
<li>思考设计的考虑并讨论不同的影响</li>
<li>描述如何计算一个数据中心的能源需求</li>
<li>理解云架构数据中心的需求和挑战，并分析其和大型计算机的不同</li>
<li>解释云软件的不同层级与每层扮演的角色</li>
<li>了解自动化资源管理的必要性和关键的规划考虑</li>
<li>评估在云上编程，部署和失败的考虑</li>
<li>理解构建多层云应用的概念，并考虑延迟，可伸缩性与健壮性</li>
<li>了解不同的计价模型与对应的商业模式</li>
<li>描述云管理技术，例如 middleware，resource provisioning，metering 和 orchestration</li>
<li>从规模，负载均衡，容错，延迟，优化和花费等角度来描述评估不同的云部署方案</li>
</ol>
<h3 id="云资源管理"><a href="#云资源管理" class="headerlink" title="云资源管理"></a>云资源管理</h3><p>了解<strong>系统，网络和存储虚拟化</strong>并理解它们在云计算系统模型中扮演的角色</p>
<ol>
<li>理解为什么虚拟化在云上非常重要的主要原因</li>
<li>解释通过虚拟化提供的不同隔离类型，例如错误隔离，资源隔离和安全隔离</li>
<li>理解为什么系统复杂度可以通过不同层级的抽象，良好定义的接口和虚拟化的应用来管理</li>
<li>理解资源共享，并解释是如何通过虚拟化来做到物理和逻辑层面的分离</li>
<li>理解虚拟化，并区分不同的虚拟机类型，例如进程和系统虚拟机</li>
<li>理解虚拟化 CPU 的条件，区别全虚拟与部分虚拟，理解作为 CPU 虚拟化主要技术的 emulation，并检查 Xen 中的虚拟 CPU 调度</li>
<li>列出传统操作系统虚拟内存和系统内存虚拟化的区别，解释多层页映射，并通过 VMWare 的 memory ballooning 技术来理解 memory over-commitment</li>
<li>解释 CPU 和 IO 设备如何在虚拟化/非虚拟化情况下进行通信，理解三个主要接口：系统调用，设备驱动和操作层级</li>
<li>从云计算的角度列出 software defined networking 和 software defined storage 近期的发展</li>
</ol>
<h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>理解<strong>云存储</strong>的基础概念，并描述它们是怎么应用在诸如 Amazon S3 和 HDFS 这类存储系统上的</p>
<ol>
<li>描述数据和存储的总体组织</li>
<li>列举不同的数据类型并给出它们的对比</li>
<li>了解规模化可能出现的问题与大数据管理，讨论不同的存储抽象</li>
<li>比较不同的文件系统，并思考它们的设计考虑，如 HDFS vs CephFS</li>
<li>比较不同的数据库并讨论它们的设计权衡</li>
<li>了解云对象存储的概念，列举数据存储中所用的 block devices</li>
</ol>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>分析不同的<strong>云计算模型</strong>，并应用它们来在云上解决问题</p>
<ol>
<li>理解并行和分布式编程模型的基础概念</li>
<li>对比不同的云编程模型：MapReduce, Spark, GraphLab 和 Spark Streaming</li>
<li>解释 MapReduce 编程模型中主要的执行流，调度和容错概念</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://www.cloudcomputingpatterns.org/" target="_blank" rel="external">Cloud Computing Patterns</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云计算作为未来的大势所趋，是每个 IT 从业者都需要关注的，这个系列结合我从校园到工作中围绕云计算积攒下来的相关经验，分享给大家。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="导论" scheme="http://wdxtub.com/tags/%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Q Con 2017 PPT 学习笔记</title>
    <link href="http://wdxtub.com/2017/05/21/q-con-2017-note/"/>
    <id>http://wdxtub.com/2017/05/21/q-con-2017-note/</id>
    <published>2017-05-21T07:06:50.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直觉得，每次开技术会议之后，花时间把相关的 PPT 过一遍，无论是预习还是复习，都是开拓视野和思路的好方法。所以凡是能找到下载的，我都会看看，这里是我的学习笔记。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.24: 完成 Day1 PPT</li>
<li>2017.05.21: 开始更新</li>
</ul>
<p>这里我简单划分成为几大类（及子分类），大家可以使用页面右边的目录挑选自己感兴趣的。</p>
<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="基于-Impala-构建实时用户行为分析引擎"><a href="#基于-Impala-构建实时用户行为分析引擎" class="headerlink" title="基于 Impala 构建实时用户行为分析引擎"></a>基于 Impala 构建实时用户行为分析引擎</h3><ul>
<li>用户行为：Who, When, Where, How, What，本质是一种特殊的日志数据</li>
<li>典型应用<ul>
<li>运营监控：PV, UV, 销售，活跃用户</li>
<li>产品改进：用户粘性，核心流程转化，新功能使用情况</li>
<li>商业决策</li>
</ul>
</li>
<li>灵活性 &gt; 及时性 &gt; 时效性</li>
<li>查询引擎：支持 SQL（足够灵活），交互式查询（足够快）</li>
<li>架构：底层 HBase + HDFS，上面是 Impala<ul>
<li>基于 MPP 的查询引擎</li>
<li>较低的容错性</li>
<li>较高的内存需求</li>
<li>较高的查询效率</li>
</ul>
</li>
<li>数据存储 Kudu + Parquet<ul>
<li>Kudu 存实时数据，Parquet 存历史数据</li>
<li>定期进行数据转储 Kudu -&gt; Parquet</li>
</ul>
</li>
<li>优化逻辑<ul>
<li>使用每天的活跃用户数据构建 Bloom Filter</li>
<li>Join 之前先用 Bloom Filter 进行过滤</li>
</ul>
</li>
</ul>
<h3 id="FreeWheel-大数据处理实践"><a href="#FreeWheel-大数据处理实践" class="headerlink" title="FreeWheel 大数据处理实践"></a>FreeWheel 大数据处理实践</h3><ul>
<li>架构：Kafka + Speed Layer(流处理，Spark，HBase) + Batch Layer(Hadoop，Spark，HDFS) + presto</li>
<li>Slider + Docker 弹性部署</li>
<li>Presto + Slider + YARN</li>
</ul>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><h3 id="人工智能技术打造智能商业体"><a href="#人工智能技术打造智能商业体" class="headerlink" title="人工智能技术打造智能商业体"></a>人工智能技术打造智能商业体</h3><ul>
<li>人工智能产生价值需要跨越两个门槛<ul>
<li>海量精准的大数据：为机器学习提供有价值的素材，需要企业完整的数字化、信息化流程</li>
<li>丰富明确的应用场景</li>
</ul>
</li>
<li>京东智能客服机器人<ul>
<li>用户需求<ul>
<li>售前咨询：咨询商品、查询参数、选择尺码、筛选对比</li>
<li>售后咨询：查询订单、查询物流、处理售后</li>
</ul>
</li>
<li>用户数据：聊天意图、聊天日志、订单信息、账户信息、访问记录</li>
<li>其他数据：商品数据、活动数据、物流数据、评价数据、网络数据</li>
<li>智能服务<ul>
<li>实时响应</li>
<li>个性化应答</li>
<li>主动关怀</li>
<li>多终端支持</li>
</ul>
</li>
<li>核心价值：提升服务体验、降低客服成本</li>
</ul>
</li>
</ul>
<h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><h3 id="技术管理的思考和实践"><a href="#技术管理的思考和实践" class="headerlink" title="技术管理的思考和实践"></a>技术管理的思考和实践</h3><ul>
<li>技术团队常见问题：忙乱无章、团队不稳定、缺乏技术含量、结果不满意、看不到发展</li>
<li>规划：路线图、目标选择、目标拆解、人才盘点</li>
<li>结果：结果呈现、项目总结、绩效结果和沟通</li>
<li>过程：把需求篮子建设好、技术需求、梯队建设、有章法地推进事情、能力模型和用人之道、助力员工提升</li>
<li>人才盘点：数量、资历、技能、类型、引入方式</li>
<li>需求原则<ul>
<li>客户为中心</li>
<li>平衡搭配，远近结合，有自己的节奏</li>
<li>关注价值和痛点</li>
<li>前瞻研究</li>
</ul>
</li>
</ul>
<h3 id="团队和工程管理取舍的实践"><a href="#团队和工程管理取舍的实践" class="headerlink" title="团队和工程管理取舍的实践"></a>团队和工程管理取舍的实践</h3><ul>
<li>70% 的工作不是研发过程，而是软件维护</li>
<li>70% 的人看到告警之后不会马上采取行动</li>
<li>70% 的运维天然对故障和告警敏感</li>
<li>没有完整工具链支持，DevOPS 就是瞎扯</li>
<li>OPSDev 可能更符合国情</li>
<li>基于一个成熟产品去研发，最保险，见效快，更从容</li>
<li>团队技能书不具备对应的产品要求，千万不要自研</li>
<li>直接面向开源去做自研，不仅代码质量号，文档也会更好</li>
<li>自研有很大风险，但能提升团队的技术追求和欲望</li>
<li>成熟开源软件不解决的问题，通常都是不重要的问题</li>
<li>周会是用来同步信息的，不是用来讨论具体问题的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直觉得，每次开技术会议之后，花时间把相关的 PPT 过一遍，无论是预习还是复习，都是开拓视野和思路的好方法。所以凡是能找到下载的，我都会看看，这里是我的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="会议" scheme="http://wdxtub.com/tags/%E4%BC%9A%E8%AE%AE/"/>
    
      <category term="PPT" scheme="http://wdxtub.com/tags/PPT/"/>
    
      <category term="视野" scheme="http://wdxtub.com/tags/%E8%A7%86%E9%87%8E/"/>
    
  </entry>
  
  <entry>
    <title>Tableau 白皮书阅读笔记</title>
    <link href="http://wdxtub.com/2017/05/03/tableau-white-paper-clip/"/>
    <id>http://wdxtub.com/2017/05/03/tableau-white-paper-clip/</id>
    <published>2017-05-03T02:32:49.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近在做数据相关工作，顺带把 Tableau 公开的数据相关白皮书看了一遍，感觉还是学到不少东西的，这里分享给大家。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.03: 完成初稿</li>
</ul>
<h2 id="商业智能"><a href="#商业智能" class="headerlink" title="商业智能"></a>商业智能</h2><p>只有了解数据，才能正确决策，在竞争中保持领先</p>
<ol>
<li>速度</li>
<li>可视化数据探索</li>
<li>连接到任何数据</li>
<li>实时协作</li>
<li>全面管控</li>
<li>可扩展性</li>
<li>移动 </li>
</ol>
<h3 id="2017-年"><a href="#2017-年" class="headerlink" title="2017 年"></a>2017 年</h3><ol>
<li>现代商业智能成为新常态<ul>
<li>借助可信和可拓展的平台，各组织可以让分析师以外的人员也能够探索受规管的数据，并利用自己的发现开展协作</li>
</ul>
</li>
<li>协作式分析从边缘进入核心<ul>
<li>信息单向流动的年代即将结束，人们将通过共享实时交互式工作簿和数据源来为业务决策提供支持</li>
</ul>
</li>
<li>一切数据趋于平等<ul>
<li>大数据和简单 Excel 电子表格之间的区别将不再重要</li>
<li>重要的是人们能够快速轻松访问数据，并结合其他类型的数据对其进行探索，从而回答业务问题</li>
</ul>
</li>
<li>自助分析扩展至数据准备<ul>
<li>数据解析、JSON 和 HTML 导入以及数据整理之类的普通数据准备无需再分配给专家完成</li>
</ul>
</li>
<li>得益于嵌入式商业智能，分析已经无处不在<ul>
<li>效果最好的分析是自然存在于工作流中的分析</li>
</ul>
</li>
<li>IT 部门成为数据英雄<ul>
<li>IT 从制作者变为功能提供者</li>
<li>掌控着以自助式服务为目标的大规模转变过程</li>
</ul>
</li>
<li>人们开始以更加自然的方式处理数据</li>
<li>向云端的过度加速进行</li>
<li>高级分析变得更加易于访问</li>
<li>数据素养成为未来的一项基础技能 </li>
</ol>
<h3 id="2015-年"><a href="#2015-年" class="headerlink" title="2015 年"></a>2015 年</h3><ol>
<li>治理方式转变。封闭所有企业数据的简单做法不再奏效</li>
<li>社交智能是竞争优势</li>
<li>分析在组织的各个角落涌现</li>
<li>社区与众不同</li>
<li>一切皆集成</li>
<li>云分析不再只适合云数据</li>
<li>与数据对话取代静态仪表板</li>
<li>数据与新闻珠联璧合</li>
<li>移动成熟</li>
<li>智能分析开始兴起</li>
</ol>
<h2 id="云技术趋势"><a href="#云技术趋势" class="headerlink" title="云技术趋势"></a>云技术趋势</h2><h3 id="2017-年-1"><a href="#2017-年-1" class="headerlink" title="2017 年"></a>2017 年</h3><ol>
<li>IT 转变其技能组合<ul>
<li>对云端专业知识的需求将会愈加迫切</li>
<li>侧重于云端安全性、托管数据库以及『基础架构即服务』</li>
<li>采用能够实现持续性项目开发和交付的灵活方法</li>
</ul>
</li>
<li>组织积极迎接混合世界</li>
<li>IT 积极与业务用户合作</li>
<li>软件治理同时改善了 IT 和业务部门的境遇</li>
<li>托管应用程序可以简化内部业务运营</li>
<li>长期的客户成功和采用是重中之重</li>
<li>云服务供应商可以降低地区性数据法规的复杂性</li>
<li>灵活的分析可以解决物联网『最后一英里』问题<ul>
<li>分析来自多个数据源、格式各不相同的数据</li>
</ul>
</li>
<li>服务提供商从软件部署转向变更管理</li>
<li>所有标准应用程序都带有协作功能</li>
</ol>
<h3 id="2016-年"><a href="#2016-年" class="headerlink" title="2016 年"></a>2016 年</h3><ol>
<li>这是一场数据抢滩战</li>
<li>合作伙伴陷入云价格战中</li>
<li>大公司以大规模迈入云时代</li>
<li>云分析助力 IT</li>
<li>硬件巨擘创造性地保持云相关性</li>
<li>将数据迁移到云更贴近复制/粘贴</li>
<li>云数据隐私</li>
<li>云技术市场使软件公司陷入两难窘境</li>
<li>混合云策略变得简单</li>
<li>移动和云分析日趋相同</li>
</ol>
<h3 id="2015-年-1"><a href="#2015-年-1" class="headerlink" title="2015 年"></a>2015 年</h3><ol>
<li>IT 人员支持云计算发展</li>
<li>云分析涵盖所有分析</li>
<li>虚拟私有云成为了新型『内部』云</li>
<li>平台价格不断坠落</li>
<li>上千种云服务将不断浮现和消失</li>
<li>身份信息进入云端。SAML 和 SSO 成为常用技术</li>
<li>云数据环境将数据堡垒变为数据集市</li>
</ol>
<h2 id="大数据趋势"><a href="#大数据趋势" class="headerlink" title="大数据趋势"></a>大数据趋势</h2><h3 id="2017-年-2"><a href="#2017-年-2" class="headerlink" title="2017 年"></a>2017 年</h3><ol>
<li>大数据速度提高、门槛降低：选项增多，加快 Hadoop 速度<ul>
<li>数据库 Exasol, MemSQL</li>
<li>基于 Hadoop 的存储 Kudu</li>
<li>SQL-on-Hadoop 引擎 Impala, Hive, Prestro, Phoenix, Drill</li>
<li>OLAP-on-Hadoop 技术 AtScale, JethroData, Kyvos Insights</li>
</ul>
</li>
<li>大数据不再仅仅是 Hadoop：为特定用途构建的 Hadoop 工具变得过时。仅仅为 Hadoop 构建且无法跨用例部署的平台将受到冷落</li>
<li>为了获取价值，组织从起步阶段就开始利用数据湖。促使业务和 IT 部门建立更牢固的合作关系。作为大数据资产的利用工具，自助式平台将会在更大程度上得到认可</li>
<li>日趋成熟的基础架构拒绝一成不变的架构<ul>
<li>Hadoop 不再仅仅是数据科学用例的批处理平台。它已经成为临时分析的多功能引擎</li>
</ul>
</li>
<li>大数据投资的驱动因素是种类，而不是数量和速度<ul>
<li>尝试集成更多数据源并专注于大数据的『长尾巴』。连接器正在变得更加关键</li>
</ul>
</li>
<li>Spark 和机器学习为大数据增辉</li>
<li>物联网、云和大数据的汇合为自助式分析创造新的机会。<ul>
<li>物联网正在生成大量结构化和非结构化数据 </li>
<li>越来越需要可以无缝连接和合并多种云端托管数据源的分析工具 </li>
</ul>
</li>
<li>自助式数据准备成为主流，最终用户开始影响大数据</li>
<li>大数据发展壮大：Hadoop 增强企业标准<ul>
<li>Apache Sentry, Apache Atlas, Apache Ranger</li>
</ul>
</li>
<li>元数据目录的兴起可以帮助人们找到值得分析的大数据<ul>
<li>元数据目录可以帮助用户发现和理解值得使用自助式工具进行分析的相关数据</li>
<li>使用机器学习来实现 Hadoop 数据的自动查找</li>
</ul>
</li>
</ol>
<h3 id="2016-年-1"><a href="#2016-年-1" class="headerlink" title="2016 年"></a>2016 年</h3><ol>
<li>NoSQL 接管市场</li>
<li>Apache Spark 为大数据点亮明灯</li>
<li>Hadoop 项目成熟，企业继续其从 Hadoop 概念证明到生产的过渡</li>
<li>大数据发展壮大，Hadoop 加入企业标准之中</li>
<li>大数据飞速发展，选项增多，加快 Hadoop 速度</li>
<li>最终用户拥有更多的选项，来为各种形式的数据做准备</li>
<li>云端 MPP 数据仓库发展升温</li>
<li>流行技术融合，物联网、云端和大数据实现融合</li>
</ol>
<h3 id="2015-年-2"><a href="#2015-年-2" class="headerlink" title="2015 年"></a>2015 年</h3><ol>
<li>大数据云端化</li>
<li>ETL 私人化</li>
<li>在 SQL 和 NoSQL 中选择</li>
<li>Hadoop：一种新的常规数据存储配置</li>
<li>开始尝试在数据湖中搜索</li>
<li>大数据生态系统将开始改变形态</li>
<li>物联网将继续发展，促成新的数据解决方案</li>
</ol>
<h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><ol>
<li>迭代和快速行动</li>
<li>通过交互实现更深层次的探索</li>
<li>通过数据融合拓宽分析范围</li>
<li>促进共享和协作</li>
</ol>
<h2 id="移动商业智能"><a href="#移动商业智能" class="headerlink" title="移动商业智能"></a>移动商业智能</h2><ol>
<li>了解使用环境</li>
<li>了解用户意图<ul>
<li>探索、查看、互动、协作</li>
</ul>
</li>
<li>专为移动设备设计<ul>
<li>一次制作，随处使用</li>
</ul>
</li>
</ol>
<h2 id="零售分析趋势"><a href="#零售分析趋势" class="headerlink" title="零售分析趋势"></a>零售分析趋势</h2><h3 id="2017-年-3"><a href="#2017-年-3" class="headerlink" title="2017 年"></a>2017 年</h3><ol>
<li>高级分析不再是分析师的专利</li>
<li>全面实现移动分析</li>
<li>物联网开始提高数据准确性</li>
<li>全渠道数据集成开始风生水起</li>
<li>机器人技术为零售数据带来重大机遇</li>
<li>增强显示和虚拟现实为零售商分析带来更多见解</li>
</ol>
<h3 id="2016-年-2"><a href="#2016-年-2" class="headerlink" title="2016 年"></a>2016 年</h3><ol>
<li>高级分析不再是分析师的专利</li>
<li>全面实现移动分析</li>
<li>物联网数据改变购物方式</li>
<li>全渠道数据集成精彩纷呈</li>
<li>零售营销组合现代化</li>
<li>实时库存不可或缺</li>
</ol>
<h3 id="重要图表"><a href="#重要图表" class="headerlink" title="重要图表"></a>重要图表</h3><ul>
<li>类别小倍数图表，快速比较多种货品一目了然，包括产品类别绩效<ul>
<li>列出许多不相关的货品，轻松进行纵向比较与横向比较</li>
</ul>
</li>
<li>周边地区客户群体图<ul>
<li>为您销售地点周边的客户群显示地形情况</li>
<li>本地和即时市场明确的示意图</li>
<li>了解与您所在低的物理距离如何构成或不构成您所在地的障碍</li>
<li>确定潜在竞争对手市场</li>
</ul>
</li>
<li>货架陈列图<ul>
<li>了解产品摆放和库存的有效程度</li>
<li>货品广受欢迎时更快地获知</li>
<li>了解客户喜好</li>
<li>查看哪些货品过去销量最佳与哪些货品长期占据货架</li>
</ul>
</li>
<li>损耗热图<ul>
<li>指出货品在何处消失并帮助找出潜在的安全盲点</li>
<li>快速了解商场盗窃的多样化及频率</li>
<li>从部门着手解决损耗问题</li>
<li>了解某地总体失窃的历史趋势</li>
</ul>
</li>
<li>移动设备上的商场指标<ul>
<li>在楼层实地做出决策，而非在电脑前</li>
<li>将数据反映的情况与货架上的实际情况相比较</li>
</ul>
</li>
</ul>
<h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p>天才是展现出初衷的智力、创造力或原创力的人士，其程度通常达到能实现前所未有的洞察力</p>
<ul>
<li>提出更深入的问题<ul>
<li>超越社交媒体平台的内置分析解决方案，导出大量数据，使用拖放式数据可视化工具</li>
</ul>
</li>
<li>将社交媒体与其他数据源融合</li>
<li>生成可供所有人探索和使用的交互式仪表盘</li>
</ul>
<h3 id="重要图表-1"><a href="#重要图表-1" class="headerlink" title="重要图表"></a>重要图表</h3><ul>
<li>关注者/触及人数增长斜度图<ul>
<li>横轴：时间；纵轴：人数</li>
<li>数据：关注者增长、提及量、总参与度、触及人数</li>
<li>元素：标签、元素</li>
<li>斜度图显示起始点和结束点之间的变化，用来比较变化率以及起止排名</li>
<li>斜度图消除了干扰，只关注两个日期之间的变化率</li>
</ul>
</li>
<li>全球/地区链接点击数地图<ul>
<li>数据：社交网络链接点击数、带地理位置标签的数据、关注者所在位置</li>
<li>元素：位置、颜色、种类</li>
<li>地图能看到用户所在地区，以及存在的地域差别</li>
<li>快速明确活跃和不活跃地区</li>
<li>查看行为差异</li>
</ul>
</li>
<li>触及人数和参与度散点图<ul>
<li>横轴：触及人数；纵轴：用户参与度</li>
<li>数据：自然触及人数/付费触及人数、点赞数、关注者数、推文数</li>
<li>元素：类别、元素</li>
<li>使用散点图可以很容易地看到离群点和聚合</li>
<li>找出离群点以及哪些帖子的效果不同于其他帖子</li>
</ul>
</li>
<li>盒须图上的点击率<ul>
<li>横轴：不同渠道；纵轴：点击率</li>
<li>数据：点击率、类别区分的参与度、触及人数</li>
<li>元素：中位数、四分位数、颜色</li>
<li>比较数据在不同类别的分布</li>
<li>离群点很容易看到</li>
</ul>
</li>
</ul>
<h2 id="从早期数据巨星学到的五条经验"><a href="#从早期数据巨星学到的五条经验" class="headerlink" title="从早期数据巨星学到的五条经验"></a>从早期数据巨星学到的五条经验</h2><ul>
<li>可视化帮助人们了解数据、<ul>
<li>图表在阐述重要统计数据的特定数量方面非常实用，它以直观方式表现主题中的各种想法，如果以数字表示时，理解起来就不会这么容易</li>
</ul>
</li>
<li>与其他人谈论您的工作<ul>
<li>加入用户组和聚会</li>
<li>活跃于社交网络</li>
</ul>
</li>
<li>使用铅笔<ul>
<li>手绘图将注意力集中于<strong>演示和设计</strong></li>
<li></li>
</ul>
</li>
<li>附有创造力</li>
<li>让大数据激发您的灵感<ul>
<li>我们获得的数据时钟超过了我们对如何使用数据的了解</li>
<li>适应新挑战，投资相应工具，用于处理当今的数据量</li>
</ul>
</li>
</ul>
<h2 id="构建自助服务分析环境"><a href="#构建自助服务分析环境" class="headerlink" title="构建自助服务分析环境"></a>构建自助服务分析环境</h2><p>针对营销，具体要求：</p>
<ul>
<li>选择重要指标<ul>
<li>核心目标</li>
<li>营销活动和营销工作对实现这些目标有何帮助</li>
<li>目标的内部或外部数据</li>
<li>设计有意义的指标来衡量这些助益</li>
<li>解释营销对目标的促进做用时，这个指标是否必须</li>
<li>制定一种系统和持续的衡量方法</li>
</ul>
</li>
<li>从所有来源拉取数据以了解全局</li>
<li>直观形象</li>
<li>使其可交互以便于写作</li>
<li>最新且实时</li>
<li>访问简单、使用轻松</li>
</ul>
<p>好奇心的驱动力是对理解事物及其缘由、原理和目的的需求。知其所以然更有益于理解。答案与过程结合形成透彻理解，可帮助我们取其精华去其糟粕，并发现新机遇。</p>
<p>在尝试理解事物和寻求答案的过程中，数据可助我们一臂之力。数据透露着事实和真理，让我们能够客观看待既往。数据就是知识，知识就是力量，只要能够利用数据的力量进行求索和决策，就能找到我们寻求的真知灼见和机遇。</p>
<p>为创造完善的分析环境，组织必须结合其最重要的两项资产：员工和数据。让员工能够在受 IT 部门信任、保护和管理的环境中查看数据，不但能够熟悉业务，了解情形，并有可能充分实现其见解的潜在价值。相应员工可以调查数据，就数据进行协作，并根据其分析制定适当决策。这种查看和了解数据的能力并不与职务或地位挂钩。在分析环境下，人人都可访问适当数据，并受到鼓励去探索。</p>
<p>这并非一日之功，而是一项需要快积跬步才得以至千里的工作。</p>
<p>构建新环境时，确定能够推动这种变革的领导者非常重要。行政支持者还可以帮助建立适当的组织架构来支持分析环境。无需编写脚本或代码。无需与复杂的数据透视表做斗争，也没有会阻碍探索和发现的限制性模板。</p>
<p>分析环境依赖于用户乐于使用的强大分析平台。这一平台应易于在组织内进行部署、管理和拓展。</p>
<p>采用新的分析环境意味着利用数据制定决策，但并不意味着将直觉抛诸脑后。在这种环境中，用户同等重视经验数据和直觉，不偏不倚。达到适当的平衡至关重要。</p>
<p>任何出色的分析活动都从直觉和假设开始，我们可以使用数据证实或反驳这种直觉和假设。</p>
<p>分析环境让组织能够更善用其最重要的两项资产：员工和数据。它让员工能够按业务需要的速度使用数据制定决策，并让组织能够抓住商机，获得竞争优势。</p>
<p>能够查看数据还可帮助人们实现自身所力不能及的目标。能够提供游戏的客户服务或推动世界积极改变，这些都是向目标看齐的工作示例。</p>
<h2 id="数据策略在-LinkedIn-的实践"><a href="#数据策略在-LinkedIn-的实践" class="headerlink" title="数据策略在 LinkedIn 的实践"></a>数据策略在 LinkedIn 的实践</h2><p>重点放在三个核心价值、两个可测量维度和一个用户友好的前端上面</p>
<h3 id="三个关键价值"><a href="#三个关键价值" class="headerlink" title="三个关键价值"></a>三个关键价值</h3><p>简单易懂非常重要，但简单常常是费劲心力谋划细节的结果。简单来说就是三个 A</p>
<ol>
<li>客户角度 Account lens：从整个客户的角度看待所有商机线索 - 而不是将每个潜在客户看作是单独的个人。但是，这并不表示去个性化或反社交的看法。</li>
<li>分析 Analytics：汇集多种数据流上，只用一个门户即可访问所有信息。分析将变得更简单，更多时间可花在利用可用数据作出决策上面</li>
<li>自动化 Automation：明确的信息和可搜索的工具不仅仅是给客户使用。</li>
</ol>
<p>我们不想让销售人员花上几个小时努力收集信息，我们希望查找信息就像上 LinkedIn, Facebook, Twitter 或 Google 那样容易。信息就在那里，触手可得，极其容易理解，也极其容易共享</p>
<h3 id="两个简单维度"><a href="#两个简单维度" class="headerlink" title="两个简单维度"></a>两个简单维度</h3><p>数十亿个数据点，简单使我们得到广泛采用，并取得成功结果。</p>
<p>从以客户为中心的角度分析数据，归根结底就是新平台的全部目的，而成功的关键将在于极其简单的设置。</p>
<p>LinkedIn 先沿着两根轴绘制其潜在客户『温度』和『奖励规模』。温度是指完成销售的可能性，而规模就是潜在交易的大小。</p>
<p>从客户角度中，个人被视为公司的延伸。于是 LinkedIn 考虑与每个客户相关的个人的活动来计算每个客户的『温度』。『奖励规模』基于公司整体。公司由此而得的网格中所处的位置决定了销售人员为追到这家客户而采取的步骤。</p>
<p>潜在客户可能属于四个象限中的一个：</p>
<ul>
<li>低温度、小规模：培养、自动化营销、找到愿意接受新观念的客户</li>
<li>低温度、大规模：自动化营销，投入更多资源，使用现场销售</li>
<li>高温度、小规模：关注这些客户很重要，但不需要现场跟进，内部销售策略多样灵活</li>
<li>高温度、大规模：以贵宾礼遇相待，从支持人员到销售高管的每个人都可能参与赢得这些客户的活动中</li>
</ul>
<h3 id="一个前端"><a href="#一个前端" class="headerlink" title="一个前端"></a>一个前端</h3><p>聚合来自多种来源的数据，以确定其线索在『规模』和『温度』维度上的分数。尽量隐藏所有底层数据结构和基础结构，得到的简单性可使销售代表关注于关键指标和可采取的步骤。</p>
<h3 id="识别重要事件"><a href="#识别重要事件" class="headerlink" title="识别重要事件"></a>识别重要事件</h3><p>基于事件的客户管理（eBAM），将客户 - 而不是地区分配给销售人员</p>
<h2 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h2><ol>
<li>实现自主</li>
<li>加速每个阶段</li>
<li>灵活安全的配置</li>
<li>可视化理解</li>
</ol>
<h3 id="院校利用数据产生影响"><a href="#院校利用数据产生影响" class="headerlink" title="院校利用数据产生影响"></a>院校利用数据产生影响</h3><ul>
<li>跟踪入学趋势</li>
<li>创建交互式大学简介</li>
<li>吸引潜在捐款人</li>
<li>通报调查结果</li>
<li>分析空间使用率</li>
<li>对比兄弟院校进行基准评测</li>
<li>表明财务责任</li>
<li>改进沟通和合作</li>
</ul>
<h2 id="提升政府的绩效管理"><a href="#提升政府的绩效管理" class="headerlink" title="提升政府的绩效管理"></a>提升政府的绩效管理</h2><ul>
<li>让工作人员使用自助服务可视化分析</li>
<li>选择重要的计分卡指标（政府人员需要能够证明自己代表公众做出的决策）<ul>
<li>核心目标是什么？</li>
<li>推行的计划对这些目标的达成有何直接助益？采用哪些价值标准来衡量这些助益</li>
<li>不论来自内部或外部，目前的数据是有利于达成这些目标的合适数据，还是只是最容易获取的数据</li>
<li>能否设计出一项有意义的指标来衡量这些助益</li>
<li>是否真的必须在采用这项指标后，才能解释计划对达成这些目标所起到的帮助做用</li>
<li>能否制定一种系统性、持续性的衡量方法</li>
<li>市民最关心哪些信息的披露</li>
<li>了解哪些信息后，市民和选民才会积极参与政府事务</li>
</ul>
</li>
<li>利用当前数据</li>
<li>建立协作文化</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近在做数据相关工作，顺带把 Tableau 公开的数据相关白皮书看了一遍，感觉还是学到不少东西的，这里分享给大家。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="趋势" scheme="http://wdxtub.com/tags/%E8%B6%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>LDA 指南</title>
    <link href="http://wdxtub.com/2017/05/03/lda-guide/"/>
    <id>http://wdxtub.com/2017/05/03/lda-guide/</id>
    <published>2017-05-03T02:30:19.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>LDA 作为文本分析中非常有用的算法，无论是在学术界还是工业界都已被广泛运用。本文是写给自己的 LDA 理解指南。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.03: 完成初稿</li>
</ul>
<p>关于 LDA 算法，网上的资料不胜枚举，除了 <a href="https://en.wikipedia.org/wiki/Latent_Dirichlet_allocation" target="_blank" rel="external">wiki</a>，我最推荐 <a href="http://yuedu.baidu.com/ebook/d0b441a8ccbff121dd36839a.html" target="_blank" rel="external">《 LDA 漫游指南》</a>。那么为什么我还要自己写一篇呢？一是加深理解，二是给出我在工作中应用 LDA 的一些思考。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>我们首先需要知道的是，LDA 是一种无监督机器学习技术，用来识别大规模文档集或语料库中潜在隐藏的主题信息。具体是怎么识别主题的呢？LDA 中最小单位是词，并假定每个词是由一个潜在隐藏的主题中抽取出来的。</p>
<p>当然，本文不会涉及具体的推导（用 mathjax 敲这些公式太痛苦了）。我们用上帝视角来还原整个过程：</p>
<ol>
<li>拿到一篇文章，文章是由『词』组成的</li>
<li>因为开了上帝视角，我们能够一眼看出每个『词』所属的『主题』</li>
<li>又因为开了上帝视角，我们在知道了每个『词』所属的『主题』之后，就可以判断出这篇文章所对应的『主题』了。</li>
</ol>
<p>那么 LDA 在这里做了什么？其实就是通过概率和计算，帮我们开了这么个上帝视角。如果对具体的推导感兴趣，可以参阅最后的链接。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为每个文章会被『划归』到某个『主题』中，所以我们可以：</p>
<ul>
<li><strong>相似文档发现</strong>，具体到产品中可以是『相关新闻』『类似文章』</li>
<li><strong>自动打标签</strong>，具体步骤为：分词 - 词性标注 - 去掉副词、介词 - LDA 训练 - 获取主题相关词，这些相关词即为标签</li>
<li><strong>新闻个性化推荐</strong>，具体步骤为：用 LDA 得到文章 Topic - 用 LR 进行点击预测 - 推荐同 Topic 最可能点击（且未点击）的新闻。另一种可能的方式是（不需要 LR）：记录用户的点击偏好（比如最常看哪类 topic） - 推荐这个 topic 中 topK 的文章（这个方法更加简答）</li>
</ul>
<h3 id="主题打分"><a href="#主题打分" class="headerlink" title="主题打分"></a>主题打分</h3><p>因为 LDA 生成的主题是没有排序的，所以我们可以把显著的、有特色的主题排到前面，而将不明意义的主题往后面排。</p>
<p>注：这个在客服行业中非常有用，因为有时候会需要从大量的客服日志中提取出通用的 FAQ 问题并建立知识库，如果有这么一个排序，就可以减少人工评判的工作量。</p>
<p>算法的核心思路是当前 topic 的概率分本与垃圾分布的距离。如果你跟我一样用 gensim 这个 python 包的话，那么下面这几个函数需要重点留意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">get_document_topics(bow, minimum_probability=None, minimum_phi_value=None, per_word_topics=False)</div><div class="line">    Return topic distribution for the given document bow, as a list of (topic_id, topic_probability) 2-tuples.</div><div class="line">    Ignore topics with very low probability (below minimum_probability).</div><div class="line">    If per_word_topics is True, it also returns a list of topics, sorted in descending order of most likely topics for that word. It also returns a list of word_ids and each words corresponding topics’ phi_values, multiplied by feature length (i.e, word count)</div><div class="line"></div><div class="line">get_term_topics(word_id, minimum_probability=None)</div><div class="line">    Returns most likely topics for a particular word in vocab.</div><div class="line"></div><div class="line">get_topic_terms(topicid, topn=10)</div><div class="line">    Return a list of (word_id, probability) 2-tuples for the most probable words in topic topicid.</div><div class="line">    Only return 2-tuples for the topn most probable words (ignore the rest).</div></pre></td></tr></table></figure>
<p>这里我们需要计算两个距离：</p>
<ol>
<li>topic -&gt; doc 距离。主要看文章分布是不是过于平均</li>
<li>topic -&gt; word 距离。主要看关键词排序是不是过于平均</li>
</ol>
<p><strong>topic -&gt; doc 距离</strong></p>
<p>我们先由前面的 <code>get_document_topics</code> 获取到每个 document 对应 topic，然后转换成每个 topic 对应的 document。因为每个 document 对应到 topic 是有一个概率的，我们需要归一化一下，这里举个例子就清楚了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 假设 topic A 中只有四篇文章</span></div><div class="line">doc1 - 属于 topic A 的概率是 0.9</div><div class="line">doc2 - 属于 topic A 的概率是 0.8</div><div class="line">doc3 - 属于 topic A 的概率是 0.7</div><div class="line">doc4 - 属于 topic A 的概率是 0.6</div><div class="line"></div><div class="line"><span class="comment"># 那么 topic A -&gt; doc 的概率分布向量经过归一化后是</span></div><div class="line"><span class="comment"># 这里的 3 = 0.9 + 0.8 + 0.7 + 0.6，保证这个向量每个元素相加最后等于 1 即可</span></div><div class="line">[0.9/3, 0.8/3, 0.7/3, 0.6/3]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 我们需要跟下面这个背景噪音向量进行比较</span></div><div class="line"><span class="comment"># 这里 4 是文章的数目</span></div><div class="line">[1/4, 1/4, 1/4, 1/4]</div></pre></td></tr></table></figure>
<p>然后我们只要计算这两个向量之间的距离即可，各类距离的计算方法可以看<a href="https://en.wikipedia.org/wiki/Category:Similarity_and_distance_measures" target="_blank" rel="external">这里</a>，KL divergence, Cosine, 皮尔逊相关度之类的都可以，距离越大，主题越有特色。</p>
<p><strong>topic -&gt; word 距离</strong></p>
<p>我们先由 <code>get_topic_terms</code> 获取 topic -&gt; word 的概率分布，然后我们计算出词向量，具体我们还是看例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 假设 Topic A 有 4 个关键词（可以自己设置，这里只是一个例子）</span></div><div class="line">word1 0.30</div><div class="line">word2 0.25</div><div class="line">word3 0.25</div><div class="line">word4 0.20</div><div class="line"></div><div class="line"><span class="comment"># 转化成向量比之前的要简单</span></div><div class="line">[0.3, 0.25, 0.25, 0.2]</div><div class="line"></div><div class="line"><span class="comment"># 我们需要跟下面这个背景噪音向量进行比较</span></div><div class="line"><span class="comment"># 这里 4 是该 topic 下词的数目</span></div><div class="line">[1/4, 1/4, 1/4, 1/4]</div></pre></td></tr></table></figure>
<p>然后我们只要计算这两个向量之间的距离即可，各类距离的计算方法可以看<a href="https://en.wikipedia.org/wiki/Category:Similarity_and_distance_measures" target="_blank" rel="external">这里</a>，KL divergence, Cosine, 皮尔逊相关度之类的都可以，距离越大，主题越有特色。（和前面一样的只是复制粘贴一下）。</p>
<p>最终得分是一个加权的排序，我们的公式是</p>
<p>$$Final\;Score=a\times Topic2DocScore + b\times Topic2WordScore$$</p>
<p>这里的 a 和 b 可以根据需要自己调整。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>抛开原理不谈，其实 LDA 的具体应用更多是在给出一个排序的依据，无论是相似还是推荐，本质都是排序（只是排序的标准不同），而在这个排序的过程中所给出的隐含 topic，如果可以加以利用，就能得到意想不到的效果。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://yuedu.baidu.com/ebook/d0b441a8ccbff121dd36839a.html" target="_blank" rel="external">LDA 漫游指南</a></li>
<li><a href="http://blog.csdn.net/huagong_adu/article/details/7937616/" target="_blank" rel="external">主题模型-LDA浅析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LDA 作为文本分析中非常有用的算法，无论是在学术界还是工业界都已被广泛运用。本文是写给自己的 LDA 理解指南。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="数学" scheme="http://wdxtub.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="模型" scheme="http://wdxtub.com/tags/%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="主题" scheme="http://wdxtub.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker 完全指南</title>
    <link href="http://wdxtub.com/2017/05/01/docker-guide/"/>
    <id>http://wdxtub.com/2017/05/01/docker-guide/</id>
    <published>2017-04-30T23:56:51.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 作为新瓶装旧酒的一门技术，用简单便捷的操作极大改变了软件开发的流程与生态环境，本文我们就来了解一下。注：Docker 目前已改名为 Moby。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.01: 完成初稿</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul>
<li>Docker 最初 dotCloud 公司内部的一个业余项目</li>
<li>Docker 基于 Go 语言</li>
<li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li>
<li>Docker 的基础是 Linux 容器（LXC）等技术</li>
<li>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多</li>
<li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器</li>
</ul>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/images/14596424862659.png" alt=""></p>
<p><img src="/images/14596424920098.png" alt=""></p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>主要优势为：</p>
<ul>
<li>更快速的交付和部署 - 容器成为了最小单位</li>
<li>更高效的虚拟化 - 内核级虚拟化</li>
<li>更轻松的迁移和拓展</li>
<li>更简单的管理</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方网站提供了 <a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac</a>, <a href="https://docs.docker.com/linux/" target="_blank" rel="external">Linux</a> 和 <a href="https://docs.docker.com/windows/" target="_blank" rel="external">Windows</a> 版本的安装教程。我们只要跟着官方文档即可，这里不再赘述。</p>
<p>不过需要提一下 <a href="https://github.com/docker/kitematic" target="_blank" rel="external">Kitematic</a> 这个图形化工具（官方给出的定义是 Visual Docker Container Management on Mac &amp; Windows），对于熟悉和了解 Docker 是很好的帮助，大家可以体验一下。</p>
<p><strong>守护进程</strong></p>
<p>运行 Docker 守护进程时，可以用 <code>-H</code> 来改变绑定接口的方式，比如 <code>sudo /usr/bin/docker -d -H tcp://0.0.0.0:2375</code>，如果不想每次都输入这么长的命令，需要加入以下环境变量 <code>export DOCKER_HOST=&quot;tcp://0.0.0.0:2375&quot;</code></p>
<p><strong>图形用户界面</strong></p>
<p>虽然我们可以用命令来控制 docker，但是如果能有一个 web 管理界面，操作什么的会方便很多，比较常见的有</p>
<ul>
<li><a href="https://shipyard-project.com/" target="_blank" rel="external">Shipyard</a></li>
<li><a href="https://github.com/portainer/portainer" target="_blank" rel="external">Potainer</a></li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>基本概念</strong>主要有三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器 </li>
<li>用户基于镜像来运行自己的容器。镜像是基于 Union 文件系统的层式结构</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的。可以理解为生成容器的『源代码』</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Registry)<ul>
<li>集中存放镜像文件的场所，可以是公有的，也可以是私有的</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<p>另外 Docker 采用的是客户端/服务器架构，客户端只需要向 Docker 服务器或守护进程发出请求即可完成各类操作。那么问题来了，我们能用 Docker 来做什么呢？我们可以：</p>
<ul>
<li>统一、优化和加速本地开发和构建流程</li>
<li>保证不同的环境中可以得到相同的运行结果</li>
<li>创建隔离环境用于测试</li>
</ul>
<p>Docker 可以提供的隔离有：</p>
<ul>
<li>文件系统隔离：每个容器都有自己的 root 文件系统</li>
<li>进程隔离：每个容器都运行在自己的进程环境中</li>
<li>网络隔离：容器间的虚拟网络接口和 IP 地址都是分开的</li>
<li>资源隔离和分组：使用 cgroups 将 CPU 和内存之类的资源独立分配给每个 Docker 容器</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>查看 docker 状态 <code>sudo docker info</code></li>
<li>查看系统中正在运行的容器的列表 <code>docker ps</code><ul>
<li>加上 <code>-a</code> 可以列出所有容器</li>
<li>加上 <code>-l</code> 可以列出最后一次运行的容器</li>
</ul>
</li>
</ul>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>接下来我们用一个简单的例子来体验下 docker</p>
<h3 id="容器小介绍"><a href="#容器小介绍" class="headerlink" title="容器小介绍"></a>容器小介绍</h3><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器（对于初级应用来说后者更方便）。</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>可以利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>现在，我们来创建一个 ubuntu:14.04 的容器 <code>docker run ubuntu:14.04 /bin/echo &#39;Hello wdx!&#39;</code>（结果如下图所示）</p>
<p><img src="/images/14937971541033.jpg" alt=""></p>
<p>可以看到正确输出了我们的 “Hello wdx!”</p>
<p>接下来，我们用 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 可以启动一个 bash 终端用来交互。参数的意思是：</p>
<ul>
<li><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li>
<li><code>-i</code> 则让容器的标准输入保持打开</li>
</ul>
<p>我们可以输入一些命令来测试</p>
<p><img src="/images/14937972820559.jpg" alt=""></p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。我们用 <code>ps</code> 或 <code>top</code> 在伪终端中查看进程信息，可以看到只有我们运行的进程，没有其他花里胡哨的（上图最后一条命令）</p>
<p><strong>试一试如下命令</strong></p>
<ul>
<li><code>cat /etc/hosts</code></li>
<li><code>ip a</code></li>
<li><code>ps -aux</code></li>
<li><code>cd ~ &amp;&amp; echo &quot;hello wdx&quot; &gt; hello.txt &amp;&amp; cat hello.txt</code></li>
</ul>
<p>（细心的同学可能会发现这里的输出暗藏玄机）</p>
<p>操作完成后，输入 <code>exit</code> 便可以退出这个 ubuntu 容器。退出之后这个容器依然存在，我们可以用 <code>docker ps -l</code> 来看看：</p>
<p><img src="/images/14937985115086.jpg" alt=""></p>
<p>每个容器有一个 Container ID 和 Name，我们一般就是通过这俩来定位一个容器的。</p>
<hr>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们可以使用 <code>docker pull</code> 命令从仓库中获取所需要的镜像。比如说 <code>sudo docker pull ubuntu:12.04</code>，相当于 <code>sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>，即从注册服务器 <code>registry.hub.docker.com</code> 中的 <code>ubuntu</code> 仓库来下载标记为<code>12.04</code> 的镜像。</p>
<p>如果想从其他仓库注册服务器下载，需要输入完成的地址，例如：<code>sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></p>
<p>下载完成之后就可以使用该镜像了，比如下面的语句就会创建容器，其中运行 <code>bash</code>：<code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></p>
<p>可以使用 <code>dokcer images</code> 来显示本地已有的镜像，如下</p>
<p><img src="/images/14596963929829.jpg" alt="docker images"></p>
<p>具体字段的意思一目了然，这里不再赘述。然后我们来运行官方例子 <code>whalesay</code> 镜像。</p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>打开浏览器，进入 <a href="https://hub.docker.com/?utm_source=getting_started_guide&amp;utm_medium=embedded_Linux&amp;utm_campaign=find_whalesay" target="_blank" rel="external">Docker Hub</a></p>
<p><img src="/images/14596967621449.jpg" alt="Docker Hub"></p>
<p>搜索 <code>whalesay</code> 这个镜像，就可以看到结果，点进去可以看到详细内容（基于 Ubuntu）</p>
<p><img src="/images/14596968187418.jpg" alt="whalesay image"></p>
<p>然后我们来运行一下，使用命令 <code>docker run docker/whalesay cowsay boo</code>，其中 <code>cowsay</code> 是要运行的命令，后面的 <code>boo</code> 是参数。</p>
<p>Docker 会先在本地查找有没有镜像，如果没有就从仓库中下载，具体的运行结果是：</p>
<p><img src="/images/14596971019958.jpg" alt="cowsay boo"></p>
<p>也可以让鲸鱼说不同的话，比如：</p>
<p><img src="/images/14596971443647.jpg" alt=""></p>
<h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>如果想要制作自己的镜像，需要自己写 Dockerfile。具体步骤如下</p>
<ol>
<li>创建一个文件夹 <code>mkdir wdxtub; cd wdxtub</code>，构造镜像所需的所有东西都会放在这个文件夹中</li>
<li>创建一个名为 <code>Dockerfile</code> 的文件 <code>gedit Dockerfile</code></li>
<li>添加第一句话 <code>FROM docker/whalesay:latest</code>，表示我们的镜像以 <code>whalesay</code> 为基础</li>
<li>添加需要运行的命令，如 <code>RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</code>（<code>fortunes</code> 这个程序会输出名言警句）</li>
<li>通过 <code>CMD</code> 指定镜像载入之后需要执行的命令，如 <code>CMD /usr/games/fortune -a | cowsay</code></li>
<li>保存并关闭 Dockerfile</li>
<li>使用 <code>sudo docker build -t wdx-whale .</code> 来构造镜像，简单来说就是用 Dockerfile 中的内容按步骤构造</li>
<li>使用 <code>docker images</code> 应该就可以看到我们新创建的镜像</li>
</ol>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>然后我们就可以运行一下看看 <code>docker run wdx-whale</code></p>
<p><img src="/images/14596980932968.jpg" alt="搞笑句"></p>
<p>还有更贱的（感觉可以玩一天）</p>
<p><img src="/images/14596987783177.jpg" alt=""></p>
<p>如果想要把自己的镜像上传到网上，就需要注册一个 Docker Hub 帐号，然后点击 Create Repository，这里我创建了一个名为 <code>wdxtub/demo</code> 的公用仓库。</p>
<p>接下来我们需要打上 tag，目前 <code>docker images</code> 的情况是：</p>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>记住我们的 IMAGE ID 26ac9649d7da。用以下命令打 tag <code>docker tag 26ac9649d7da wdxtub/wdx-whale:latest</code>，然后再 <code>docker images</code> 一次：</p>
<p><img src="/images/14596998719751.jpg" alt=""></p>
<p>然后用这个命令登录 <code>docker login --username=yourhubusername --email=youremail@company.com</code>，对于我来说就是 <code>docker login --username=wdxtub --email=dacrocodilee@gmail.com</code></p>
<p>成功之后大概是这样：</p>
<p><img src="/images/14596999803535.jpg" alt="登录成功"></p>
<p>然后就可以 push 上去了 <code>docker push wdxtub/wdx-whale</code>，像下面这样</p>
<p><img src="/images/14597002872580.jpg" alt="push"></p>
<p>为了测试 pull 自己的镜像，我们先把本地上的 whale 镜像删掉：<code>docker rmi -f wdxtub/wdx-whale; docker rmi -f wdx-whale</code>（如果有其他的用不着的也都删掉），最后剩下（上课要用的镜像）：</p>
<p><img src="/images/14597004851281.jpg" alt=""></p>
<p>接着来运行一下 <code>docker run wdxtub/wdx-whale</code></p>
<h3 id="管理镜像"><a href="#管理镜像" class="headerlink" title="管理镜像"></a>管理镜像</h3><p>我们可以把镜像导出到本地文件，使用 <code>docker save</code> 命令即可，比如针对我现在有的镜像 <code>wdxtub/wdx-whale(id:26ac9649d7da)</code>，可以这样：<code>docker save -o wdx-local-whale.tar wdxtub/wdx-whale</code>。如果要载入的话，使用下面的命令即可（会载入相关的元数据信息）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">docker load --input wdx-local-whale.tar</div><div class="line"><span class="comment"># 或者</span></div><div class="line">docker load &lt; wdx-local-whale.tar</div></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 <code>docker rm</code> 删掉依赖于这个镜像的所有容器.</p>
<p><code>sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>
<blockquote>
<p>镜像的实现原理</p>
</blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>举个例子，</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器 <code>docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> 容器会把输出的结果(STDOUT)打印到宿主机上面</p>
<p><img src="/images/14597048507796.jpg" alt=""></p>
<p>如果使用了 -d 参数运行容器 <code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>，则显示是这样：</p>
<p><img src="/images/14597049156842.jpg" alt=""></p>
<p>使用 <code>docker logs containerid</code> 可以查看输出，如：</p>
<p><img src="/images/14597049744299.jpg" alt=""></p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</p>
<p>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，有很多种方法，包括使用 docker attach 命令或 nsenter 工具等。具体参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">这里</a></p>
<h3 id="终止与重新启动"><a href="#终止与重新启动" class="headerlink" title="终止与重新启动"></a>终止与重新启动</h3><p>使用 <code>docker stop containerid</code> 来终止容器。终止状态的容器可以用 <code>docker ps -a</code> 命令看到。</p>
<p>另外，<code>docker restart containerid</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="导入导出与删除"><a href="#导入导出与删除" class="headerlink" title="导入导出与删除"></a>导入导出与删除</h3><p>如果要导出本地某个容器，可以使用 <code>docker export containerid</code> 命令。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.0</div><div class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入，例如</span></div><div class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</div></pre></td></tr></table></figure>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p>
<p>注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的<code>docker rm</code> 默认并不会删除运行中的容器。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。相信信息可以直接看教程，这里不赘述了。</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html" target="_blank" rel="external">Docker Hub 指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html" target="_blank" rel="external">私有仓库指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/config.html" target="_blank" rel="external">配置文件指南</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="external">Install Docker Machine</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 作为新瓶装旧酒的一门技术，用简单便捷的操作极大改变了软件开发的流程与生态环境，本文我们就来了解一下。注：Docker 目前已改名为 Moby。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>写在一百万次访问</title>
    <link href="http://wdxtub.com/2017/04/26/one-million-visit/"/>
    <id>http://wdxtub.com/2017/04/26/one-million-visit/</id>
    <published>2017-04-26T07:16:40.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在写作上老天爷赏给我的大概是个窝窝头，但平凡的努力也可以有平凡的精彩。即使我走的不快，但只要一直在路上，就总能看到新的风景。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.26: 完成初稿</li>
</ul>
<p>今天早上起床，习惯性打开自己的博客，发现访问量居然突破了六位数。去年六月份我把访问统计加入到博客中时，曾无数次幻想过访问量到达一百万次的场景。唯一没有想过的就是这一天来得如此快，快到让我感觉有些不真实。</p>
<p>这不由得让我想起我在 Lofter 写书评的日子。我从 2013 年开始写书评，除了给读书会投稿外，还会发到自己的博客上。原本的念头很简单，就是找个地方把自己的文字存下来，毕竟从高中起就有零零碎碎的写作，虽然写得不咋地，但就这么丢了，着实可惜。</p>
<p>从最初的网易博客、博客大巴再到 Lofter，可以说基本上中文网络上现存和曾经存在过的博客平台我都使用过。兜兜转转一大圈，还是回到了自己搭建独立博客的路子上，毕竟从版面到内容都能够按照自己的喜好来，也不会『被』强行加上广告。我一不靠这个赚钱，二不想浪费读者流量，只是一个记录生活留下足迹的地方，就这样简简单单挺好。</p>
<p>写作不是为了增加粉丝，但是看到有人喜欢自己写的东西，还是很高兴的，还记得在 Lofter 上关注我的人在前八个月里，从 0 增加到了 80，也就是平均一个月 10 个人，3 天 1 个人。变化发生在第十个月，可能因为持续的书评输出，我的博客在『读书』这个分类里成了『资深』，慢慢开始有人转有人评有人推荐，粉丝这才多了起来。又一年过去了，粉丝大概增加到了七八千；又一年过去了，粉丝有了十多万。我时常拿这个例子暗暗鼓励自己，没有前面的坚持，是不会有后面的突变的。</p>
<p>于是这个事情在新的独立博客中又『发生』了一次。做任何事情都有一个加速的过程，总有那么一段时间是加速度很大但速度不快，看起来没前进多少，但只要能把这个加速度维持一段时间，短则数月长则数年，就会有惊人的变化。</p>
<p>从 0 到 1000000，从最初零散的博客到前段时间发布的 wdxtub.com 1.0 版本，我收获的不仅是一堆数字和一个产品，更是一套世界观和方法论。有专注于理论的『不周山』板块，有专注于实践的『通天塔』板块，有专注于生活的『好望角』板块，还有专注于打卡的『书影音』板块。当我开始琢磨怎么把一个事情做好的时候，其实就是一种快速成长。学着去合理安排时间，合理组织文字；试着去灵活表达想法，灵活展现内容。</p>
<p>这种不断升级自我认知，不断通过实践调整优化的方法论，让我往往能够更快找到问题的关键所在，并且用最合适的方式去把事情做好。更重要的是，我能够用尽可能清晰的文字来描述自己的想法，尽量避免因为沟通不到位而造成的资源浪费。</p>
<p>在这里，我必须要感谢我博客最忠实的读者 —— 爸爸妈妈，我的周记和随笔成了我们沟通的桥梁，能让你们看到我的改变，我很开心。我还要感谢关心我的朋友们，无论是留言勘误还是问题探讨，都是切磋、学习、进步的过程，很高兴能和大家一起成长。如果你也有想要写作的冲动，不要犹豫，动起来再说，没有人一开始就能做得很好，但所有人都可以通过努力不断超越过去的自己。</p>
<p>生命是一个不断展开的过程，我总觉得，对于年轻人来说，不要停下，就是给自己最好的礼物。最后，我想用四年以前第一篇书评的第一句话来结束本文：</p>
<blockquote>
<p>用这一篇读后感来作为新博客的开篇再合适不过了，新参者就是“新来的人”的意思，无论是对于这个新博客，还是之后的人生，我都是一个新参者，我也只是一个新参者，所以希望能够抱着这样的心态，来继续我前进的脚步。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然在写作上老天爷赏给我的大概是个窝窝头，但平凡的努力也可以有平凡的精彩。即使我走的不快，但只要一直在路上，就总能看到新的风景。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="积累" scheme="http://wdxtub.com/tags/%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="博客" scheme="http://wdxtub.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="访问" scheme="http://wdxtub.com/tags/%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>【决战大数据】读书笔记</title>
    <link href="http://wdxtub.com/2017/04/24/big-data-clips/"/>
    <id>http://wdxtub.com/2017/04/24/big-data-clips/</id>
    <published>2017-04-24T12:31:36.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最后提到的『闭环论』，正是我一直在追求的，不过高人这么一点拨，感觉豁然开朗。我多么希望两年前能看到这本书，这样我就可以在大把空闲时间的校园里，把 Patriots 提前做出来了。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.25: 完成初稿</li>
</ul>
<p>大数据时代，用数据找机会，用数据还原真实。从『看』到『用』，从『用』到『养』数据，只有实效的数据才是正道。</p>
<p>数据十诫</p>
<ol>
<li>好的问题，答案就在里面</li>
<li>在实践中提炼数据</li>
<li>让数据变成科技，惠及更多人</li>
<li>让数据跟着『人』走</li>
<li>木有数据质量，神马数据都是浮云</li>
<li>以『假定数据是可获取的』去思考问题</li>
<li>大数据安全，不是监管</li>
<li>利用数据拿到更有用的数据</li>
<li>建立数据的数据，才有进步</li>
<li>让人做人擅长做的事，让机器做机器擅长做的事</li>
</ol>
<p>大数据从来不是免费的午餐。大数据的来源是多种渠道的，偏倚、随机的误差总是存在。</p>
<p>断层才是大数据所面临的最严重的问题。现在，收集数据的人并不清楚未来使用数据的人要做什么，这是目前大数据的一大关键命门。</p>
<p>不只是收集数据的人不知道将来的人怎么使用数据，就连创建模型的人也不知道自己所采用的数据在未来是否稳定，而使用模型的人也不知道整个数据的来路或加工过程。</p>
<p>答案不重要，思考的角度才重要。一套巧妙的数据化思考方式，三分靠想法，七分靠实践，切勿空谈。</p>
<h2 id="大数据的本质就是还原用户的真实需求"><a href="#大数据的本质就是还原用户的真实需求" class="headerlink" title="大数据的本质就是还原用户的真实需求"></a>大数据的本质就是还原用户的真实需求</h2><p>识别，让似是而非的行为数据串联起来。企业有多大的能力去识别一个『碎片化了的个人』，将是一个巨大的考验和机会。</p>
<p>从企业价值来看，数据收集实现的是企业资源的合理分配；从客户价值来看，数据收集实现的是顾客体验的提升。</p>
<p>场景与还原并行 —— 前端还原消费者场景，后端还原业务需求。</p>
<p>数据的本质就是还原，这是收集元数据的关键方法。</p>
<p>作为一名数据分析师如果你不把自己的分析与当下结合，是没办法进步的。</p>
<p>『答案不是结果，方法才是』</p>
<h2 id="『活』的数据才是大数据"><a href="#『活』的数据才是大数据" class="headerlink" title="『活』的数据才是大数据"></a>『活』的数据才是大数据</h2><p>大数据的真正价值是将数据用于形成主动收集数据的良性循环中，以带动更多的数据进入这个自循环中，并应用于各个行业。</p>
<p>多样的自循环方式打开了大数据之门，而进入这个循环的关键就是，从解决问题出发。</p>
<p>『活』做数据收集，就是要跳出既定思维的框架，从相关联的行业和也物种去收集能够为现在所用的数据，找到能够更好地佐证企业现有业务决策和发展的数据。</p>
<p>去观察行业内对这个数据最敏感的那些人。</p>
<p>把数据激活，从静态数据变成动态数据，必须要用场景来验证，仅仅是把我们收集的数据简单堆砌在一起，是没有意义的。</p>
<p>好的分析师相当于市场解码器</p>
<h2 id="无线数据"><a href="#无线数据" class="headerlink" title="无线数据"></a>无线数据</h2><p>无线时代到来之后，一切都发生了变化。原本可以收集用户完整行为数据的网站变得不再可靠，而数据还原用户行为的方式也发生了改变。</p>
<p>保证 PC 和无线两份数据的完整，通过用户体系将两份数据关联起来，就可以在分析的时候用彼此的融合来还原用户的行为。</p>
<p>无线应当是作为一种横向的基础模型穿插于各个垂直的主题模型之中的，如果将无线作为一个独立的模型，在进行用户行为还原和用户分析的时候则会变得很困难。</p>
<p>大数据相信全量数据，而非样本；是分析得出，而不是抽样获得。</p>
<h2 id="数据分类与数据价值，什么才是你的核心数据"><a href="#数据分类与数据价值，什么才是你的核心数据" class="headerlink" title="数据分类与数据价值，什么才是你的核心数据"></a>数据分类与数据价值，什么才是你的核心数据</h2><p>从数据角度来说，估值就是通过不同的维度去思考数据的价值。只有基于对数据的分类和对数据价值的不同认识，才能去对数据做筛选。</p>
<p>数据作为一种资产，不同的数据含金量必然不同，自然就会产生不同的价值。而且，就同一组数据而言，在不同的环境下甚至会呈现出不同的价值。</p>
<p>一个好的数据从业者则必须要对各个数据的价值和稳定性洞若观火。</p>
<ol>
<li>按照是否可以再生的标准来看，可以分为不可再生数据和可再生数据。对不可再生的数据而言，已有的数据要严格保护，想要但是还没有的数据就要及早收集。对于可再生数据而言，要及早做好业务的预判和数据处理的规划，这样数据在需要的时候就能够快速地获得应用，我们把这一数据叫做数据中间层</li>
<li>按照数据所处的存储层次来看，可以分为基础层、中间层和应用层。基础层必须统一，因为这是最基本的数据，而且基本数据是原始数据。除了备份的需求外没有必要在各个场合保留多份数据。只要保证这个数据有良好的元数据管理方式，就能极大地降低成本。</li>
<li>按照数据业务归属来看，可以分为各个数据主体。</li>
<li>按照是否为隐私来区分，可以分为隐私数据和非隐私数据。拥有大数据的企业高管必须要关注数据安全。</li>
</ol>
<p>能够辨别关系、身份的数据是最重要的。这些数据应该是有多少存多少，永远不要放弃。在大数据时代，越能够还原用户真实身份和真实行为的数据，就越能够让企业在大数据竞争中保持战略优势。</p>
<ul>
<li>数据价值 1：识别与串联价值</li>
<li>数据价值 2：描述价值<ul>
<li>对于企业来说，描述价值与业务目标的实现并不呈正比关系，应该收集和业务紧密相关的数据</li>
<li>用来描述数据最好的一种方式就是分析数据的框架，即基于对数据的理解，对数据进行分类和有逻辑的展示</li>
</ul>
</li>
<li>数据价值 3：时间价值</li>
<li>数据价值 4：预测价值</li>
<li>数据价值 5：产出数据的价值<ul>
<li>很多数据本身并没有特别的含义，但是在几个数据组合在一起的或者对部分数据进行整合之后就产生了新的价值</li>
</ul>
</li>
</ul>
<p>精细的数据分类，严格的数据生产加工过程，将让我们在使用数据时受益匪浅。</p>
<h2 id="从用数据到养数据"><a href="#从用数据到养数据" class="headerlink" title="从用数据到养数据"></a>从用数据到养数据</h2><p>在收集数据时，我们必须知道这些数据未来可以用来做什么，如果今天都想象不出来的话，日后就更不可能了。</p>
<p>数据应用因小而美。『小』不是指数据量，而是指应用的目标很具体。</p>
<h3 id="如何用框架来做决策"><a href="#如何用框架来做决策" class="headerlink" title="如何用框架来做决策"></a>如何用框架来做决策</h3><p>想要解决的问题越复杂，框架也就越复杂。但是，决策最重要的前提是要从小角度切入，从『小』做起。这里有一个四步走的方法：</p>
<ol>
<li>首先确定有什么问题，从解决问题的角度出发去收集数据</li>
<li>把收集到的数据整理好，放入一个『数据框架』内。让决策者用框架更清楚地看到数据与决策之间的关系</li>
<li>看框架与做决策的关系</li>
<li>根据决策行动，然后检查行动是否达到目的（如果没有，则需要优化整个流程）</li>
</ol>
<h3 id="养数据，重要的数据战略"><a href="#养数据，重要的数据战略" class="headerlink" title="养数据，重要的数据战略"></a>养数据，重要的数据战略</h3><p>『养』数据，就是主动收集数据，是基于深入业务理解的更高层次的商业决策。</p>
<p>如果你要做一名数据分析师，脑海里就要长期装着这样一个想法『这个数据是怎么来的？』你要打破局限，不要把自己封闭在狭隘的思想中。在未来商业中，谁被逼到『或』式选择境地，往往谁吃亏（比如促销的最后一天 = 『买或不买』）</p>
<p>在面对『或』式选择的时候，我们更容易被惯性牵绊。很多时候，你需要远离『或』的概念，才不会被困住而浑然不觉。</p>
<h2 id="数据的盲点，负面数据的力量"><a href="#数据的盲点，负面数据的力量" class="headerlink" title="数据的盲点，负面数据的力量"></a>数据的盲点，负面数据的力量</h2><p>在数据中，盲点可以分为两类：一类是物理盲点，另一类是逻辑盲点。</p>
<p>面对数据的盲点，正能量思考告诉你怎么做可以到达成功的终点，负能量思考则告诉你怎么做才不会失败。</p>
<p>是否看到数据盲点价值的核心就是，有没有看到应该看到的数据，有没有错失不应该错失的数据。</p>
<p>我们观察数据的时候容易只将焦点放在正面数据上，而忽略掉负面数据。</p>
<p>错误的经验会让你不断地犯错误。</p>
<h2 id="阿里巴巴的大数据实践"><a href="#阿里巴巴的大数据实践" class="headerlink" title="阿里巴巴的大数据实践"></a>阿里巴巴的大数据实践</h2><p>从数据化运营到运营数据是不断运行的循环。在这样的循环中，会容纳许多新的、不同维度的数据，这些数据经过在整个循环中的适应过程，然后再运用到数据化运营中，并且改变原有的运营方式，这个过程就是我认为的大数据落地的方法。</p>
<p>数据化运营的的前提是假定数据是稳定的，并且以此来改变企业的运营。而运营数据，则是假定数据都是可以获取的，而且是不稳定的。</p>
<p>数据化运营需要和商业咬合得非常紧密，所以数据也是混合在商业里，以假定稳定的方法去做业务上的对比和细分及趋势预估的。假定数据是稳定的，也意味着我们习惯于不去寻找一些新数据。</p>
<p>『用数据拿数据』的方法可以将数据化运营和运营数据打通。将数据化运营和运营数据打通，有可能会创造出一些意想不到的创新。我们在大数据环境里运营数据时，有可能走不通的原因是，现在的数据已经庞大到需要管理才能到创新的数据化运营。这个循环能否成型，往往需要很长时间的努力。</p>
<p>目的和目标区别在于：『目的』是要到达的终点；而『目标』则是衡量到达终点的价值标准。</p>
<p>他很重视客服，最擅长的做法是通过客服来观测数据，通过最前端来决定后端，这就是探索。我很赞赏他说的『发现交易量急速上涨的时候，就要停掉广告』。这句话体现了他作为一名科学家的思维逻辑 —— 当交易量急速上涨时，对订单的处理能力就会下降，所以减少广告可以很好地控制局势。</p>
<p>对于创业公司来说，管理者不需要把眼光放得过于长远。如果从短期目标出发，在不断的观察之中发现问题，并且解决问题，很可能会更容易获得成功，而事实上很多人的成功就是这样造就的。</p>
<h2 id="混、通、晒，阿里巴巴数据化运营的内三板斧"><a href="#混、通、晒，阿里巴巴数据化运营的内三板斧" class="headerlink" title="混、通、晒，阿里巴巴数据化运营的内三板斧"></a>混、通、晒，阿里巴巴数据化运营的内三板斧</h2><p>只有具备商业敏感的数据分析师，才会懂得使用什么数据来驱动公司实现经营目标。数据部的人要和业务部的人经常『混』在一起。</p>
<p>如果数据分析师缺乏商业意识，那么公司就成了『盲人』——分析师不知道该使用怎样的逻辑去分析数据，而公司的决策层也得不到任何有价值的参考意见。作为数据分析师，如果不和业务部混在一起，又怎么会知道业务部在做什么。商业敏感是要靠『混』出来的，它并不会凭空出现在你面前。</p>
<p>『通』是『混、通、晒』里最关键的连接点。知道带着业务问题来看数据或者带着数据问题来看业务，这就是做到了『通』。</p>
<p>值得注意的是，『通』有两个场景。比如说，现在有一个商业场景和一堆数据，这两者产生关系时，就是商业模式和数据彼此的『通』，我们可以称它为『数据中间层』，简单来说，它就是能够敏感地反映出商业变化的数据群（Smart Data Set）</p>
<p>另外一种更深入的『通』，就是存在于公司组织中的数据。把数据打通，一是商业理解和数据之间的『通』，另一种就是部门数据和部门数据的交叉。</p>
<p>想做到数据的积累和沉淀，想要打通数据，建立合理的系统是不二之选。首先，做好数据安全工作，以保证公司内部不同职位的员工可以查看不同的数据；然后，统一不同部门的数据标准，使公司内部数据有统一的接口，避免混乱；最后，关联不同部门的数据，创造机会让数据的运营可以扩散至数据部门之外。</p>
<p>数据能不能做到在获取、使用、分享、协同、连接、组合之上让自己变得超级简单和便捷，这是数据化运营里面非常重要的一点，这也正是『晒』的内容。</p>
<p>『晒』是在『混』和『通』的基础上产生出来的最终的数据表现，是基于人、商业和数据结合后的一种看数据和用数据的方法论。通常是通过数据来回答这几个问题：</p>
<ul>
<li>业务好还是不好</li>
<li>数据如何改变可以让业务更好</li>
<li>如何利用数据帮助业务发现机会，甚至产生出新的商业价值</li>
</ul>
<p>具体应用用数据解决什么问题，要根据业务的场景来决定。</p>
<p>所谓的框架就是，对一个业务进行指标化的分解，并通过有限多个指标来客观描述业务的状况。</p>
<p>在电子商务领域，评价业务水平通常有两套指标，一套是常用的计算成交额的方法，即<strong>流量 x 转化率 x 客单价 = 成交额</strong>，它能够评价一个类目、一个商品的健康度。另外一套指标在商品大促的时候使用居多，即<strong>预热期加入购物车的商品数 x 商品单价 x 经验转化率 x 经验成交额占比 = 大促成交额</strong>（因为经验转化率和经验成交额占比通常是两个固定的数据）</p>
<p>业务需要进行比较才能判断好坏，而比较的前提就是要不断地去寻找比较对象。</p>
<p>我们到底要解决的是什么问题，我应该用什么逻辑来解决，在抛开一切杂念获得验证的思路之后，再来看细节问题决策就会显得非常简单了。其实，用逻辑来思考的问题或者发现的问题，就是一个本质问题。</p>
<h2 id="存、管、用，阿里巴巴运营数据的外三板斧"><a href="#存、管、用，阿里巴巴运营数据的外三板斧" class="headerlink" title="存、管、用，阿里巴巴运营数据的外三板斧"></a>存、管、用，阿里巴巴运营数据的外三板斧</h2><p>存，数据收集的开始。收集数据不是目的，让收集起来的数据如何产生价值才是最终的目的。</p>
<p>管，保护好存储数据。学会用数据产品来解决获取及使用数据的问题。数据管理，是大数据行业的脏活苦活累活，是最悲催和最难解决的事情。</p>
<p>用，从收集数据到管理数据。数据的分裂和重组，都能做到颠覆性创新。</p>
<h3 id="第一步-建立用户的标签"><a href="#第一步-建立用户的标签" class="headerlink" title="第一步 建立用户的标签"></a>第一步 建立用户的标签</h3><ol>
<li>通过业务规则结合数据分析来建立标签</li>
<li>通过模型来建立标签</li>
<li>通过模型的组合来生成新的标签</li>
</ol>
<h3 id="第二步-标签的应用"><a href="#第二步-标签的应用" class="headerlink" title="第二步 标签的应用"></a>第二步 标签的应用</h3><p>最核心的就是数据中间层和前台业务层的对接，并且能够让运营人员非常方便地进行商品的设置。</p>
<ol>
<li>中间层和业务层的对接</li>
<li>中间层的易用性</li>
</ol>
<h3 id="解决本质问题"><a href="#解决本质问题" class="headerlink" title="解决本质问题"></a>解决本质问题</h3><p>不断地用逻辑方法将问题进行分解，直到不能分解为止，然后从根本处去解决这个问题。</p>
<p>总的来说，当我们遇到一个问题之后，一定要问自己这到底是现象还是本质，如果是现象就一定要找到本质。被表面迷惑是很多人都会犯的错误，而所谓的成功，就是少犯错误，就是早一点从本质出发去思考问题。</p>
<h2 id="大数据，未来商业的利器"><a href="#大数据，未来商业的利器" class="headerlink" title="大数据，未来商业的利器"></a>大数据，未来商业的利器</h2><p>假定数据是脏的。到底是因为数据源脏了，还是因为数据提炼过程做得不好。</p>
<p>学会慢慢淡化数据。数据是有优先级的，在数据中有些是特别核心的，有些即使缺失了也没有多大问题。所以，我们要学会真正坐下来盘点那些对公司最有价值、对用户最有价值的数据。</p>
<p>数据的标签化管理。数据的属性标签是人类经验判断的数据，是数据后的数据。</p>
<p>标签的属性管理，在运营数据中非常重要。属性管理的层级化十分有必要，但是在使用数据前，必须要了解数据的场景、数据是如何放进去的和数据的场景是什么。在这一切未知之前，就说数据如何好用的话，是不可能的。所以，现在企业运营数据的趋势是，我们应该找出一些属性进行归类，然后再慢慢地考虑如何提炼，这对于未来非常重要。</p>
<p>重要的是数据和数据之间的关系，而不是数据本身。</p>
<p>我们千万不要把所有的能力都用来处理实时化的问题，因为我们依然会有大量的数据需要在恰当的时机（Right Time）处理，有的数据是重要的，但不紧急。</p>
<p>数据处理不一定要实时，在其他数据没有到位的情况下，数据实时化的价值也不大。</p>
<p>人和机器的结合，或者人和数据的结合将是未来的一种进步模式，人类将通过数据变得更加智能。</p>
<p>经验使人变笨的原因在于你之前的经验本身就存在误差，即数据源本身就存在问题，而这种误差一般人看不出来。</p>
<p>永远不要假定这个世界是真空的，所以需要多多观察频繁出现的新数据。当有新数据出现时，以往的经验就需要重新做评估了。</p>
<h2 id="开启属于你个人的大数据管理"><a href="#开启属于你个人的大数据管理" class="headerlink" title="开启属于你个人的大数据管理"></a>开启属于你个人的大数据管理</h2><p>成功路上，有 4 种东西是可以积累的，分别是财富、人际关系、知识以及思维方式。思维方式与你所做的选择和决策密切相关，冥冥之中决定了『运』的走向。</p>
<p>要对数据做一个积累，要对我所在行业中呈现出的信息进行积累。这是一个有限时间和无限大数据进行博弈的时代。如果没有积累数据的意识，没有培养自己数据化思考的意识，改变命运真的就成为一种投机行为。</p>
<h3 id="做好个人大数据管理"><a href="#做好个人大数据管理" class="headerlink" title="做好个人大数据管理"></a>做好个人大数据管理</h3><p>早上可以用来做数据收集。要完成这个大数据积累的闭环，要求放进去的数据，一定要能够非常快速、实时地调用出来，这就需要一个非常好的分类/标签管理体系。（用两三个关键词在 10 秒内调出我积累的有效数据）</p>
<p>在我的微博关注里，按照两个维度来分类我关注的人：一是他们懂什么东西，即有什么特长；二是根据重要性，进行 5-20 分钟，或者 45 分钟关注度的划分。（如果时间不够，就只看最重要的人）</p>
<p>从收集数据的角度来看：首先，我在选择有效的数据源；其次，我有重要性的选择，所以我能很好地控制我的时间。每天我做完这些数据收集的时间大约是一个小时，时间久了，我现在对每个数据源甚至提供数据的记者的能力都了若指掌。</p>
<p>标签的生命周期。</p>
<ul>
<li>越有效的标签就越能让我快速地调取数据<ul>
<li>标签的用途多样，比如做知识分类的、识别来源的、情境和人物描述的以及表明时序的，等等</li>
</ul>
</li>
<li>要注意知识范畴的培养<ul>
<li>行业标签、技术标签、分类方法</li>
</ul>
</li>
<li>场景的标签我把它分为公司与人物，再加上时间（时间是很重要的过滤条件）</li>
</ul>
<p>时间线和来源是锁定想要数据的重要线索。</p>
<p>在大数据的世界中，没有人要求你懂得细节，没有人要求你成为一名数据分析方面的专家，但是要求在你需要拿到一个专家的数据时，能哦古快读地调用出来。做到这样的话，我们就已经突破了人类短时记忆的短板。</p>
<p>眼睛与大脑是相互影响的，而你看到的将影响你的思考，反过来你的思考方式又影响着你看到的东西。</p>
<ul>
<li>首先，你所选定的题目，一定要是你感兴趣的，或者跟你的职业相关的。</li>
<li>其次，个人大数据管理和做大数据一样，一定要从小处着眼</li>
<li>再者，就是尽量让数据的收集变得简单</li>
<li>最后，你一定要把这个『运营数据-数据化运营-运营数据』的循环打通成闭环，也要利用今天社会化的优势，学会借助别人的力量。</li>
</ul>
<p>收集、决策、行动、管理，开启你个人的大数据管理，改变自身的知识积累和思维方式，成为一个能够掌握自己未来的人。</p>
<h2 id="像李小龙的格斗一样去思考"><a href="#像李小龙的格斗一样去思考" class="headerlink" title="像李小龙的格斗一样去思考"></a>像李小龙的格斗一样去思考</h2><p>忘掉必杀技。当人人都有绝招的时候，绝招就不是绝招了。</p>
<p>在迂回中寻找落地点。</p>
<p>衡量每一个变化。在目标确定的基础上，能够对一些变化做出有效的判断。</p>
<p>衡量变动时有两个大的前提，一个前提是要保证数据是能够被有效记录下来的，另一个前提是数据是能够被有效解读的。</p>
<p>持续的反馈。思考中的稳定就来自于变化环境下的不断反馈。</p>
<p>寻找爆发点。主干，就是一件事物最原始、最核心的规律。</p>
<p>做公益，第一重要的其实不是钱。是专业、爱和用心</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后提到的『闭环论』，正是我一直在追求的，不过高人这么一点拨，感觉豁然开朗。我多么希望两年前能看到这本书，这样我就可以在大把空闲时间的校园里，把 Patriots 提前做出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="思路" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>【赤裸裸的统计学】读书笔记</title>
    <link href="http://wdxtub.com/2017/04/24/naked-statistics-clips/"/>
    <id>http://wdxtub.com/2017/04/24/naked-statistics-clips/</id>
    <published>2017-04-24T11:21:02.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>人们喜欢看到简单的答案。什么是最好的？当然是第一名。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.24: 完成初稿</li>
</ul>
<p>我们所能收集的数据以及所能进行的实验的种类总归是有限的。</p>
<p>我们运用最好的数据、理论和资源来进行统计分析，但这一过程并不等同于加法或除法，正确的技术不一定能够得到『正确的』答案，电脑也不一定比人脑更加准确和无懈可击。数据总是想要高速我们一些信息，但是面对这些信息，聪明又诚实的人经常有不同的看法。</p>
<p>如果一组数据分布中没有特别离谱的异常值，那么它们的中位数和平均数将会是差不多的。</p>
<p>将一系列复杂的信息浓缩成一个数字，我们可以因此对原先无法展开简单比较的事物进行排名，但不同的浓缩方式可能会得到不同的结果。</p>
<p>使用统计学来描述复杂现象的这一过程并不是精确无误的，这就为掩盖真相创造了大量的空间。</p>
<p>即使是最为精确和精密的描述性数据，都有可能面临一个根本性的问题：缺乏清晰度，不知道我们到底要定义、描述或解释什么。</p>
<p>在某些时候，统计学的功能仅仅是让数据看上去更顺眼。</p>
<p>人们喜欢看到简单的答案。什么是最好的？当然是第一名。</p>
<p>相关系数是很好的统计指标。</p>
<p>作为消费者，你应该知道，从长远来看，保险并不能为你省钱。从统计学的角度来看，购买保险是一项『糟糕的投资』，因为平均来看，你支付给保险公司的钱永远要比得到的赔付多。</p>
<p>常见的与概率有关的错误、误解和道德困境：</p>
<ul>
<li>想当然地认为事件之间不存在联系</li>
<li>成群病例的发生（事情有的时候真的就是这么巧）</li>
<li>检方谬误</li>
<li>回归平均数（或趋均数回归）</li>
<li>统计性歧视</li>
</ul>
<p>每一项重要的研究成果都离不开优质数据的默默支持，让分析成为可能。我们需要避免常见的偏见：</p>
<ul>
<li>选择性偏见</li>
<li>记忆性偏见</li>
<li>幸存者偏见</li>
<li>健康用户偏见</li>
</ul>
<p>中心极限定理是许多统计活动的『动力源泉』，其核心要义是，一个大型样本的正确抽样与其所代表的群体存在相似关系。一些推理：</p>
<ol>
<li>如果我们掌握了某个群体的具体信息，就能推理出从这个群体中正确抽取的随机样本的情况。</li>
<li>如果我们掌握了某个正确抽取的样本的具体信息（平均数和标准差），就呢个对其所代表的群体做出令人惊讶的正确推理。</li>
<li>如果我们掌握了某个样本的数据，以及某个群体的数据，就能推理出该样本是否就是该群体的样本之一。</li>
<li>如果我们已知两个样本的基本特性，就能推理出这两个样本是否取自同一个群体。</li>
</ol>
<p>统计推断与假设检验：并非绝对可靠的魔法，但对于认识这个世界来说，作用是巨大的。</p>
<p>回归分析能够在控制其他因素的前提下，对某个具体变量与某个特定结果之间的关系进行量化。也就是说，我们能够在保持其他变量效果不变的情况下，将某个变量的效果分离出来。</p>
<p>只有当变量之间的关系为线性时，回归分析才可派上用场。</p>
<p>在一个回归方程式中，假如两个或两个以上解释变量彼此之间高度相关，那么回归分析的结果将有可能无法分清每一个变量与因变量之间的真实关系。</p>
<p>假如变量过多，尤其当无关变量过多的时候，回归分析的结果就会被冲淡或稀释。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人们喜欢看到简单的答案。什么是最好的？当然是第一名。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="统计" scheme="http://wdxtub.com/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之团队建设】贰 远程团队项目成功指南</title>
    <link href="http://wdxtub.com/2017/04/19/babel-team-remote-project/"/>
    <id>http://wdxtub.com/2017/04/19/babel-team-remote-project/</id>
    <published>2017-04-19T12:57:38.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>分散在五个城市两个时区的远程团队，如何在两个月的时间内从零开始打造一款产品、找到客户并成功上线呢？我们用实践找到了答案，这一路走得很辛苦，但收获也很多。如果恰好你也在远程团队，恰好也有产品上线的压力，那么不妨来参考一下我们的经验。</p>
<p>注：写于 Liboost 1.0 版发布当天</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.19: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>离职之后入职之前赋闲在家的日子里，除了每天写写书稿，最让我意想不到的是我加入了一个『特殊』的团队。之所以特殊，一是实现了我从高中起的愿望（我一直想跟同学一起搞点事情），二是这个团队所做的行业是我从来没有接触过的（公益），三是以技术合伙人的身份加入的我要面对全新的挑战（真正做起来才知道做一件事情不容易，做好更不容易），四是团队成员非常分散（五个城市两个时区，大部分成员并非全职）。</p>
<p>如何在这样的条件下把事情做成，其实大家都没有把握。但是世上本没有路，摸着石头过河也就有了路。更难能可贵的是，在这样的状态下一点一点聚沙成塔，才能真正感受到万丈高楼平地起的豪情。</p>
<p><img src="/images/14926101793547.jpg" alt=""></p>
<p>如果要问我从中学到的最宝贵的经验是什么，那么一定是下面几条：</p>
<ol>
<li>有热情，有灵性，踏踏实实，想把事情做好，事情没做好就想各种办法把事情做好的人才是真正能让事情从零到壹的人。（对应后文『远程团队』一节）</li>
<li>规划和行动都要脑中有大方向，不然很容易迷失在细节中。很多时候能够分清轻重缓急，事情就已经成功了一半。（对应后文『确定方向』一节）</li>
<li>团队成员间相互信任是非常重要的，用人不疑疑人不用。只有大家朝着一个方向努力才能真正合作无间，而非各怀鬼胎相互使绊。（对应后文『高效执行』一节）</li>
<li>团队人数不宜过多，但每个人都需要能独当一面（出活）。方向选对，找准用户，力量集中，信息透明且高速流动，才能四两拨千斤。（对应后文『利器清单』一节）</li>
</ol>
<p>（赶时间的同学看到这里就足够了，不赶时间的可以具体看看每一节的说明）</p>
<h2 id="远程团队"><a href="#远程团队" class="headerlink" title="远程团队"></a>远程团队</h2><p>首先要强调的两点是：</p>
<ul>
<li>当一天和尚敲一天钟的人不适合任何需要发挥创造力的工作，最佳的归宿是在大机器里当好零件。</li>
<li>不要自己找借口和理由限制自己，世界是动态的，想要提升自己的价值，就要在学习的过程中不断产出，没有主动性的人适合去敲钟。</li>
</ul>
<p>那么具体到远程团队，如何才能合作无间，甚至比天天待在一起的团队效率更高呢？核心就两点：</p>
<ol>
<li>在意时间，珍惜时间，用好时间</li>
<li>信息透明，信息流动，产出导向</li>
</ol>
<p>把时间作为重要的资产，也就意味着每个人的时间都要尽可能高效利用，所以对于非紧急事项，一定要用被动的交流方式（比如文档），不要打断别人的工作。开会需要占据本就不多的重叠时间，所以一定要规定会议时长，提前列好议程议题，会上拿出解决方案并指派实施人。</p>
<p>努力让信息透明和流动，以工作进展作为评判标准，也就意味着团队需要培养共同的工作习惯，共享所有可能的资源，把每个人的工作进展都摆在台面，尽量少做或不做重复工作。</p>
<p>在时间、信息和产出的融合中，团队的精气神就会慢慢展现出来。这里需要注意的是，可以允许有大部分的兼职成员，但一定要有核心全职成员起到穿针引线的效果，把所有人的努力串起来，把项目向前推进。</p>
<h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>小团队最忌讳的就是想要一步登天，心急吃不了热豆腐，想要吃成胖子，饭也得一口一口吃。因为资源有限，所以如何选择目标，如何规划到达目标的路径就非常重要。</p>
<p>这里有两点需要注意，一是关注核心和不变因素，因为这部分是一定要做且是其他一切的基础，早一点做好，就有更多的时间完善；二是规划的时候最好用白板和粗一点的笔，就是要通过这种粗线条的按时来让我们的思维集中在大方向上，并且一旦确定，轻易不修改。</p>
<p>我们只制定短期和中期计划，分别对应当前版本的开发计划和下一个版本的开发计划（只维护两个版本的路线图），因为多了也没用，计划赶不上变化，两个大版本的规划，绰绰有余了。而在具体的推进过程中，不要过早关注细节，做的时候就会知道什么是重要的细节。</p>
<p>至于商业模式和商业策略，也是一开始就要考虑的，但不是说一定要具体到非常细节的程度。举个例子来说，我们不走『用免费圈用户然后再想办法变现』的路子，所以努力保持盈利是我们的目标，我们的大部分规划和策略都是基于这个大方向的，而有这么个大方向其实就够了。</p>
<p>重要的事情再说一次：确定了方向，微调可以，轻易不要大改。</p>
<h2 id="高效执行"><a href="#高效执行" class="headerlink" title="高效执行"></a>高效执行</h2><p>可能很多朋友觉得两个月的时间一点也不快，毕竟 HackerRun 之类的活动 24 小时就可以搞一个 Demo 出来。但 Demo 和实际可用的产品之间的距离绝对超乎大多数人想象，只有真正经历过的人才明白个中含义。（举个例子，类似的产品有的团队做了几年才勉强可以上线）</p>
<p>高效执行的基础就认识到通往完整产品的漫长旅程，高效执行的核心是确定方向便全力冲刺，高效执行的方式是流畅合理的工作流。这意味着：</p>
<ul>
<li>早上线，快速测试、反馈与迭代</li>
<li>不要被突如其来的『好点子』打乱部署</li>
<li>精力用在最核心的功能和模块</li>
<li>不要犹豫太久，做出决定就是取得进展</li>
<li>大项目分解成小任务，按照优先级排序</li>
<li>不要搞太多规章制度，不管黑猫白猫只要抓到老鼠就是好猫</li>
</ul>
<p>最后强调一点，沟通成本可能比看起来和想象中都要大，所以如果你坚信自己的想法没错，那么做了再说，专业人士能够为自己的决策负责，而负起责任是走上正轨的必备条件。</p>
<h2 id="利器清单"><a href="#利器清单" class="headerlink" title="利器清单"></a>利器清单</h2><p>为了配合远程团队的一整套工作流程，市面上其实已经有了各种各样的工具，我们只需要选择顺手的，努力用好即可，这里是我们所有的工具清单及简单介绍（请把广告费打到我账上 2333）：</p>
<ul>
<li>项目管理：<a href="https://www.teambition.com" target="_blank" rel="external">Teambition</a><ul>
<li>针对开发：包括但不限于当前版本/下一版本需求、开发中、测试中、已发布</li>
<li>针对团队：包括但不限于团队建设、工作流程、人才库</li>
<li>每个任务都指派到具体的人，对于可以评估时间的任务，给出截至时间</li>
</ul>
</li>
<li>协作文档：<a href="https://shimo.im/desktop" target="_blank" rel="external">石墨文档</a><ul>
<li>所有需要协同编辑的文档都会放在这里，并按照不同的文件夹进行管理</li>
<li>包括但不限于：运营相关、沟通记录、开发相关、用户访谈、归档</li>
<li>大家都可以看到彼此的工作进度，也可以直接通过评论提及团队成员</li>
</ul>
</li>
<li>服务器：<a href="https://cn.aliyun.com/" target="_blank" rel="external">阿里云</a></li>
<li>代码托管：<a href="https://github.com" target="_blank" rel="external">Github</a></li>
<li>交流讨论：微信群、电话（紧急）</li>
</ul>
<p>工具不需要太多，尽量减少学习成本，重点在于大家形成一致的工作习惯。如果大家感兴趣具体每个工具我们的使用方式，可以评论留言，我会选择进行详细说明。</p>
<h2 id="结束之前"><a href="#结束之前" class="headerlink" title="结束之前"></a>结束之前</h2><p>没有什么经验是可以照搬的，没有什么成功是可以复制的，有的是『路漫漫其修远兮，吾将上下而求索』，有的是『上士闻道，勤而行之』。</p>
<p>将来的路还很长，要勇敢地大步往前走。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分散在五个城市两个时区的远程团队，如何在两个月的时间内从零开始打造一款产品、找到客户并成功上线呢？我们用实践找到了答案，这一路走得很辛苦，但收获也很多。如果恰好你也在远程团队，恰好也有产品上线的压力，那么不妨来参考一下我们的经验。&lt;/p&gt;
&lt;p&gt;注：写于 Liboost 1.0 版发布当天&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
    
      <category term="远程" scheme="http://wdxtub.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
      <category term="项目" scheme="http://wdxtub.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="推进" scheme="http://wdxtub.com/tags/%E6%8E%A8%E8%BF%9B/"/>
    
  </entry>
  
  <entry>
    <title>拳皇 14 指南</title>
    <link href="http://wdxtub.com/2017/04/18/kof14-guide/"/>
    <id>http://wdxtub.com/2017/04/18/kof14-guide/</id>
    <published>2017-04-18T02:20:13.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>看大司马玩了这么多次拳皇，我终于也手痒了，于是趁着五折购入 PS4 版拳皇 14。这里是我的格斗笔记</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.18: 完成初稿</li>
</ul>
<h2 id="通用按键"><a href="#通用按键" class="headerlink" title="通用按键"></a>通用按键</h2><p>这部分来自游民星空</p>
<p><img src="/images/14924821818814.jpg" alt=""></p>
<p><img src="/images/14924821907475.jpg" alt=""></p>
<p><img src="/images/14924822005643.jpg" alt=""></p>
<h2 id="攻击套路"><a href="#攻击套路" class="headerlink" title="攻击套路"></a>攻击套路</h2><h3 id="普通攻击"><a href="#普通攻击" class="headerlink" title="普通攻击"></a>普通攻击</h3><p>按下拳键和脚键即可发动通常攻击。</p>
<ul>
<li>若在与对手贴近的情况下发动，攻击将会变化。</li>
</ul>
<h3 id="连击"><a href="#连击" class="headerlink" title="连击"></a>连击</h3><p>在靠近对手时连按□键，角色可以发动连击直至使出必杀技。</p>
<ul>
<li>当能量槽为1格以上时，可使用1格能量将必杀技变为超必杀技。</li>
<li>此外在极限模式中，当力量槽为1格以上时，可使用1格力量槽将必杀技变为极限超必杀技。</li>
</ul>
<h3 id="投掷与破除投掷"><a href="#投掷与破除投掷" class="headerlink" title="投掷与破除投掷"></a>投掷与破除投掷</h3><p>在对手近身区域发动投掷，可进行无法防御的投掷攻击。 </p>
<ul>
<li>部分角色可以进行空中投掷。</li>
<li>此外，在被对手投掷的瞬间，若找准时机发动投掷，则可以破除投掷。</li>
</ul>
<p>※ 必杀技的投掷无法破除。</p>
<h3 id="极限模式"><a href="#极限模式" class="headerlink" title="极限模式"></a>极限模式</h3><p>可以通过消耗1格力量槽来发动的极限模式。 </p>
<ul>
<li>在极限模式时将出现极限模式槽，槽随着时间加长而不断减少。</li>
<li>在极限模式中除了可以发动额外必杀技，还可通过消耗全部剩余极限模式槽，在能量槽不少于1格的情况下发动极限超必杀技和顶点超必杀技。</li>
</ul>
<h3 id="吹飞攻击"><a href="#吹飞攻击" class="headerlink" title="吹飞攻击"></a>吹飞攻击</h3><p>同时按下重拳键和重脚键时，可以发动吹飞攻击。</p>
<ul>
<li>在地面上出招会变为站立吹飞攻击，击中地面上的对手后，可以将对手打飞到画面的边缘。<ul>
<li>吹飞对手后，对手会进入膝盖崩溃状态，此时可以进行追击。</li>
</ul>
</li>
<li>在空中出招则使出空中吹飞攻击。<ul>
<li>此状况下不会将对手打飞到画面的边缘，但在弹反击中后可以进行追击。</li>
</ul>
</li>
</ul>
<p>※弹反击中：在对手进行攻击动作时，我方的攻击击中对手即为弹反击中（仅限部分动作）。</p>
<h3 id="必杀技"><a href="#必杀技" class="headerlink" title="必杀技"></a>必杀技</h3><p>通过方向键与键的组合（一顿乱搓），可以发动每个角色独有的必杀技。部分招数会根据轻键和重键发生性能变化。</p>
<h3 id="额外必杀技"><a href="#额外必杀技" class="headerlink" title="额外必杀技"></a>额外必杀技</h3><p>在极限模式中同时按下两个拳键或两个脚键，可以发动必杀技出招。</p>
<p>※ 根据不同的必杀技，按键也有所不同 </p>
<ul>
<li>相较于通常必杀技，为威力更大、性能更好的必杀技。 </li>
<li>只要有极限模式槽就可以无限次发动额外必杀技，但是每次发动都会消耗极限槽。</li>
</ul>
<h3 id="超必杀技"><a href="#超必杀技" class="headerlink" title="超必杀技"></a>超必杀技</h3><p>可以通过消耗1格力量槽来发动的高级必杀技。 </p>
<ul>
<li>部分招数会根据轻键和重键发生性能变化。</li>
</ul>
<h3 id="极限超必杀技"><a href="#极限超必杀技" class="headerlink" title="极限超必杀技"></a>极限超必杀技</h3><p>可以通过消耗2格力量槽来发动的高级版超必杀技。同时按下两个拳键或两个脚键，可以发动超必杀技出招。</p>
<p>※ 根据不同的超必杀技，按键也有所不同。</p>
<p>此外，在极限模式中可以变为消耗1格力量槽，但同时结束极限模式。</p>
<p>※ 在极限模式中无需同时按下2个键，就可以发动极限超必杀技。</p>
<h3 id="顶点超必杀技"><a href="#顶点超必杀技" class="headerlink" title="顶点超必杀技"></a>顶点超必杀技</h3><p>可以通过消耗3格力量槽来发动的最高级必杀技。 </p>
<ul>
<li>每个角色只携带一个，而且可以使局势瞬间逆转的王牌招式。</li>
<li>此外，在极限模式中可以变为消耗2格力量槽，但同时结束极限模式。</li>
</ul>
<h2 id="防御套路"><a href="#防御套路" class="headerlink" title="防御套路"></a>防御套路</h2><h3 id="普通防御"><a href="#普通防御" class="headerlink" title="普通防御"></a>普通防御</h3><p>按下与对手所处位置相反方向的方向键，可以防御对手的攻击。</p>
<ul>
<li>防御分为站立防御和下蹲防御，无论进行何种防御都存在无法防御的攻击。</li>
</ul>
<p>※ 遭到通常技、特殊技攻击时，进行防御可免除伤害；但遭到必杀技、超必杀技攻击时会受到削弱伤害。</p>
<p>此外，为抵御对手攻击而进行持续防御时，防御破除槽的值将减少，当值为0时，角色会进入一段时间的无防御状态，即防御破除状态。</p>
<h3 id="紧急回避"><a href="#紧急回避" class="headerlink" title="紧急回避"></a>紧急回避</h3><p>通过前转或后转的动作来回避对手的攻击。</p>
<ul>
<li>一定时间内，保持可免疫打击技和跳跃道具类招数的无敌状态，但无法避开投掷技。</li>
</ul>
<p>※ 动作结束时会露出一些破绽，因此需要特别注意。</p>
<h3 id="受身技"><a href="#受身技" class="headerlink" title="受身技"></a>受身技</h3><p>在被吹飞倒地的瞬间，若找准时机发动受身技，可避免角色长时间倒地。 </p>
<ul>
<li>存在倒地时可以进行追击的技能，所以需要伺机利用受身技回避。</li>
<li>但是，根据招数不同也存在受身技无法应对的攻击。</li>
</ul>
<h3 id="防御取消吹飞攻击"><a href="#防御取消吹飞攻击" class="headerlink" title="防御取消吹飞攻击"></a>防御取消吹飞攻击</h3><p>在防御对手攻击时使出吹飞攻击，即为防御取消吹飞攻击。</p>
<ul>
<li>虽然需要消耗1格力量槽，但在攻击中变为无敌状态，可以对对手的攻击进行反击。</li>
</ul>
<h3 id="防御取消紧急回避"><a href="#防御取消紧急回避" class="headerlink" title="防御取消紧急回避"></a>防御取消紧急回避</h3><p>在防御对手攻击时使出紧急回避，即为防御取消紧急回避。</p>
<ul>
<li>虽然需要消耗1格力量槽，但在攻击中变为无敌状态，且动作结束时无破绽，所以是进行反击的有利时机。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.gamersky.com/handbook/201608/796619_2.shtml" target="_blank" rel="external">《拳皇14》图文攻略 操作及玩法图文攻略</a>\</li>
<li><a href="http://www.gamersky.com/handbook/201607/779668.shtml" target="_blank" rel="external">《拳皇14》角色出招表及背景资料一览</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看大司马玩了这么多次拳皇，我终于也手痒了，于是趁着五折购入 PS4 版拳皇 14。这里是我的格斗笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
    
      <category term="格斗" scheme="http://wdxtub.com/tags/%E6%A0%BC%E6%96%97/"/>
    
      <category term="PS4" scheme="http://wdxtub.com/tags/PS4/"/>
    
  </entry>
  
  <entry>
    <title>淘宝美食地图</title>
    <link href="http://wdxtub.com/2017/04/05/taobao-food-map/"/>
    <id>http://wdxtub.com/2017/04/05/taobao-food-map/</id>
    <published>2017-04-05T08:17:03.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下可以淘宝到的好吃的（搜索关键词），非常适合『按图索骥』，品位比较个人化。长期更新中</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.04.05: 完成初稿</li>
</ul>
<h2 id="肉类"><a href="#肉类" class="headerlink" title="肉类"></a>肉类</h2><ul>
<li>高坑牛肉干</li>
<li>广达香肉脯松</li>
<li>姚记肚包肉</li>
<li>水一方现烤辣味鱿鱼丝</li>
</ul>
<h2 id="调味"><a href="#调味" class="headerlink" title="调味"></a>调味</h2><ul>
<li>仲景香菇酱</li>
<li>小康牛肉酱 </li>
<li>和富堂本家 2013 咸菜</li>
<li>金兰酱油</li>
<li>金兰 拌饭拌面酱</li>
<li>金兰 脆瓜</li>
<li>沫沫辣酱</li>
</ul>
<h2 id="主食"><a href="#主食" class="headerlink" title="主食"></a>主食</h2><ul>
<li>有机大米</li>
<li>四川烟熏五香小豆干</li>
<li>大溪豆干原味大板条</li>
<li>朝日有机红薯干天然无添加 甜度高</li>
<li>菲律宾宿雾芒果干</li>
</ul>
<h2 id="甜品"><a href="#甜品" class="headerlink" title="甜品"></a>甜品</h2><ul>
<li>tokyo banana原味香蕉蛋糕</li>
<li>蜜兰诺松塔千层酥饼干曲奇</li>
<li>北海道白色恋人巧克力饼干</li>
<li>北海道ROYCE原味牛奶生巧克力</li>
<li>纳宝帝奶酪芝士威化饼</li>
</ul>
<h2 id="店铺"><a href="#店铺" class="headerlink" title="店铺"></a>店铺</h2><ul>
<li>清之坊天猫旗舰店</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.zhihu.com/question/20958648" target="_blank" rel="external">淘宝上有哪些网购美食</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下可以淘宝到的好吃的（搜索关键词），非常适合『按图索骥』，品位比较个人化。长期更新中&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="淘宝" scheme="http://wdxtub.com/tags/%E6%B7%98%E5%AE%9D/"/>
    
      <category term="零食" scheme="http://wdxtub.com/tags/%E9%9B%B6%E9%A3%9F/"/>
    
  </entry>
  
</feed>
