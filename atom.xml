<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2017-07-15T01:02:52.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第五十七周 - 将进酒</title>
    <link href="http://wdxtub.com/2017/07/14/lets-drink-wine/"/>
    <id>http://wdxtub.com/2017/07/14/lets-drink-wine/</id>
    <published>2017-07-14T15:00:07.000Z</published>
    <updated>2017-07-15T01:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>君不见黄河之水天上来，奔流到海不复回。</p>
<a id="more"></a>
<hr>
<p>连绵的雨天终于有了要结束的迹象，炎炎夏日重新成为了生活的背景板，早点起床早点上班不但能躲烈日还能早点下班回家吃饭，怎么看都是一个好习惯。结束了上周的高强度工作，这周的工作更多回归到了我的主线任务 - 深度学习平台。在不断的迭代开发中，慢慢意识到最适合公司发展的系统，才是最好的。从最简单的做起，不搞太多花里胡哨的，大巧不工，大智若愚。</p>
<p>自从开发了电饭煲的『煮粥』功能，喝粥就成了我最新的快速填饱肚子兼食疗的方法。半杯米，两三把绿豆，一两把薏仁，煮上三四个小时，那就是一锅清凉去火的绿豆粥了。早上煲好，中午晚上都不会饿肚子，除了时不时想吃肉之外，其他都很好。不油腻，简简单单清清淡淡，给身体的负担没那么重，就很舒服。</p>
<p>几个月前，我之前用的多说评论系统宣布停止服务，于是我换成了网易云跟帖，而现在网易云跟帖也要停止服务了，我还能怎么办呢？数字时代的生存法则和现实生活有很大的不同，那些无形的数据资产，很可能因为服务提供方的一个决策而成为空中楼阁，给我的生活和工作流程带来很大的影响。</p>
<p>既然别人的服务靠不住，那我就自己搞吧！于是轰轰烈烈的博客搬迁升级计划悄然展开。梳理了自己生活工作流程中的痛点时发现，有技术有心情的人可以自己折腾（自建服务器并搭建专属服务）；没有技术也没有心情的人最好直接付费（省心省力）；如果不想付费，要么就得忍受广告，要么就是拿自己的数据资产不当回事儿。</p>
<p>博客搬迁的基础准备工作（云主机、域名和博客平台）基本已经完成。经过几番权衡比较，主机我选择了阿里云，博客平台我选用了 <a href="http://typecho.org/" target="_blank" rel="external">Typecho</a>（再也不用操心评论系统啦）。自建网站少不了备案，好在阿里云的备案流程还算简单，就是消耗点时间罢了。至于博客的重构计划，主要是针对原来博客中多而杂的内容。具体的组织形式会以系列的方式分不同维度进行划分：</p>
<ul>
<li>按照领域分类<ul>
<li>机器学习（深度学习/数据挖掘）</li>
<li>云计算（框架、架构）</li>
<li>计算机科学（CSAPP，算法，数据结构）</li>
<li>无人机</li>
</ul>
</li>
<li>按照目的分类<ul>
<li>求职</li>
<li>团队建设</li>
</ul>
</li>
<li>按照项目分类<ul>
<li>Patriots</li>
<li>日志分析平台</li>
</ul>
</li>
<li>按照系列分类<ul>
<li>朝花夕拾（周记和回忆）</li>
<li>试说新屿（原来的所有效率类和乐活类文章会合并到这里，包括爱好、摄影、阅读、写作）。需要严格限制文章的篇数，一篇就讲清楚一个完整的事情。按章节分，不超过十二章（十二生肖作为章节名）</li>
</ul>
</li>
</ul>
<p>除了博客外，因为自己有了服务器，就顺带搭建了一个私有云笔记（使用 <a href="https://www.leanote.com/" target="_blank" rel="external">Leanote</a>），自建虽然不如云服务稳定，但至少数据比较安全，也算是一个备份。而原来的 MWeb + 文件同步流程因为 iCloud 的不给力和 Dropbox 的被墙而难以为继，所以已有 MWeb 更多会专注于本地的文档（比如技术积累和 Kindle 书摘），而 Leanote 则会接管我的日常笔记（可以方便同步查看）</p>
<p>新老博客预计会并轨运行一段时间，后面 wdxtub.com 就会成为一个备份，大部分内容会转移到新的博客去。这么一想，整理房间，整理文件，整理思路，整理生活的思路都是一样的，持续断舍离，持续继承，持续交付。运用奥卡姆剃刀原理，如无必要勿增实体，还是要走极简风格。</p>
<p>因为子妍有几天要加班，所以这周尝试了新的交通工具 - 单车。好久没有骑车走八九公里的路了，但是这种在路上的心情，这种想要相见的心情确实让每次一踩踏板都更有力了一些。生活中感情上最重要的就是螺旋式良性循环，因为只有这样才能每天都快快乐乐的。但更重要的是维持良性循环的两个人，在偏离轨道后能快速纠正，而不是放任不理鸵鸟心态。很多问题，如果忘了我而记起我们，就不再是问题；很多困难，如果坚定我们而放下我，就不再是困难。希望我们能继续坚持和发扬优良品质，早睡早起，严肃活泼，积极向上，争取更大的胜利。</p>
<p>天生我材必有用，古来圣贤皆寂寞，将进酒，杯莫停。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;君不见黄河之水天上来，奔流到海不复回。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>语音识别动手玩</title>
    <link href="http://wdxtub.com/2017/07/10/hands-on-speech-recognition/"/>
    <id>http://wdxtub.com/2017/07/10/hands-on-speech-recognition/</id>
    <published>2017-07-10T09:28:08.000Z</published>
    <updated>2017-07-11T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>上周因为工作需要，用 HTML5 + Go 搭了一个简单的语音识别评测的 demo，用户可以直接打开网页 -&gt; 说一句话 -&gt; 查看来自不同服务提供商的语音识别结果（目前是科大讯飞、腾讯 AI 加速器和百度语音三家）。因为之前的项目很少直接跟硬件打交道，所以这次依然是摸着石头过河。好在之前有做过语音识别的项目，所以基本的概念还是懂的（因为涉及到数据格式，不懂的话即使看代码也容易云里雾里）。</p>
<p>俗话说的好，授人以鱼不如授人以渔，这个小项目的代码固然不多，但如何一个人把项目做好可能比源代码本身更重要，所以更多会记录整个项目是如何开展的过程（以及我的思考和选择）。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编码之前的准备工作有很多，从需求分析、技术调研到技术选型，每一步都走好了，项目才能顺利。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在领到一个新任务之后，最重要的工作不是动手，而是弄清楚到底需要做什么。为什么这么说？因为很多时候老大们只是有一个想法想要验证，并不会有一个很清晰的图景，这就需要我们主动沟通，去和老大们一起弄清楚到底需要做一个什么东西，然后才是具体技术方案的选择。</p>
<p>经过和老大的沟通，确定了是要做一个大家都方便访问的评测不同语音识别服务提供商的 demo，老大倾向于做一个页面，只要有浏览器和麦克风就可以体验，至于交互这些只要达到能用的平均线即可。</p>
<h3 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h3><p>因为需要依赖第三方的服务，所以首先要弄清楚第三方提供了什么服务，尤其是具体的接入方式需要特别注意。经过一番搜索和阅读，我得到了下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">提供商\SDK平台</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">android</th>
<th style="text-align:center">Linux(c)</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">REST API</th>
<th style="text-align:center">Windows</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">百度</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">科大</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">腾讯</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
</tbody>
</table>
<p>对应的文档在 </p>
<ul>
<li><a href="http://yuyin.baidu.com/docs" target="_blank" rel="external">百度语音</a> - <a href="http://ai.baidu.com/docs#/ASR-Android-SDK/top" target="_blank" rel="external">文档1</a> <a href="http://yuyin.baidu.com/docs/asr/166" target="_blank" rel="external">文档2</a></li>
<li><a href="http://www.xfyun.cn/services/voicedictation" target="_blank" rel="external">科大讯飞</a> - <a href="http://doc.xfyun.cn/msc_linux/290898" target="_blank" rel="external">Linux 文档</a></li>
<li><a href="http://ai.qq.com/" target="_blank" rel="external">腾讯 AI 加速器</a></li>
</ul>
<p>支持的格式</p>
<ul>
<li>百度 Rest API: 原始 PCM 的录音参数必须符合 8k/16k 采样率、16bit 位深、单声道，支持的压缩格式有：pcm（不压缩）、wav（不压缩，pcm编码）、amr（压缩格式）</li>
<li>腾讯 Rest API: 必须符合16k采样率、16bit采样位数、单声道，语音格式    PCM、WAV、AMR、 SILK</li>
<li>讯飞 SDK: 采样率16KHZ或者8KHZ，单声道，采样精度16bit的PCM或者WAV格式的音频</li>
</ul>
<p>在调研到这些信息之后，我们就可以轻松做出技术选型了。</p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>首先的考虑因素是快速出成果，所以能用 Restful API 就尽量用（毕竟直接对好接口即可）。但是讯飞在这个方面非常不友好，只提供了 Linux C 和 Java 的 SDK，所以得另外想办法处理讯飞这个问题。</p>
<p>注：最快的方法其实是用 android 或 iOS 的 SDK，集成到项目中直接用即可，但因为前面老大已经要求要用 html 方案，因此这些不予考虑（除非 html 做不出来，才弄其他方案）</p>
<p>因为讯飞只提供了 Linux C 的 SDK(Java 我是不太想用的)，所以得想个办法集成到后端(Go)，正当我一筹莫展之际，一个名为 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts</a> 的项目进入了我的眼帘（科大讯飞语音linux在线语音合成后台服务），虽然并不是使用讯飞的语音识别而是语音合成功能，但证明了用 Go 封装讯飞的 C SDK 是可能的。于是我赶紧看了一波代码，并很快完成了用 Go 封装的讯飞语音识别 SDK（也算是给讯飞做了一点微小的工作）。</p>
<p>好，那么现在问题解决，前端 html5 + js，后端 Go + Go 封装的 C SDK，直接在之前为公司开发的深度学习平台上开一个接口即可。</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>准备工作的最后一步就是到各家的开放平台上创建应用，得到我们调用 API 或 SDK 的凭证。百度语音的最好申请，腾讯 AI 加速器的需要申请内测（我们公司有合作所以不用申请），讯飞的需要审核（不然每天只有 500 次）。</p>
<p>创建完成之后把各家的 App ID/APP Key 之类的信息记录下来，后面需要用。</p>
<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>之所以要后端，是因为前端 JS 发请求会遇到跨域的问题，另外后端处理我也更加熟悉（事实证明离开了后端还真不行）</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分的难点在于如何通过浏览器调用麦克风，尤其是在 Chrome 上，要求全程 HTTPS 加密（当然也有另外的办法就是本地打开）。那用其他浏览器可不可以呢？可以！比如 Firefox，但是感觉 Firefox 对 Mac 的麦克风支持的一般，经常出现问题，所以我一直都是用 Chrome 在测试的。</p>
<p>因为毕竟前端写得少，大部分代码都是参照 <a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a> 这篇博客写的。主要是两个文件 <code>index.html</code> 和 <code>recorder.js</code>，接下来分别说明一下。</p>
<p>先说 <code>index.html</code> 的部分，代码不长，主要做的事情就是申请麦克风访问，然后给按钮添加动作，最后就是用 audio 控件来播放音频了。audio 控件还是比较好用的，给出音源地址即可，播放和音量都自带，很省心。我还加了个日志区域方便调试，其他的没什么难度，在此略去不表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>语音识别评测 Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>追一语音识别评测 Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>评测科大讯飞、百度语音与腾讯 AI 加速器的语音识别接口<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>由于 Chrome47 以上以及 QQ 浏览器需要 HTTPS 的支持，请更换至 360、FireFox、Edge 进行体验<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另：IE 和 Safari 全版本不支持录音功能<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span>&gt;</span>录音<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"stop"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span> <span class="attr">disabled</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--&lt;button id="upload" class="ui-btn ui-btn-primary" disabled&gt;上传&lt;/button&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"audio-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>操作日志<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/recorder.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">        function __log(e, data) &#123;</div><div class="line">            log.innerHTML += "\n" + getNowFormatDate() + " " + e + " " + (data || '');</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        function getNowFormatDate() &#123;</div><div class="line">            var date = new Date();</div><div class="line">            var seperator1 = "/";</div><div class="line">            var seperator2 = ":";</div><div class="line">            var month = date.getMonth() + 1;</div><div class="line">            var strDate = date.getDate();</div><div class="line">            if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;</div><div class="line">                month = "0" + month;</div><div class="line">            &#125;</div><div class="line">            if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;</div><div class="line">                strDate = "0" + strDate;</div><div class="line">            &#125;</div><div class="line">            var hours = date.getHours()</div><div class="line">            if (hours &lt; 10) &#123;</div><div class="line">                hours = "0" + hours</div><div class="line">            &#125;</div><div class="line">            var minutes = date.getMinutes()</div><div class="line">            if (minutes &lt; 10) &#123;</div><div class="line">                minutes = "0" + minutes</div><div class="line">            &#125;</div><div class="line">            var seconds = date.getSeconds()</div><div class="line">            if (seconds &lt; 10) &#123;</div><div class="line">                seconds = "0" + seconds</div><div class="line">            &#125;</div><div class="line">            var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate +</div><div class="line">                "-" + hours + seperator2 + minutes + seperator2 + seconds;</div><div class="line">            return currentdate;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        window.onload = function() &#123;</div><div class="line">            var start = document.querySelector('#start');</div><div class="line">            var stop = document.querySelector('#stop');</div><div class="line">            //var upload = document.querySelector('#upload');</div><div class="line">            var download = document.querySelector('#download');</div><div class="line">            var container = document.querySelector('#audio-container');</div><div class="line">            var recorder;</div><div class="line"></div><div class="line">            HZRecorder.get(function(rec) &#123;</div><div class="line">                recorder = rec;</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            start.addEventListener('click', function() &#123;</div><div class="line">                __log("开始录音")</div><div class="line">                this.disabled = true;</div><div class="line">                stop.disabled = false;</div><div class="line">                //upload.disabled = true;</div><div class="line">                var audio = document.querySelectorAll('audio');</div><div class="line">                for (var i = 0; i &lt; audio.length; i++) &#123;</div><div class="line">                    if (!audio[i].paused) &#123;</div><div class="line">                        audio[i].pause();</div><div class="line">                    &#125;</div><div class="line">                    container.removeChild(audio[i]) // 移除之前的录音</div><div class="line">                &#125;</div><div class="line">                recorder.start();</div><div class="line">            &#125;);</div><div class="line">            stop.addEventListener('click', function() &#123;</div><div class="line">                this.disabled = true;</div><div class="line">                start.disabled = false;</div><div class="line">                //upload.disabled = false;</div><div class="line">                recorder.stop();</div><div class="line"></div><div class="line">                var audio = document.createElement('audio');</div><div class="line">                recorder.play(audio)</div><div class="line">                container.appendChild(audio);</div><div class="line"></div><div class="line">                // 下载音频文件</div><div class="line">                // var link = window.document.createElement('a');</div><div class="line">                // var link = document.createElement('a');</div><div class="line">                // link.href = audio.src;</div><div class="line">                // link.download = 'output.wav';</div><div class="line">                // link.click();</div><div class="line"></div><div class="line">                recorder.upload("http://127.0.0.1:8778/v1/api/qq/voice_recog", function(state, e) &#123;</div><div class="line">                    switch (state) &#123;</div><div class="line">                        case 'uploading':</div><div class="line">                            __log("上传中，会在后端进行转码与识别");</div><div class="line">                            break;</div><div class="line">                        case 'ok':</div><div class="line">                            //__log("上传成功");</div><div class="line">                            break;</div><div class="line">                        case 'error':</div><div class="line">                            __log("上传失败");</div><div class="line">                            break;</div><div class="line">                        case 'cancel':</div><div class="line">                            __log("上传被取消");</div><div class="line">                            break;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">            &#125;);</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是 <code>recorder.js</code>（基本是照抄上面提到的原博客），主要做的工作就是处理浏览器采集到的音频信号，编码成 wav。注意这里没有更改采样率（采用默认的 44100），因为直接截取的话音调会有变化，导致识别结果较差。但其他的部分都尽量按照前面提到的标准来弄，即 16 位采样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</div><div class="line">    <span class="comment">//兼容</span></div><div class="line">    <span class="built_in">window</span>.URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</div><div class="line">    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> HZRecorder = <span class="function"><span class="keyword">function</span>(<span class="params">stream, config</span>) </span>&#123;</div><div class="line">        config = config || &#123;&#125;;</div><div class="line">        config.sampleBits = config.sampleBits || <span class="number">16</span>; <span class="comment">//采样数位 8, 16</span></div><div class="line">        config.sampleRate = config.sampleRate || <span class="number">44100</span>; <span class="comment">//采样率 16000（会变慢）</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">new</span>(<span class="built_in">window</span>.webkitAudioContext || <span class="built_in">window</span>.AudioContext)();</div><div class="line">        <span class="keyword">var</span> audioInput = context.createMediaStreamSource(stream);</div><div class="line">        <span class="keyword">var</span> createScript = context.createScriptProcessor || context.createJavaScriptNode;</div><div class="line">        <span class="keyword">var</span> recorder = createScript.apply(context, [<span class="number">4096</span>, <span class="number">1</span>, <span class="number">1</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> audioData = &#123;</div><div class="line">            <span class="attr">size</span>: <span class="number">0</span>, <span class="comment">//录音文件长度</span></div><div class="line">            buffer: [], <span class="comment">//录音缓存</span></div><div class="line">            inputSampleRate: context.sampleRate, <span class="comment">//输入采样率</span></div><div class="line">            inputSampleBits: <span class="number">16</span>, <span class="comment">//输入采样数位 8, 16</span></div><div class="line">            outputSampleRate: config.sampleRate, <span class="comment">//输出采样率</span></div><div class="line">            oututSampleBits: config.sampleBits, <span class="comment">//输出采样数位 8, 16</span></div><div class="line">            input: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.buffer.push(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(data));</div><div class="line">                <span class="keyword">this</span>.size += data.length;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">compress</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//合并压缩</span></div><div class="line">                <span class="comment">//合并</span></div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="keyword">this</span>.size);</div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.buffer.length; i++) &#123;</div><div class="line">                    data.set(<span class="keyword">this</span>.buffer[i], offset);</div><div class="line">                    offset += <span class="keyword">this</span>.buffer[i].length;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//压缩</span></div><div class="line">                <span class="keyword">var</span> compression = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputSampleRate / <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> length = data.length / compression;</div><div class="line">                <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(length);</div><div class="line">                <span class="keyword">var</span> index = <span class="number">0</span>,</div><div class="line">                    j = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (index &lt; length) &#123;</div><div class="line">                    result[index] = data[j];</div><div class="line">                    j += compression;</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">encodeWAV</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> sampleRate = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleRate, <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> sampleBits = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleBits, <span class="keyword">this</span>.oututSampleBits);</div><div class="line">                <span class="keyword">var</span> bytes = <span class="keyword">this</span>.compress();</div><div class="line">                <span class="keyword">var</span> dataLength = bytes.length * (sampleBits / <span class="number">8</span>);</div><div class="line">                <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">44</span> + dataLength);</div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">                <span class="keyword">var</span> channelCount = <span class="number">1</span>; <span class="comment">//单声道</span></div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">var</span> writeString = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">                        data.setUint8(offset + i, str.charCodeAt(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 资源交换文件标识符 </span></div><div class="line">                writeString(<span class="string">'RIFF'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 下个地址开始到文件尾总字节数,即文件大小-8 </span></div><div class="line">                data.setUint32(offset, <span class="number">36</span> + dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// WAV文件标志</span></div><div class="line">                writeString(<span class="string">'WAVE'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形格式标志 </span></div><div class="line">                writeString(<span class="string">'fmt '</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 过滤字节,一般为 0x10 = 16 </span></div><div class="line">                data.setUint32(offset, <span class="number">16</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 格式类别 (PCM形式采样数据) </span></div><div class="line">                data.setUint16(offset, <span class="number">1</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 通道数 </span></div><div class="line">                data.setUint16(offset, channelCount, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 采样率,每秒样本数,表示每个通道的播放速度 </span></div><div class="line">                data.setUint32(offset, sampleRate, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8 </span></div><div class="line">                data.setUint32(offset, channelCount * sampleRate * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8 </span></div><div class="line">                data.setUint16(offset, channelCount * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 每样本数据位数 </span></div><div class="line">                data.setUint16(offset, sampleBits, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 数据标识符 </span></div><div class="line">                writeString(<span class="string">'data'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 采样数据总数,即数据总大小-44 </span></div><div class="line">                data.setUint32(offset, dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 写入采样数据 </span></div><div class="line">                <span class="keyword">if</span> (sampleBits === <span class="number">8</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset++) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        <span class="keyword">var</span> val = s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>;</div><div class="line">                        val = <span class="built_in">parseInt</span>(<span class="number">255</span> / (<span class="number">65535</span> / (val + <span class="number">32768</span>)));</div><div class="line">                        data.setInt8(offset, val, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset += <span class="number">2</span>) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        data.setInt16(offset, s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Blob([data], &#123; <span class="attr">type</span>: <span class="string">'audio/wav'</span> &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">//开始录音</span></div><div class="line">        <span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 需要先清理 buffer</span></div><div class="line">            audioData.size = <span class="number">0</span>;</div><div class="line">            audioData.buffer = [];</div><div class="line">            audioInput.connect(recorder);</div><div class="line">            recorder.connect(context.destination);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//停止</span></div><div class="line">        <span class="keyword">this</span>.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            recorder.disconnect();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取音频文件</span></div><div class="line">        <span class="keyword">this</span>.getBlob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.stop();</div><div class="line">            <span class="keyword">return</span> audioData.encodeWAV();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回放</span></div><div class="line">        <span class="keyword">this</span>.play = <span class="function"><span class="keyword">function</span>(<span class="params">audio</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> blob = <span class="keyword">this</span>.getBlob()</div><div class="line">            audio.src = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">            __log(<span class="string">"录音结束，Wav 大小: "</span> + blob.size + <span class="string">"B Wav 地址: "</span> + audio.src)</div><div class="line">            audio.controls = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//上传</span></div><div class="line">        <span class="keyword">this</span>.upload = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();</div><div class="line">            fd.append(<span class="string">"audioData"</span>, <span class="keyword">this</span>.getBlob());</div><div class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line"></div><div class="line">                    __log(xhr.responseText)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (callback) &#123;</div><div class="line">                xhr.upload.addEventListener(<span class="string">"progress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'uploading'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'ok'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'error'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"abort"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'cancel'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">            xhr.open(<span class="string">"POST"</span>, url);</div><div class="line">            xhr.send(fd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//音频采集</span></div><div class="line">        recorder.onaudioprocess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            audioData.input(e.inputBuffer.getChannelData(<span class="number">0</span>));</div><div class="line">            <span class="comment">//record(e.inputBuffer.getChannelData(0));</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//抛出异常</span></div><div class="line">    HZRecorder.throwError = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">            alert(message);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> message; &#125; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是否支持录音</span></div><div class="line">    HZRecorder.canRecording = (navigator.getUserMedia != <span class="literal">null</span>);</div><div class="line">    <span class="comment">//获取录音机</span></div><div class="line">    HZRecorder.get = <span class="function"><span class="keyword">function</span>(<span class="params">callback, config</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (callback) &#123;</div><div class="line">            <span class="keyword">if</span> (navigator.getUserMedia) &#123;</div><div class="line">                navigator.getUserMedia(&#123; <span class="attr">audio</span>: <span class="literal">true</span> &#125; <span class="comment">//只启用音频</span></div><div class="line">                    ,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</div><div class="line">                        <span class="keyword">var</span> rec = <span class="keyword">new</span> HZRecorder(stream, config);</div><div class="line">                        callback(rec);</div><div class="line">                    &#125;,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">                        <span class="keyword">switch</span> (error.code || error.name) &#123;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PERMISSION_DENIED'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PermissionDeniedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'用户拒绝提供信息。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NOT_SUPPORTED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NotSupportedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'浏览器不支持硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MANDATORY_UNSATISFIED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MandatoryUnsatisfiedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法发现指定的硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">default</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法打开麦克风。异常信息:'</span> + (error.code || error.name));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                HZRecorder.throwErr(<span class="string">'当前浏览器不支持录音功能。'</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">window</span>.HZRecorder = HZRecorder;</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>至此，前端的工作就告一段落，主要工作就是录音，并把 44100Hz 16bit 的 wav 文件上传到后端，并等待后端返回语音识别结果。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>虽然前端做的工作不多，但其实后端要做的也不多，毕竟是调用别人的接口嘛，要再这么麻烦就没有人用啦。所以后端要做的工作主要分两个部分，对于有 Restful API 的服务来说，就是准备数据，对于只有 Linux C SDK 的服务来说，就是用 Go 去调用 C SDK，接下来我们先讲讲共用的部分，然后分别说说不同服务需要注意的地方。</p>
<p>共用的部分就是改变录音的采样率，前面提到浏览器默认的采样率是 44100Hz，我们需要转变成 16000Hz 的，考虑到 44100 并不能整除 16000，所以简单的采样一定会导致频率的变化，但是不用紧张，我们还有两大法宝 <code>ffmpeg</code> 和 <code>sox</code>。转码的命令也很简单，以下两个任选一个即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ffmpeg -i input.wav -ar 16000 output.wav</div><div class="line"><span class="comment"># or</span></div><div class="line">sox input.wav -r 16000 output.wav</div></pre></td></tr></table></figure>
<p>然后我们就要以转码后的 <code>output.wav</code> 为基础，进行下面的操作了。使用 Restful API 需要注意的就是不同平台有不同的加密、验证方式和不同的参数，但无论如何音频文件需要用 Base64 编码，然后只要写一个通用的工具方法即可，这里不多说，主要还是说一下如何去用 Go 调用 C SDK（主要参考的是 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a> 的代码）。</p>
<p>首先就是从讯飞的语音云平台上下载 SDK，然后把 SDK 内的文件放到一个名为 <code>xf</code> 的文件夹中，就叫做 <code>package xf</code> 好了。目录大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">├── README.md</div><div class="line">├── include</div><div class="line">│   ├── convert.h</div><div class="line">│   ├── msp_cmn.h</div><div class="line">│   ├── msp_errors.h</div><div class="line">│   ├── msp_types.h</div><div class="line">│   ├── qise.h</div><div class="line">│   ├── qisr.h</div><div class="line">│   └── qtts.h</div><div class="line">├── libs</div><div class="line">│   ├── x64</div><div class="line">│   │   └── libmsc.so</div><div class="line">│   └── x86</div><div class="line">│       └── libmsc.so</div><div class="line">└── xf.go</div></pre></td></tr></table></figure>
<p>着重讲两个文件，一个是 <code>xf.go</code>（相当于是 C SDK 的 Wrapper），另一个是 <code>convert.h</code>（是参照讯飞的官方例子改的）。我们先来看看 <code>convert.h</code>，实际上就是用 C 来完成语音识别的调用（代码略长，感兴趣的同学估计得慢慢理解）。留意一下 <code>run_iat</code> 这个核心函数的返回值 <code>char *</code>，后面在 <code>xf.go</code> 中有用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qisr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_cmn.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_errors.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFER_SIZE	4096</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_LEN	640 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HINTS_SIZE  100</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">run_iat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* audio_file)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* session_begin_params	=	<span class="string">"sub = iat, domain = iat, language = zh_cn, accent = mandarin, sample_rate = 16000, result_type = plain, result_encoding = utf8"</span>;</div><div class="line">    <span class="keyword">char</span> *retstr = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*		session_id					=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>			rec_result[BUFFER_SIZE]		=	&#123;<span class="string">'\0'</span>&#125;;	</div><div class="line">	<span class="keyword">char</span>			hints[HINTS_SIZE]			=	&#123;<span class="string">'\0'</span>&#125;; <span class="comment">//hints为结束本次会话的原因描述，由用户自定义</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	total_len					=	<span class="number">0</span>; </div><div class="line">	<span class="keyword">int</span>				aud_stat					=	MSP_AUDIO_SAMPLE_CONTINUE ;		<span class="comment">//音频状态</span></div><div class="line">	<span class="keyword">int</span>				ep_stat						=	MSP_EP_LOOKING_FOR_SPEECH;		<span class="comment">//端点检测</span></div><div class="line">	<span class="keyword">int</span>				rec_stat					=	MSP_REC_STATUS_SUCCESS ;			<span class="comment">//识别状态</span></div><div class="line">	<span class="keyword">int</span>				errcode						=	MSP_SUCCESS ;</div><div class="line"></div><div class="line">	FILE*			f_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>*			p_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_count					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_size					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			read_size					=	<span class="number">0</span>;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == audio_file)</div><div class="line">    &#123;</div><div class="line">        retstr = <span class="string">"[Error] 文件名为空"</span>;</div><div class="line">        <span class="keyword">goto</span> iat_exit;</div><div class="line">    &#125;</div><div class="line">		</div><div class="line"></div><div class="line">	f_pcm = fopen(audio_file, <span class="string">"rb"</span>);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == f_pcm) </div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 打开音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nopen [%s] failed! \n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_END);</div><div class="line">	pcm_size = ftell(f_pcm); <span class="comment">//获取音频文件大小 </span></div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_SET);		</div><div class="line"></div><div class="line">	p_pcm = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pcm_size);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == p_pcm)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 无法分配内存"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nout of memory! \n"</span>);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	read_size = fread((<span class="keyword">void</span> *)p_pcm, <span class="number">1</span>, pcm_size, f_pcm); <span class="comment">//读取音频文件内容</span></div><div class="line">	<span class="keyword">if</span> (read_size != pcm_size)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 读取音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nread [%s] error!\n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n开始语音听写 ...\n"</span>);</div><div class="line">	session_id = QISRSessionBegin(<span class="literal">NULL</span>, session_begin_params, &amp;errcode); <span class="comment">//听写不需要语法，第一个参数为NULL</span></div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] QISRSessionBegin 失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRSessionBegin failed! error code:%d\n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">10</span> * FRAME_LEN; <span class="comment">// 每次写入200ms音频(16k，16bit)：1帧音频20ms，10帧=200ms。16k采样率的16位音频，一帧的大小为640Byte</span></div><div class="line">		<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (pcm_size &lt; <span class="number">2</span> * len) </div><div class="line">			len = pcm_size;</div><div class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		aud_stat = MSP_AUDIO_SAMPLE_CONTINUE;</div><div class="line">		<span class="keyword">if</span> (<span class="number">0</span> == pcm_count)</div><div class="line">			aud_stat = MSP_AUDIO_SAMPLE_FIRST;</div><div class="line"></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;"</span>);</div><div class="line">		ret = QISRAudioWrite(session_id, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;p_pcm[pcm_count], len, aud_stat, &amp;ep_stat, &amp;rec_stat);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != ret)</div><div class="line">		&#123;</div><div class="line">            retstr = <span class="string">"[Error] QISRAudioWrite 失败"</span>;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d\n"</span>, ret);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">			</div><div class="line">		pcm_count += (<span class="keyword">long</span>)len;</div><div class="line">		pcm_size  -= (<span class="keyword">long</span>)len;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (MSP_REC_STATUS_SUCCESS == rec_stat) <span class="comment">//已经有部分听写结果</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">			<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">			&#123;</div><div class="line">                retstr = <span class="string">"QISRGetResult failed"</span>;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed! error code: %d\n"</span>, errcode);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">				total_len += rslt_len;</div><div class="line">				<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">					retstr = <span class="string">"[Error] Buffer 太小"</span>;</div><div class="line">                    <span class="keyword">goto</span> iat_exit;</div><div class="line">				&#125;</div><div class="line">				<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (MSP_EP_AFTER_SPEECH == ep_stat)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		usleep(<span class="number">200</span>*<span class="number">1000</span>); <span class="comment">//模拟人说话时间间隙。200ms对应10帧的音频</span></div><div class="line">	&#125;</div><div class="line">	errcode = QISRAudioWrite(session_id, <span class="literal">NULL</span>, <span class="number">0</span>, MSP_AUDIO_SAMPLE_LAST, &amp;ep_stat, &amp;rec_stat);</div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d \n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (MSP_REC_STATUS_COMPLETE != rec_stat) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed, error code: %d\n"</span>, errcode);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">			total_len += rslt_len;</div><div class="line">			<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">		&#125;</div><div class="line">		usleep(<span class="number">150</span>*<span class="number">1000</span>); <span class="comment">//防止频繁占用CPU</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n语音听写结束\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,rec_result);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line"></div><div class="line">    retstr = rec_result;</div><div class="line"></div><div class="line">iat_exit:</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != f_pcm)</div><div class="line">	&#123;</div><div class="line">		fclose(f_pcm);</div><div class="line">		f_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != p_pcm)</div><div class="line">	&#123;	<span class="built_in">free</span>(p_pcm);</div><div class="line">		p_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	QISRSessionEnd(session_id, hints);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> retstr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们来看看对 C SDK 的封装，这里采用了 cgo 的方案，具体的不展开，我们直接上 <code>xf.go</code> 的代码（很短，没想到吧，另外 <code>import &quot;C&quot;</code> 这句和上面的注释之间不能有空行）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> xf</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">#cgo CFLAGS:-g -Wall -I ./include</div><div class="line">#cgo LDFLAGS:-L./lib -lmsc -lrt -ldl -lpthread</div><div class="line"></div><div class="line">#include "convert.h"</div><div class="line"></div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	loginParams := <span class="string">"appid = your_app_id, work_dir = ."</span></div><div class="line">	ret := C.MSPLogin(<span class="literal">nil</span>, <span class="literal">nil</span>, C.CString(loginParams))</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"登录成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logout</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	ret := C.MSPLogout()</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"注销成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpeechToText</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// https://golang.org/cmd/cgo/</span></div><div class="line">	<span class="comment">// 需要在执行前 export LD_LIBRARY_PATH=/usr/local/lib</span></div><div class="line">	<span class="comment">// 如果改动了 c++ 文件，需要改动这个调用 C 的文件，才会进行重新编译，不然一直是老的</span></div><div class="line">	<span class="comment">// 官方例子中是支持 wav 的（不需要转换了）</span></div><div class="line">	<span class="comment">// ffmpeg -i output.wav -f s16be -acodec pcm_s16be output.pcm</span></div><div class="line">	fmt.Println(<span class="string">"004"</span>)</div><div class="line">	retstr := C.run_iat(C.CString(filename))</div><div class="line">	<span class="keyword">return</span> C.GoString(retstr), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 Go 的 <code>string</code> 到 C 的 <code>char*</code> 可以使用 <code>C.CString()</code>，反过来可以使用 <code>C.GoString()</code> 来转换。转换完成之后，把结果返回给前端即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像游戏评测一样，来个打分，满分十分</p>
<ul>
<li>接入方便程度<ul>
<li>腾讯: 9.0</li>
<li>百度: 8.5</li>
<li>讯飞: 5.0</li>
</ul>
</li>
<li>用户体验<ul>
<li>百度: 9.0</li>
<li>腾讯: 8.0</li>
<li>讯飞: 6.0</li>
</ul>
</li>
<li>识别效果（基于小样本的主观判断）<ul>
<li>讯飞: 8.0</li>
<li>百度: 7.5</li>
<li>腾讯: 6.0</li>
</ul>
</li>
</ul>
<p>在这里希望讯飞能够更加互联网/接地气一些，不然用起来真的挺麻烦的（不知道大客户是不是有其他待遇）</p>
<h2 id="附录-音频格式知识"><a href="#附录-音频格式知识" class="headerlink" title="附录: 音频格式知识"></a>附录: 音频格式知识</h2><p>WAV：wav是一种无损的音频文件格式，WAV符合 PIFF(Resource Interchange File Format)规范。所有的WAV都有一个文件头，这个文件头音频流的编码参数。WAV对音频流的编码没有硬性规定，除了PCM之外，还有几乎所有支持ACM规范的编码都可以为WAV的音频流进行编码。</p>
<p>PCM:PCM（Pulse Code Modulation—-脉码调制录音)。所谓PCM录音就是将声音等模拟信号变成符号化的脉冲列，再予以记录。PCM信号是由[1]、[0]等符号构成的数字信号，而未经过任何编码和压缩处理。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的影响效果。</p>
<p>简单来说：wav是一种无损的音频文件格式，pcm是没有压缩的编码方式。</p>
<p>WAV可以使用多种音频编码来压缩其音频流，不过我们常见的都是音频流被PCM编码处理的WAV，但这不表示WAV只能使用PCM编码，MP3编码同样也可以运用在WAV中，和AVI一样，只要安装好了相应的Decode，就可以欣赏这些WAV了。在Windows平台下，基于PCM编码的WAV是被支持得最好的音频格式，所有音频软件都能完美支持，由于本身可以达到较高的音质的要求，因此，WAV也是音乐编辑创作的首选格式，适合保存音乐素材。因此，基于PCM编码的WAV被作为了一种中介的格式，常常使用在其他编码的相互转换之中，例如MP3转换成WMA。<a href="http://blog.csdn.net/u014434080/article/details/53261433" target="_blank" rel="external">来源</a></p>
<p>采样的位数指的是描述数字信号所使用的位数。8 位(8 bit)代表 2 的 8 次方即 256，16 位(16 bit)则代表 2 的 16 次方即 65536 / 1024 = 64K</p>
<p>采样率是一秒钟内对声音信号的采样次数</p>
<p>网络接收一个音频的时长是 20ms, 已知音频采样率是 8kHz，采样的位数是 16bit。<code>[时长]20ms * [采样率]8kHz * [采样的位数]16bit = 320 byte</code></p>
<p>例如，CD 采用16位的采样精度，44.1KHz 的采样频率，为双声道，它每秒所需要的数据量为 <code>16×44100×2÷8＝176400</code> 字节。这样算下来，比特率应该是 1400 多 Kbps，如果采用 MP3、WMA 编码格式，比特率能够更小。<a href="http://www.wuroom.com/post/122/" target="_blank" rel="external">来源</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a></li>
<li><a href="https://www.v2ex.com/t/342898" target="_blank" rel="external">纯 HTML5 实现的录音功能，支持回放和上传</a></li>
<li><a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a></li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="Web" scheme="http://wdxtub.com/tags/Web/"/>
    
      <category term="语音" scheme="http://wdxtub.com/tags/%E8%AF%AD%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用操作指南</title>
    <link href="http://wdxtub.com/2017/07/10/linux-operation-guide/"/>
    <id>http://wdxtub.com/2017/07/10/linux-operation-guide/</id>
    <published>2017-07-10T01:04:50.000Z</published>
    <updated>2017-07-10T03:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="压缩解压-tar"><a href="#压缩解压-tar" class="headerlink" title="压缩解压 tar"></a>压缩解压 tar</h2><p>如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 <code>tar</code> 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。</p>
<p>使用 <code>tar</code> 命令只要记得参数是『必选+自选+<code>f</code>』即可，我们先来看看『必选！五选一』:</p>
<ol>
<li><code>-c</code> 意为 create，表示创建压缩包</li>
<li><code>-x</code> 意为 extract，表示解压</li>
<li><code>-t</code> 表示查看内容</li>
<li><code>-r</code> 给压缩包追加文件</li>
<li><code>-u</code> 意为 update，更新压缩包中的文件</li>
</ol>
<p>注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如：</p>
<ul>
<li><code>-z</code> 使用 gzip 属性</li>
<li><code>-j</code> 使用 bz2 属性</li>
<li><code>-Z</code> 使用 compress 属性</li>
<li><code>-v</code> 意为 verbose，显示详细的操作过程</li>
<li><code>-O</code> 将文件输出到标准输出</li>
</ul>
<p>然后最后一个一定要是 <code>f</code> 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 假设我们有很多 .md 文件需要打包，那么可以使用</span></div><div class="line">tar -cf posts.tar *.md <span class="comment"># c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用</span></div><div class="line">tar -rf posts.tar *.txt <span class="comment"># r 是追加文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用</span></div><div class="line">tar -uf post.tar hello.md <span class="comment"># u 是更新</span></div><div class="line"></div><div class="line"><span class="comment"># 压缩好了，我们来看看压缩包的内容，可以使用</span></div><div class="line">tar -tf posts.tar <span class="comment"># t 是列出文件内容</span></div><div class="line"></div><div class="line"><span class="comment"># 把压缩包发送到其他位置之后，需要解压，可以使用</span></div><div class="line">tar -xf posts.tar <span class="comment"># x 是解压</span></div></pre></td></tr></table></figure>
<p>加入自选参数后的用法（要不要加 v 可以看个人喜好）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># tar.gz 相关</span></div><div class="line">tar -czf posts.tar.gz *.md <span class="comment"># 压缩</span></div><div class="line">tar -xzf posts.tar.gz <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.bz2 相关</span></div><div class="line">tar -cjf posts.tar.bz2 *.md <span class="comment"># 压缩</span></div><div class="line">tar -xjf posts.tar.bz2 <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.Z 相关</span></div><div class="line">tar -cZf posts.tar.Z *.md <span class="comment"># 压缩</span></div><div class="line">tar -xZf posts.tar.Z <span class="comment"># 解压</span></div></pre></td></tr></table></figure>
<p>总结一波，遇到不同类型的文件，请用不同的套路来应对：</p>
<ul>
<li><code>*.tar</code> -&gt; <code>tar -xf</code></li>
<li><code>*.tar.gz</code> -&gt; <code>tar -xzf</code></li>
<li><code>*.tar.bz2</code> -&gt; <code>tar -xjf</code></li>
<li><code>*.tar.Z</code> -&gt; <code>tar -xZf</code></li>
<li><code>*.gz</code> -&gt; <code>gzip -d</code></li>
<li><code>*.rar</code> -&gt; <code>unrar e</code></li>
<li><code>*.zip</code> -&gt; <code>unzip</code></li>
</ul>
<h2 id="空间占用-du"><a href="#空间占用-du" class="headerlink" title="空间占用 du"></a>空间占用 du</h2><p>很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 显示当前文件下 Top 10 空间占用的文件/目录，</span></div><div class="line"><span class="comment"># s 表示不显示每个子目录或文件的大小</span></div><div class="line"><span class="comment"># h 表示用更加自然的方式显示（比如 K/M/G 这样）</span></div><div class="line">du -sh * | sort -nr | head</div></pre></td></tr></table></figure>
<h2 id="系统状态-top"><a href="#系统状态-top" class="headerlink" title="系统状态 top"></a>系统状态 top</h2><p>了解系统状态一般少不了 <code>top</code> 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看某用户的进程</span></div><div class="line">top -u wdxtub</div><div class="line"></div><div class="line"><span class="comment"># 进入系统状态显示后，具体值代表的意思是</span></div><div class="line"><span class="comment"># PR    进程优先级，越小优先级越高</span></div><div class="line"><span class="comment"># VIRT  占用的虚拟内存</span></div><div class="line"><span class="comment"># RES   占用的物理内存</span></div><div class="line"><span class="comment"># SHR   占用的共享内存</span></div><div class="line"><span class="comment"># S     进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）</span></div><div class="line"><span class="comment"># TIME+ 进程启动后占用的总 CPU 时间</span></div><div class="line"></div><div class="line"><span class="comment"># 可以按照不同的指标排序显示，按对应键即可</span></div><div class="line"><span class="comment"># P 按照 CPU 使用率排序</span></div><div class="line"><span class="comment"># T 按照 MITE+ 排序</span></div><div class="line"><span class="comment"># M 按内存使用占比排序</span></div></pre></td></tr></table></figure>
<p>其他查看进程相关信息的命令有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看进程内存分布</span></div><div class="line">pmap <span class="_">-d</span> 12345 <span class="comment"># 12345 是进程号</span></div><div class="line"></div><div class="line"><span class="comment"># 按照内存排序，这里的 grep 可以过滤特定的用户</span></div><div class="line">ps <span class="_">-e</span> -o <span class="string">'pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid'</span> | grep wdxtub | sort nrk5</div></pre></td></tr></table></figure>
<h2 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 find"></a>查找 find</h2><p>在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 找出七天前的文件</span></div><div class="line">find / -type f -mtime +7 -print</div><div class="line"><span class="comment"># / 表示从根目录中查找</span></div><div class="line"><span class="comment"># -type f 表示找出系统普通文件，不包含目录</span></div><div class="line"><span class="comment"># -mtime +n 表示寻找 n 天前的数据</span></div><div class="line"><span class="comment"># -print 打印文件名称</span></div><div class="line"></div><div class="line"><span class="comment"># 找出并删除七天前的文件</span></div><div class="line">find /temp/ -type f -mtime +7 -print -exec rm <span class="_">-f</span> &#123;&#125; \;</div><div class="line"><span class="comment"># -exec 表示后面执行系统命令</span></div><div class="line"><span class="comment"># &#123;&#125; 只有该符号能跟在命令你后面</span></div><div class="line"><span class="comment"># \; 结束符号</span></div><div class="line">find /temp/ -type f -mtime +7 -print | xargs rm <span class="_">-f</span></div><div class="line"><span class="comment"># 使用管道和 xargs = -exec</span></div><div class="line"></div><div class="line"><span class="comment"># 查找 /var 下最大的十个文件</span></div><div class="line">find /var -type f -ls | sort -k 7 -r -n | head</div><div class="line"></div><div class="line"><span class="comment"># 查找 /var/log 下大于 5GB 的文件</span></div><div class="line">find /var/<span class="built_in">log</span>/ -type f -size +5120M -exec ls -lh &#123;&#125; \;</div><div class="line"></div><div class="line"><span class="comment"># 找出今天所有文件并将它们拷贝到另一个目录</span></div><div class="line">find /home/wdxtub/ -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;</div></pre></td></tr></table></figure>
<h2 id="远程登录-ssh"><a href="#远程登录-ssh" class="headerlink" title="远程登录 ssh"></a>远程登录 ssh</h2><ul>
<li><code>ssh -vvv username@ip</code> ssh 的 debug 模式</li>
<li><code>ssh -i key.pem username@ip</code> 用 pem key 登录 ssh</li>
</ul>
<h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>这里是一些比较零碎的命令行技巧</p>
<ul>
<li><code>openssl rand -hex n</code> 产生随机的十六进制数，n 是字符数 </li>
<li><code>source /path/to/filename</code> 在当前 shell 里执行一个文件里的命令</li>
<li><code>${variable:0:5}</code> 截取变量的前五个字符</li>
<li><code>wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs</code> 用 wget 抓取完整的网站目录结构，存放到本地目录中</li>
<li><code>mkdir -p /home/wdxtub/{test0,test1,test2}</code> 一次创建多个目录</li>
<li><code>dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img</code> 测试硬盘写入速度</li>
<li><code>hdparm -Tt /dev/sda</code> 测试硬盘读取速度</li>
<li><code>echo -n &quot;test&quot; | md5sum</code> 获取文本的 md5</li>
<li><code>curl -I http://wdxtub.com</code> 获取 HTTP 头信息</li>
<li><code>netstat -tln4 | awk &#39;{print $4}&#39; | cut -f2 -d: | grep -o &#39;[0-9]*&#39;</code> 显示所有 tcp4 监听端口</li>
<li><code>time command</code> 查看命令的运行时间</li>
<li><code>export</code> 查看所有的环境变量</li>
<li><code>cmp file1 file2</code> 文件内容对比</li>
<li><code>cat -n file</code> 内容前面会显示行号</li>
<li><code>lsof -i:22</code> 查看 22 端口现在运行的程序</li>
<li><code>lsof -c abc</code> 显示 abc 进程现在打开的文件</li>
<li><code>lsof -p 12</code> 看进程号为 12 的进程打开了哪些文件</li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="运维" scheme="http://wdxtub.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>大海啊都是水 - 马来西亚游记</title>
    <link href="http://wdxtub.com/2017/07/09/sea-all-water/"/>
    <id>http://wdxtub.com/2017/07/09/sea-all-water/</id>
    <published>2017-07-09T00:37:10.000Z</published>
    <updated>2017-07-14T00:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>一四七、三六九、九九归一跟我走，上天下海不回头。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.09: 完成初稿</li>
</ul>
<p>转眼 2017 已经来到了下半年，我才开始动笔写今年的第一篇游记。工作之后，时间成了最稀缺的资源，尤其是少得可怜的年假，说走就走的旅行似乎变得那么遥不可及。幸好在同事的撺掇下，一行四人快速敲定了沙巴-仙本那的行程，才终于浮生偷得五日闲，远离平时上班的一亩三分地，真正践行了『世界这么大我想去看看』的豪言壮语。</p>
<p><img src="/images/14995667893620.jpg" alt=""></p>
<h2 id="具体行程"><a href="#具体行程" class="headerlink" title="具体行程"></a>具体行程</h2><p>为了方便想去玩的小伙伴，这里列出具体的行程，方便大家做攻略参考。</p>
<ul>
<li>第一天: 下午从香港飞到哥打基纳巴鲁，晚上入住住市中心离码头比较近的地方<ul>
<li>地点: 旺角、尖沙咀</li>
<li>饮食: 麦奀云吞面、佐敦咖喱饭、中村藤吉本店</li>
<li>交通: 步行，到机场的大巴（33 港币）</li>
</ul>
</li>
<li>第二天: 白天在码头买票游不同的岛，晚上从哥打基纳巴鲁飞到仙本那，晚上入住当地酒店</li>
<li>第三天: 在仙本那体验深潜，晚上继续住酒店</li>
<li>第四天: 在仙本那跳岛游，晚上从仙本那飞回哥打基纳巴鲁，入住 Airbnb 找到的公寓</li>
<li>第五天: 睡了一个上午，中午吃完饭，下午飞回香港，最后在深圳湾口岸回深圳</li>
</ul>
<p>其他事项</p>
<ul>
<li>机票是在穷游网打折的时候买的亚航往返，后来我才知道亚航也是马来西亚的，另一个当地航空叫做 - 马航</li>
<li>手机电力是极大的制约，充电宝有用，但毕竟不防水，所以大部分时间为了节约电力，我都是用纸笔记录</li>
<li>如果要潜水的话水下相机一定要准备好，gopro 可以搞一个，其他防水相机也很好，国产的请不要考虑，亲测渣渣</li>
<li>深潜会弄得满船都是水，最好不要携带任何贵重及怕水的物品</li>
<li>一件快干防晒风衣是非常重要的，不然动辄一个小时的海风，会让人生不如死</li>
<li>能吃饱一定要吃饱（不要管好不好吃），能睡好一定要睡好，不然巨大的体能消耗可以轻易胖子拖瘦瘦子拖垮</li>
<li>防晒基本是不够用的，请安心接受晒黑（可能还有脱皮）的结局</li>
<li>提前下载好 Uber 和 Google Map 并把重要地点标记好，出行会方便很多</li>
<li>当地电话卡信号一般，还是中国移动比较移得动（联通差评）。下了飞机拿到之前预订的当地电话卡，打 Uber 非常便宜，基本不会超过十马币（乘以 1.5 大概就是人民币）</li>
<li>离仙本那最近的机场是斗湖机场，那里只有两家航空公司：亚航与马航。机场很小（一共三个登机口）</li>
<li>东南亚口音英语比印度英语还要难听懂</li>
</ul>
<h2 id="旅途随想"><a href="#旅途随想" class="headerlink" title="旅途随想"></a>旅途随想</h2><p>以要点的形式来记录旅途随想，大部分取材于当时的文字。</p>
<p><img src="/images/14995678328174.jpg" alt=""></p>
<ul>
<li>时隔这么多年再到香港，感觉已有太大的不同。行千里路与读万卷书结合到一起之后，迸发出的新世界让我自己都有些诧异：这个世界没有那么好，但也没有那么糟。大家不过是过过日子，谁又能一直是圣人呢。</li>
<li>来到香港，大概就明白港产片和港星那种特别的气质，一种桀骜不驯的浪子今非昔比的感觉。黄金时代大幕落下后留下的回忆，需要很多时间和空间去消化。</li>
<li>不得不说香港的居民楼实在是太拥挤了，拥挤到看着就没有什么幸福感。山腰上的房子像一排屏障，有些突兀，要我说风水就不大好。现代社会一个奇怪的现象便是越拥挤反而人与人之间越生疏，这种生疏感最终撕裂了人群与社会，让很多很小的事情瞬间变得无法控制。</li>
<li>去美国之前觉得香港的路牌大约是很酷的，但在美国看久了之后就意识到，香港的一切不过是套着一层西方表皮，模仿得不能算拙劣，但却没多少特色特色。这样想来，大陆很多地方是有点土，但再土是自己的土，在我看来也要比洋人的洋要好。等什么时候洋成了一个普普通通的词汇，中国人民恐怕才算是真的站起来了。</li>
<li>飞机不出意外地晚点，预计起飞的时间已经过了一个小时，我却依然在地面上。我倒不是担心飞机晚点没办法好好睡觉，是担心子妍为了等我降落等得太久，而我又忘了让她别等早点睡。</li>
<li>快十一点的时候我们飞到了南山群岛上空，第一次离九段线和曾母暗沙如此近（水平方向上），飞了这么久还没有离开祖国，更加深刻地意识到，没有强大的海军，是无法承载这这一切的。</li>
<li>海边防晒是一个大工程，稍有不慎便会前功尽弃。但即使被晒黑了，也没必要太着急，急也变不白。比较好的方式是待在水里，毕竟比较凉快。</li>
<li>飞机晚点在哪里都是大概率事件，毕竟天气谁都说不准。不过去了其他国家再想想祖国的航空，用如此少的空域能达到如此的效率，也是挺不容易的。晚点最让人难过的是关心你的人会担心得无法入睡。</li>
<li>出来玩大家一般都是比较友好的（尤其是驴友，毕竟谁没有个需要帮助的时候呢），所以脸皮不能太薄。</li>
<li>因为在海边 + 热带，长了很多痘痘，这种情况和我上次去稻城亚丁类似，回来需要修身养性（看来我还是不太适合这种生活）。</li>
<li>深潜的体验是很奇妙的，和陆地上看到的东西完全不同（而这一切仅仅需要下潜十米），就和无人机一样，都是换一个视角来看我们的世界。不过潜水确实是一项危险的运动，我们有教练带着都感觉有点可怕（呼吸，尤其是进水之后如何处理，每个步骤都要冷静不能出错）。游泳还是要会的，在海里游泳和在游泳池里是有很大区别的。</li>
<li>出来旅行吃和住很重要，不要在这里省钱，不然肯定得不偿失。另外海鲜并没有想象中那么惊艳，正常水平而已。</li>
<li>有一个静电是水上木屋，一堆小朋友划着船过来要吃的，会说的只有 hello，抢了东西就跑。眼神中没有任何赶集，有的只是贪婪和理所当然。我感觉很悲哀，也许很多东西真的就是生来注定的，感谢祖国一波。</li>
<li>一望无际的大海第一次见，清澈的海水和珊瑚第一次见，一群小鱼从身边游过是第一次体验。</li>
<li>岛和岛之间的距离基本都需要半小时以上，在途中前不着村后不着店的无力感，只有看到镇定自若的老司机船长船员才能缓解。不然在食物和水都短缺的情况下，真不知道要如何生存。</li>
<li>夜晚的星空很美，应该是我看过最多星星的夜晚。但这其中任何一颗我们在有生之年都无法触及，有种沧海一粟的感觉，人类是多么渺小。</li>
<li>一个愿意在各方面的持续学习的人才是真正的人，这么说的意思是只会机械重复工作的人和机器本质上没有区别。</li>
<li>船员们和教练们虽然样貌有不同，但性格的内核是一样的，不然也不可能会选择这样一份职业，即开朗乐观，随遇而安。</li>
<li>要买一个能看气压等各类指标的手表，时尚款的并没有任何卵用。</li>
<li>本地人只吃冰冻海鲜，新鲜的给游客吃。</li>
<li>东南亚人有些真的挺像猴子的，尤其是那些又黑又瘦的，越离开钢筋水泥的现代社会，越会发现像动物才是最有效率的。</li>
<li>经济和文化上的政府真的很有效，大部分人都有微信，但支付宝的推广还需要时间。另外中文以后肯定在东南亚是通用语言（比如说二十年后？）</li>
<li>旅行还是要轻装要背包，拿行李箱真的不酷，当然，度假除外。</li>
<li>最好吃的一顿是叉烧和海南鸡饭，其他的除了海鲜和肉骨茶之外，基本是糟糕的回忆。</li>
<li>用脚蹼游泳是很有趣的体验，脚蹼对于水中的行动力起着决定性的作用，不过我还不得要领，需要学习。</li>
<li>被殖民很容易失去能动性，毕竟什么都被决定了，就慢慢有了奴性。</li>
<li>中国游客居多，不得不说这有好有坏，不过在中文环境中确实压力比较小。</li>
<li>回家有人在口岸等我，是这趟旅途最完美的句号。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>潜水证还是要抽时间去考一下的，去东南亚旅行是很累人的，出门在外安全最重要，吃好睡好了才能玩好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一四七、三六九、九九归一跟我走，上天下海不回头。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="旅行" scheme="http://wdxtub.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="马来西亚" scheme="http://wdxtub.com/tags/%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A/"/>
    
      <category term="潜水" scheme="http://wdxtub.com/tags/%E6%BD%9C%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>第五十六周 - 醉酒癫歌</title>
    <link href="http://wdxtub.com/2017/07/07/drunk-song/"/>
    <id>http://wdxtub.com/2017/07/07/drunk-song/</id>
    <published>2017-07-07T11:30:26.000Z</published>
    <updated>2017-07-07T13:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>莫说狂狂人心存厚道，莫笑痴因痴心难找，莫怕醉醉过海阔天高，且狂且痴且醉趁年少。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.06: 完成初稿</li>
</ul>
<p>深圳又是一个星期的雨雨晴晴雨雨雨雨，更可怕的是天气预报里十天依然是九天有雨。印象中去年并没有这样多雨，和匹兹堡相比，深圳的雨更加爽快，可以十五分钟完成倾盆到明媚的转变，仔细想想，倒也符合两座城市的风格。</p>
<p>上个周末终于跑了一次步，跑完之后就把手机里唯一的运动健身应用给卸载了，主要原因当然是新一轮的 app 极简计划又启动了，只有时不时断舍离，才能把真正重要的事物凸现出来。随着年龄的增大，更加意识到时间的宝贵，所以要把时间多花在重要的人和事上。于是把那些耗时间的数值积累类游戏都删了，都是泡沫，还是好好写博客比较靠谱。</p>
<p>在创业公司最有趣的地方在于永远不知道这种真的会做什么，比如说我的主线任务是深度学习平台，但是上周因为粗粮公司的业务，学着去用内部开发的 seq2bow 工具（不用在意这些细节，大概就是从日志中自动构建知识库的工具），这周要测试几家不同服务提供商的语音识别接口，留给主线任务的时间基本是零（因为每个新任务对我来说基本都是从零开始，一个星期要学要研究要开发要测试，还是很紧的）。</p>
<p>好在无论过程多么艰难，结果大约是好的，不断看别人的代码去学习理解别人的思路，代码读得多了，竟有种看书的感觉，仿佛可以还原出当时那个写代码的人所处的场景和内心的想法（即使用了代码格式化工具，这些痕迹也依然存在），莫名觉得很有趣，好像在和谜之拍档合作一样。有的人性如烈火，写出来的代码也是简单粗暴；有的人细致入微，文档会标出大部分需要注意的地方；还有人的深思熟虑，一看就是接受过系统编码训练的科班出身。有的服务提供商提供的是 Restful API 接口，从参数的命名、加密的方式和开发文档的风格也能看出不同人、不同团队和不同公司的风格。</p>
<p>因为我们公司和腾讯 AI 加速器深度合作，前些天两个团队一起拉着讨论了一波需求，感觉很不错。并不是说我们提什么要求对方就答应什么要求，而是双方在讨论的过程中逻辑分明，不同任务有不同的优先级，能做到的就做，能去推动的就去推动，但不能做到或者没有排期的也会如实相告，这种坦诚本身其实才是合作最重要的东西。更巧的是，后来发现其中一个小哥跟我同一天生日，有缘分，果然接口调试的也是非常顺利。</p>
<p>今天历尽艰辛终于通过 cgo 成功调用了讯飞的 linux sdk，时隔这么多年重新写 c，不得不说是很艰难的事情，但是 Go 作为 C/C++ 系列的传人，能够毫无压力（当然损失不少性能）互相调用，其实是非常取巧的做法（该处为褒义）。因为 C/C++ 的代码质量大浪淘沙，留下来的基本都是精华，能够拿来用，自然是非常省心的，如果轮子够好，那么一次就够，也是某种程度上的环保嘛。</p>
<p>现在想想，创业最难的就是找方向和找人，因为人多才能做大事，即使我效率很高能顶十个人，但如果这个活一定是要二十一个人才能完成的话，工作就会陷入困境。但是如果提前一些准备够三十个人，就能从容面对，慢工出细活了​​​​。</p>
<p>这周因为子妍要去市里集中办公，所以下班之后的主要任务就是坐地铁换乘然后散步。我还是挺喜欢两个人一路边走边聊的，雨后不太热，晚风正轻抚，除了在体育场被群众的运动热情吓到之外，其他的都和最温情的小说里写得差不多。尤其打动我的是两件事，一是我工作中攻坚受阻的时候，子妍给我买了一堆肠粉和粥（于是我吃了两天才吃完），二是我跟子妍分享了一个介绍分形的应用之后，我们一起看分形公式和图像一起感受数学之美。能够找到志趣相投积极上进热爱学习的另一半很不容易，我得好好珍惜。</p>
<p>我颠颠又倒倒好比浪涛，有万种的委屈我付之一笑；我一下低我一下高，摇摇晃晃不肯倒，酒里乾坤我最知道。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;莫说狂狂人心存厚道，莫笑痴因痴心难找，莫怕醉醉过海阔天高，且狂且痴且醉趁年少。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>留学生入户深圳指南</title>
    <link href="http://wdxtub.com/2017/07/03/oversea-student-return-guide/"/>
    <id>http://wdxtub.com/2017/07/03/oversea-student-return-guide/</id>
    <published>2017-07-03T00:50:37.000Z</published>
    <updated>2017-07-08T15:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为个人的生活和工作的变动，需要入户深圳（以留学生身份），所以在这里记录一下整个过程（因为网上的其他资料都不够详细）。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.03: 开始更新</li>
</ul>
<p>声明：本文只是个人的参考备忘，不代表任何意见或建议（也不承担任何责任），具体以规定和文件为准，本人不回答任何相关问题，遇到问题请看官自行解决（当然我会尽量写得详细，不过毕竟不同人的情况不一样，所以最重要是有灵性）。</p>
<p><strong>注意：所有资料拿到手都多复印几份，确保自己有一份复印件留底</strong></p>
<h2 id="获取教育部国外学历学位认证书"><a href="#获取教育部国外学历学位认证书" class="headerlink" title="获取教育部国外学历学位认证书"></a>获取教育部国外学历学位认证书</h2><ul>
<li>总体流程：注册及在线申请 -&gt; 在线支付认证费用 -&gt; 递交认证申请材料 -&gt; 查询认证进程 -&gt; 领取认证结果</li>
<li>所需费用：￥360(认证费用) + ￥25(邮寄费用) = ￥385</li>
<li>获得资料：国外学历学位认证书（一式两份）</li>
</ul>
<p>除照片、翻译件和授权声明外，所有材料须交验证机构验看原件（原件经现场审验后即行退回），只收取复印件。需要提交的资料有：</p>
<ol>
<li>一张近期二寸（或小二寸）证件照片，底色不限</li>
<li>需认证的国外源语言（颁发证书院校国家的官方语言）学位证书或高等教育文凭正本原件和复印件</li>
<li>需认证的国外学位证书（高等教育文凭）的中文翻译件原件（须经正规翻译机构（公司）进行翻译，个人翻译无效），深圳人才园服务大厅里就有做翻译的（就在认证窗口对面），翻完直接就可以到窗口办理学历认证</li>
<li>申请者留学期间所有护照（含护照首页-个人信息页、末页-本人签字页、以及所有留学期间的所有签证记录和出入境记录）原件和复印件</li>
<li>申请者亲笔填写的<a href="http://www.cscse.edu.cn/Portals/0/hg/sqsm.doc" target="_blank" rel="external">授权声明</a></li>
<li>如果是合作办学，需要国内大学学位证书或高等教育文凭正本原件和复印件</li>
</ol>
<p>可选材料：</p>
<ol>
<li>成绩单原件及复印件</li>
</ol>
<p>具体的步骤为：</p>
<ol>
<li>访问教育部留学服务中心的<a href="http://renzheng.cscse.edu.cn/Login.aspx" target="_blank" rel="external">国（境）外学历学位认证系统</a>，注册帐号并登录系统</li>
<li>填写完个人信息后，点击『新建申请』在线填写认证申请，进行国外学历学位认证申请</li>
<li>把该填写的东西都填写完之后（尤其是邮寄地址），进行网上支付（银联在线），费用为 ￥360(认证费用) + ￥25(邮寄费用) = ￥385</li>
<li>到选择的验证机构递交认证申请材料，我选择的是<a href="http://www.szhrss.gov.cn/wsbs/bszn/xwrz/" target="_blank" rel="external">深圳市人事人才公共服务中心</a><ul>
<li>联系人: 谭剑成</li>
<li>电话: 0755-88123601</li>
<li>地址: 深圳市福田区深南大道 8005 号深圳人才园行政服务大厅 16、17 号窗口</li>
</ul>
</li>
<li>可登录系统查询认证进程及状态</li>
<li>鉴定通过后（大概需要一个月），会得到一式两份的国外学历学位认证书</li>
</ol>
<p>相关文件：</p>
<ul>
<li><a href="http://renzheng.cscse.edu.cn/Html/rz_xz.html" target="_blank" rel="external">认证须知</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info6388.htm" target="_blank" rel="external">验证机构联系方式</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info13479.htm" target="_blank" rel="external">学历学位认证申请材料</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info3081.htm" target="_blank" rel="external">国外学历学位认证申请材料</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info6386.htm" target="_blank" rel="external">常见问题解答</a></li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>根据我自己的进度更新</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为个人的生活和工作的变动，需要入户深圳（以留学生身份），所以在这里记录一下整个过程（因为网上的其他资料都不够详细）。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="留学生" scheme="http://wdxtub.com/tags/%E7%95%99%E5%AD%A6%E7%94%9F/"/>
    
      <category term="流程" scheme="http://wdxtub.com/tags/%E6%B5%81%E7%A8%8B/"/>
    
      <category term="深圳" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%9C%B3/"/>
    
  </entry>
  
  <entry>
    <title>第五十五周 - 心的旅程</title>
    <link href="http://wdxtub.com/2017/06/30/heart-journey/"/>
    <id>http://wdxtub.com/2017/06/30/heart-journey/</id>
    <published>2017-06-30T02:47:08.000Z</published>
    <updated>2017-07-01T15:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们要一起乘风追寻梦的旅程，一路上带着那些口袋里的天真，穿越了天空穿越阴霾，向前走，大不了转个弯。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.30: 完成初稿</li>
</ul>
<p>深圳继续维持了一晒就是一天的炎热，六月转眼也来到了最后一天，一眨眼半年就过去了。好在今年上半年无论是工作生活还是感情都有了不小的进展，总体来说是一个<del>不错</del>完美的上半年。</p>
<p>潜水归来也快两周了，工作又回到了充满压力和挑战的节奏，不断要尝试新东西学习新技能，总是有很多答案未知甚至问题本身都未知的难题等着我们。开发只有了解到用户的痛点，才能真正做出有价值的产品，而了解痛点就需要在相同或类似的场景下感受不同的工作流程，走几遍就知道问题出在哪里了。但毕竟是在创业公司，临时插入的高优先级工作与主线工作的时间、精力分配，如何把握好这个度，很需要效率和判断力。</p>
<p>这周的主题曲不由得让我想起『Journey』这款游戏，风之旅人，<a href="http://wdxtub.com/2015/08/30/journey/">风之旅途</a>，心的旅程，新的旅程。在这个游戏中除了可以通过不同的按键发出声音之外，没有其他任何方式跟玩家互动，当然，你会发现很长一段时间内，这段旅程只有你一个人走。但是当未知的玩家出现时，这个游戏立刻有了变化，两人同行，面对大风和黄沙，似乎也有了多一份力量。没有语言，也就没有谎言；目标都是山顶，也就没有欺骗与怀疑。</p>
<p>游戏前期场景开阔，大家各玩各的自由飞翔，到了后期冰天雪地有些压抑，两个人就会不自觉得靠在一起，一起躲避敌人，一起对抗暴风雪。当我流连忘返于壮观美景而和陌生人失散之后，游戏一开始的孤独感又聚拢了起来。可是当我走到出口的时候，远远看见陌生人在喊着音阶等我，真的很想摔手柄，因为我居然没办法认识这个陌生人，甚至也不知道他是谁。但也许这也就是最好的羁绊。很难用言语来形容与不认识的旅人一起度过艰难险阻最后登上山顶的心情。有相遇就有分别，哪怕只能一起走一段旅程，也是令人难忘的记忆。</p>
<p>准备周记提纲的时候，无意中看到了当年记录的《亲密关系：通往灵魂的桥梁》的<a href="http://wdxtub.com/2014/09/11/close-relation-clip/">书摘</a>。有的时候重新翻翻老书的摘录，会有非常不一样的感受。</p>
<p>书中把亲密关系的过程分为以下几个阶段：绚丽、幻灭、内省和启示。对大部分人来说，这四个阶段是这样的：</p>
<ul>
<li>绚丽：即热恋期，总体表现是什么都好你好我好我们好。这种感觉良好会逐渐积累，让我们把自己从小到大得不到的、未满足的需求，全部都投射在那个爱我们、让我们觉得特殊的人身上，觉得有了他/她，这些需求都会得到满足</li>
<li>幻灭：我们总是会做出各种匪夷所思毫无逻辑的情感判断与行动选择，会懊悔会内疚会有压力，一方面，我们希望伴侣让我们快乐，而让对方感到压力；另一方面，我们自己也承受着压力，因为我们也必须做对方的『一切』。两个人都对彼此做过度的情绪索求，会在脆弱的亲密关系的互动上，施加极大的压力</li>
<li>内省：本质是在内心找到自己真正需要的事物，或者说是意识到不再需要什么来让自己变得完整，也就逐渐能够学会放手（不把需求强加在伴侣身上）和接纳（认识和接纳本来的自我）。并最终认识到：我们原本就是一个完整的个体，所需要的一切，都存在于我们心中</li>
<li>启示：需要双方的共同努力，在一段亲密关系中，伴侣之间愈亲密，分享就愈多，我们就愈可能发现平时不易察觉的旧伤。用愤怒来保护自己也就意味着用痛苦去伤害伴侣，为自己的愤怒负责的最佳方式是充分去感受它并发现生气到底是为了逃避什么。如果我们愿意面对自己所逃避的感觉（不论这令我们多么不自在），我们就能发掘埋藏在更深处的、平静而充满爱的感觉</li>
</ul>
<p>但真正到生活中，有的时候就会发现还真是应了那句老话：尽信书不如无书。因为就我和子妍的相处情况来看，我们的亲密关系并不归于上面提到的四个阶段，反而用『赌书消得泼茶香』更能表达。</p>
<p>注：赌书消得泼茶香这一典故说得是，李清照和丈夫都是著名的学者，情投意合恩爱无比，更重要的是，他们的爱是有层次有情调的，因为两人都爱看书。书看得多了，两人就打起赌来，一个问书籍中一个典故或是什么内容，另外一个人就要回答这个典故在哪本书中记载的，甚至具体到这本书在书架的位置。回答错了的话，就要将杯中的茶水倒进自己的衣服里，以示惩罚。原词为：谁念西风独自凉，萧萧黄叶闭疏窗。沉思往事立残阳，被酒莫惊春睡重。赌书消得泼茶香，当时只道是寻常。（清）纳兰性德</p>
<p>换句话说，因为我们从小到大的家庭环境和成长经历都颇为相似，也都爱读书爱思考，所以这段感情从一开始就是严肃活泼的。我们没有太多得不到或未满足的需求，我们能够认识到双方都是完整的个体，因此我们不会对彼此做过度的情绪索求。如果两个人一开始就是『明辨 博学 慎思 笃行』的，那么消极情绪、倦怠感、迷思及冲动大约是不存在的，存在的只是两个人认定彼此的坚定。</p>
<p>不合理的期望是愤怒的前奏，但合理的期待则是共同进步的最佳动力。我们为达到彼此的小小期待而努力，我们为每一点每一次互相深入了解而喝彩。正因为两个人都有足够的深度，所以新鲜感不会消散，眼前的世界反而会越来越开阔。我们不会沉迷于二人世界而成为坐井观天的井底之蛙，而是两个人合二为一同心协力踏上探索发现世界和人生的旅程。（我是多么幸福的人呀）</p>
<p>这是我们心的旅程，一起登上那座山，一起飞过那片海。乌云已经散开，阳光已经盛开，睁开眼就是未来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要一起乘风追寻梦的旅程，一路上带着那些口袋里的天真，穿越了天空穿越阴霾，向前走，大不了转个弯。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>第五十四周 - 至我们的星辰大海</title>
    <link href="http://wdxtub.com/2017/06/23/for-our-dream/"/>
    <id>http://wdxtub.com/2017/06/23/for-our-dream/</id>
    <published>2017-06-23T09:11:10.000Z</published>
    <updated>2017-06-24T08:40:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾经的我那么懦弱畏惧着一切，也曾向往外面如此美丽的世界。用力挣扎用力忘记身上的烙印，却压抑不了胸中的热血。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.23: 完成初稿</li>
</ul>
<p>从马来西亚回来，由烈日骄阳转为连日阴雨，凉快是凉快了，但湿答答粘糊糊总是不太舒服，好在临近周末天终于开始放晴。虽然这让已经晒得很黑的我黑(xue)上加墨(shuang)，但是能看到蓝天白云，总归是一件让人开心的事情。</p>
<p>本以为是度假的旅行变成了某种意义上的修炼，体力透支，精神疲惫，回到深圳后缓了两三天才恢复正常。好在走之前已经提前多做了一些工作，总归还是按计划在推进项目。写代码这个事情是非常需要『谋定而后动』的，不然大部分时间都会浪费在拆东墙补西墙上，只有先花大量的时间去探索调研，才能在转为开发阶段的时候稳准狠，效率高的同时，出错也少。所以这周也算是『收割』以前的劳动成果，我把深度学习平台的前后端框架搭好并部署到服务器上，接下来就进入一点一点上线新功能，一点一点打磨产品的阶段了。</p>
<p>回过头来想想，其实做任何事情都是一样的，旅行也好，写代码也罢，无非是从一个地方到另一个地方，执行一些动作，遇到一些困难，寻找一些方案，然后问题解决皆大欢喜。这里面有一些经验是可以总结的，比如：</p>
<ol>
<li>凡事预则立：在机场临时托运行李的价格要比网上提前预订贵一倍还有多，如果不想花冤枉钱，就要提前安排好</li>
<li>遇事莫慌张：在仙本那找不到 ATM 取钱（后来走了三公里找到了，但是排队的人实在太多），总有退而求其次的方法，多问问人就好。脸皮厚带笑容体力好，基本上出去玩问题不大</li>
<li>吃住很重要：不要因为这样那样的原因在吃和住上省钱，尤其是住，我依然记得在酒店厕所里见到蟑螂时的恐惧。最后一晚住了 airbnb，感觉就好很多</li>
<li>不如烂笔头：舟车劳顿后很容易忘事儿，手机也要省着电不能一直看着，所以最好的方法就是带一个小本子带一支笔，然后走到哪写到哪，不但可以打发时间，更重要的是有些感受是过了就不再的，只有在那时那地才有那种心境</li>
<li>防晒记心间：第一次感受热带的烈日，一个字 -『可怕』。擦了多少防晒都没啥用，最靠谱的办法就是 - 一直待在船上，中策是 - 一直泡在海水里，下策是 - 跑到海滩上照相</li>
</ol>
<p>还会另外写一篇的（毕竟我在飞机上都手写了十几页），这里就不再赘述，继续来说说写代码做工程。</p>
<p>看《乔布斯传》的时候，让我印象最深刻的情节是乔布斯的老爸言传身教让乔布斯领会到了工程之道，即『看不到的地方也要做得优雅简洁』，这并不是为了吹毛求疵，其实才是某种意义上的『捷径』，毕竟脚踏实地才是走得最快的。那么，别人看不到（或不会看）的代码为什么要写得一样好呢，因为简洁本身是一种标准，在这样标准的要求下各个模块出错的概率会大大降低，或者说出了问题需要修补的地方大大减少。而且糟糕的方案和优雅的方案可能看起来差不多，但用户真正开始用的时候，糟糕的方案就会出这样那样的问题，消耗用户对产品的信任；而优雅的方案会让用户感受到优雅简洁的力量，更重要的是用户会觉得这玩意儿靠谱，很多事情都是这样，用户对你有信心，那再难的事儿很可能也不是事儿了。</p>
<p>前些天在微博上看到西瓜大丸子汤说：程序员是一种罕见的从职业的极早期，就建立根深蒂固的协作思维的职业。代码要重用，文档要清晰，架构要考虑演化，数据要考虑用户容错。不但要和已知的队友合作，还要考虑和未知的人合作。所以程序员是特别开放的职业。在和其他一些职业对照后，就发现这种特质是多么难能可贵。合作才能改变世界。</p>
<p>确实，拥抱开源之后就会深深意识到程序员是一个多么理想主义又脚踏实地的群体（当然也有部分没有灵性的，略去不表）。在此之前我从未想过要以何种方式和全球各地并不认识的人合作，但通过群体智慧，我们真的让这个世界运行得更有效率也更加简洁了（隐藏复杂度是工程的一部分）。当然，能做要做的事情还有很多，我还要继续努力努力修行。</p>
<p>还记得很多年前我看过的一本杂志，里面提到了『<a href="http://wdxtub.com/2013/06/24/slow-net/">慢网</a>』这个概念，那时候就觉得这可能是未来的方向，毕竟随着智能设备逐渐吞噬我们的时间，总有一天会开始反转。最近我生活的重心也逐渐转向线下，下班后散散步逛逛街看看电影，去亲朋好友家拜访这些都是生活中很重要的一部分，网络不再是一个目的，最终成为了一个工具。</p>
<p>这周和子妍一起回广州，能够一起在大巴上晃悠，一起走在我走过无数次的街道上，非常开心。虽然街道年年变化感觉又熟悉又陌生，虽然天气捉摸不定几时晴几时雨，但只要一直在往前走，蓝天白云彩虹流星明月星空都会有的，我对此很有信心。虽然说从孩子身上可以看到整个家庭家族所施加的影响，但是真正去见一下，去感受一下也非常重要。一开始是两个人，后面是两个家庭，再后面是一个大家庭，整个融合交织的过程其实也是逐渐『共生』的过程，如果大家的 DNA 不匹配，这个磨合的过程就会很痛苦。但是一旦遇到了对的人，那这个碱基对就像 ATCG/ATGC/TACG/TACG 那样完美配对行云流水，组合出来超级水稻亩产一千八（一袋能顶两袋洒2333）。这个故事告诉我们，不要说找到，哪怕是遇到投缘的人，已经是很不容易；遇到，然后还要彼此欣赏喜欢，那就更是需要缘分和运气了（我终于明白了为什么我从小抽奖的手气都这么差了）。</p>
<p>挥舞双臂微笑面对我的明天，勇敢跨越我会迎风向前。努力飞吧，打破所有阻挡；飞吧，昂头冲上云霄。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经的我那么懦弱畏惧着一切，也曾向往外面如此美丽的世界。用力挣扎用力忘记身上的烙印，却压抑不了胸中的热血。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第五十三周 - 声律启蒙</title>
    <link href="http://wdxtub.com/2017/06/15/rhythm-inspiration-2/"/>
    <id>http://wdxtub.com/2017/06/15/rhythm-inspiration-2/</id>
    <published>2017-06-15T00:06:37.000Z</published>
    <updated>2017-06-15T00:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>鬓皤对眉绿，齿皓对唇红。天浩浩，日融融，佩剑对弯弓。</p>
<p>注：本周周记因为要去沙巴旅游而不得不提前写完提前发</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.15: 完成初稿</li>
</ul>
<p>细心的读者估计会发现，这是我的周记系列第二次用『声律启蒙』这个标题了，第一次单纯是觉得歌词有意境，而这次更多的是意识到不经意间往往是命中注定。</p>
<p>先来说说工作，因为本周要和同事们一起去旅游，所以工作上主要是以完善现有代码和为回来之后的自己做好交接工作为主，具体来说就是打磨现有的模块，并且为未来的模块总体统筹规划。一个人负责这类偏预研的项目其实压力和风险都不小，一是因为在没有出成果之前，确实会处于『不足为外人道也』的状态，大家都很忙，所以没有人会细细听慢慢看项目的进展，更多时候是以结果为导向的，即只要事儿做好了，哪怕所有的代码都是复制粘贴完全不可维护，也无所谓（创业公司嘛）；二是因为这个项目本身就是一个非常前沿的方向，没有现成的解决方案不说，我还需要兼容公司原有的工作流，在设计和开发上都有些带着镣铐跳舞的意思。</p>
<p>不过困难和挑战越大，做出来的东西才越有价值，我能做的就是不断思考，边写边重构，优化设计思路，用最合适的工具完成任务，争取早日出成果。不过话说回来，今年第一次出游，也许回来之后一切就豁然开朗了，毕竟要努力工作痛快玩嘛！</p>
<p>然后接着上周的话题，继续来聊聊爱情（我发现原来朋友们更喜欢看情感话题）。</p>
<p>从博客里翻出两年前看《爱是光着脚的哲学》之后写的书评，便又一次意识到了『纸上得来终觉浅』。这本书其实并没有写太多新鲜的东西，是把柏拉图的《会饮篇》和《斐德罗篇》，以及莎士比亚的《奥赛罗》与《仲夏夜之梦》中关于爱情的内容串讲了一遍。我们在日常生活中总是会看到许许多多关于情感的困惑，但倘若我们回过头去看看前辈们的思考，就会发现那些历经千年的答案，很可能就是参考答案（但并不是正确答案，毕竟没有一个衡量对错的标准）：</p>
<ul>
<li><strong>斐德罗</strong>：情爱最伟大之处，在于它能使任何人都成为最好的勇士。爱情比其他任何人类关系更能够激发我们达到理想的状态。</li>
<li><strong>鲍萨尼亚</strong>：天上的阿佛洛狄忒主导着一种纯男性浪漫爱情的人生，只关注被爱之人的灵魂，而世俗的阿佛洛狄忒所支配的只是肉体的浪漫欲望，这种快感可以从男人身上获得，也可以从女人身上获得。有序的、属天的爱是完全关乎灵魂的，而无序的、属地的爱则完全是关乎肉体的</li>
<li><strong>厄律克西马库</strong>：核心理念是平衡或和谐。爱情这门艺术就是要找出灵魂和肉体中各种要素的正确平衡。爱是能够让凡人接触到神圣之物的载体。灵魂中有健康的爱也有邪恶的爱，同样地，肉体中也分健康的爱和不健康的爱</li>
<li><strong>阿里斯托芬</strong>：人类的情爱能力在多大程度上能尊重和融合男性和女性的体验，在理解爱情时，喜剧本身应该是我们必备的一个重要视角，如果我们太过严肃，最终可能会迷失双眼，无法真正看清我们所试图了解的真相。</li>
<li><strong>吕西亚斯</strong>：为什么最好避开对我们有爱情的人？因为一个有爱情的人从本质上来说是个疯狂之人，已经不能用头脑清醒地思考。由此，和一个有爱情的人相处，就必须要忍受他可能做的各种疯狂举动。爱你的人，对你有极强的占有欲，他会试图将你从亲朋好友身边拉走，因为他会嫉妒你和他们在一起的时间，他希望你所有的精力都集中在他身上，死心塌地地认为拥有他会让自己安心，得到保护。</li>
<li><strong>狄奥提玛</strong>：爱情和欲望暗含着需要和缺乏。爱智慧的哲人是情爱生活的模范榜样，因为他们一刻不停地寻求智慧，这种寻找从不会放弃，也不会满足。爱身上丰富和贫乏的结合，让他始终处于生气勃勃和贫乏衰败两种状态的交替之中。这种永不停息的循环就是情爱生活的本质所在。当我们一旦遇上美丽的爱人时，我们就会体验到，那种创造新生的冲动。正确的浪漫爱情，应该能鼓舞我们渴望成为一个更加完美的自己。</li>
<li><strong>苏格拉底</strong>：对于像我们这样终有一死的众生来说，我们期望情爱不朽，超过我们的生命长度。因此，情爱欲望的中心部分，就是某种战胜死亡、抵达永恒的渴望。爱是我们抵达不朽的阶梯。苏格拉底式的创造力是双性同体的，男子气概和女性气质，通过孕育而完美融合——身体和精神双重意义上的。</li>
<li><strong>柏拉图</strong>：当我们坠入爱河，我们没有像有些人说的那样“安定下来”，而是变得不安分，以我们以前从来不敢想象的方式去追寻。因此，浪漫生活是一种充满渴望、不断追求的生活，而不是一种简单满足的生活：是一种舍弃。浪漫让我们体会到，生活并不完美。通过哲学，我们学到一个艰难的事实：我们常常害怕并且躲避现实。但是，当我们坠入爱河并开始作为爱人和被爱之人的崭新自我时，这种害怕反而没有之前来得强烈。</li>
</ul>
<p>不知道大家认同哪一位先贤的观点？当年的我首推柏拉图（注：和我们现在理解的柏拉图式爱情还是有很大区别的），现在的我不会去在意爱情是什么形状，而更关注最终能发现怎么样的新世界。至今我还是心心念念《爱的艺术》中的这么一段话：</p>
<blockquote>
<p>爱情只能产生于这样两个人中间，这两个人都从他们生存的圈子里跳出来并互相结合，同时他们每个人都又能脱离自我中心去体验自己。只有这种『中心体验』才是人的现实，才是生活，才是爱情的基础。这样体验到的爱情是不断地挑战，这种爱情不是避风港，而是一种共同的努力、成长和劳动。如果两个人能从自己的生命的本质出发，体验到通过与自觉地一致，与对方结成一体，而不是逃离自我，那么在这样的基本事实面前，就连和谐、冲突、欢乐和悲伤这样的东西也就只能退居第二位了。“爱情的存在只有一个证明：那就是双方联系的深度和每个所爱之人的活力和生命力。这也是我们所能看到的爱情的唯一成果。</p>
</blockquote>
<p>每当看到这些充满憧憬的画面我都会想，一个人得是多么幸运，才能拥有这样的『中心体验』，才能在共同的努力、成长和劳动中，让双方联系的深度更深，让每个所爱之人的活力和生命力更强。</p>
<p>我也一直在想，阅读、写作和思考让我最终成为了我，却也让人孤独。我有了更为广阔的精神世界，却发现那片土地原没有现实中来得拥挤，甚至想要擦肩而过，很多时候都是一种奢望。但忽然有一天，我发现这么一个人，我想说的话也是她想说的，我看过的书也是她看过的，我爱听的歌也是她爱听的，我想走的路也是她想走的，我想看的风景也是她想看的。我也逐渐意识到这些巧合绝不是偶然，不经意间往往是命中注定。我也相信这样美好的巧合还会越来越多。</p>
<p>回过头去看看前人的观点，他们都很机智地没有提及时间这个变量，即两个人在一起要多久才能达到理想状态。这个其实和速度的公式是一样的，即  $v_t = v_0 + at$ ，如果初速度和加速度足够大，那么时间即使不长，也可以达到足够理想的境界。就好像两辆车一起公路旅行，如果都是慢车，自然走不快；如果一快一慢，如果要通行则只能迁就慢的；但如果都是好车，那自然可以一路驰骋，春风得意马蹄疾。</p>
<p>如果目标是星辰大海，那么只要前期准备完成，就不用去在意老黄历中的黄道吉日，对于探索者来说，每一天都是黄道吉日。</p>
<p>女子眉纤，额下现一弯新月；男儿气壮，胸中吐万丈长虹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鬓皤对眉绿，齿皓对唇红。天浩浩，日融融，佩剑对弯弓。&lt;/p&gt;
&lt;p&gt;注：本周周记因为要去沙巴旅游而不得不提前写完提前发&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="旅行" scheme="http://wdxtub.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第五十二周 - 君是山</title>
    <link href="http://wdxtub.com/2017/06/09/you-are-mountain/"/>
    <id>http://wdxtub.com/2017/06/09/you-are-mountain/</id>
    <published>2017-06-09T07:56:27.000Z</published>
    <updated>2017-06-09T15:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>君是君，山归山。明月石上，流连琴声晚。水千尺，双扶摇，倒影船。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.09: 完成初稿</li>
</ul>
<p>一整周的晴空万里一扫之前的阴霾，让人心旷神怡。还记得多年前在五道口过街通道中透过玻璃看到的蓝天，大约北方的天空就是和南方的有些不同吧。</p>
<p>如果把时间倒回到 09 年，那天的我终于考完了最后一科 - 物理，也标志着我在执信的生活要划上一个句号了。我一直觉得执信给我的不仅仅是三年高中，而是一群志同道合同时又充满灵性的朋友，让我得以真正开始自己的人生。但我未曾想过的是，高考那年，直到今天仍旧以各种意想不到的方式影响着我，改变着我。</p>
<p>我还清楚得记得中考的时候妈妈跟我说过，华附有全省招生的班，里面可汇聚着全广东最厉害的学生（那时候华附是全省招生，而执信只限于广州市）。我当时想着『我才不要到压力那么大的地方去呢』，便带着所有的憧憬来到了执信（这里得插一句，那年中考我的总分是广州市的第 35 名，所以理论上我想去哪就去哪）。</p>
<p>而如今，我遇到一个人，我来自执信她来自华附，我学物理她学化学，我们同年高考，她比我高一分。我们都去了中山大学，甚至也许在明德园到至善园的路上擦肩而过，毕业后兜兜转转最后此时此刻在深圳相遇。我不禁想引用来自漳州大儿童的一名小朋友的诗（并画蛇添足）：</p>
<blockquote>
<p>天空喜欢收集阳光，时钟喜欢收集数字，插座喜欢收集电，而我喜欢收集你。</p>
</blockquote>
<p>很多事情是第一眼就可以看出来的，比如说有没有灵性。就像前面三句出自小朋友之手的诗歌，只要看一眼，就能意识到孩子观察世界的角度与表达方式是多么有趣。天空与阳光，时钟与数字，插座与电，居然能用『收集』来联系到一起，仿佛透过文字都能看到那颗打量世界的好奇心。</p>
<p>但很多事情是很难第一眼就能看出来的，比如说识人。不同的人生像环绕的年轮与无言的大地，要细细品慢慢看才能琢磨一二。童年与成长，少年与叛逆，青年与选择，又如何能够在惊鸿一瞥之间一目了然呢？我们都想遇到另一个自己，却在不断的找寻中，发现这真的是太难了，太需要坚持，太需要努力，太需要缘分。没有坚持，路走不长；没有努力，路走不远；没有缘分，路走不到一起。</p>
<p>我开始感谢自己这些年来的写作，不但给了我自己一个跟过去对话的机会，也给了懂我的人一个参与我过去的机会。当我读着她五六年前的文字，仿佛又回到了当年的青葱激扬。我们的人生与记忆得以通过文字在更长的时间维度中交织，原来，我们已经认识那么久了。</p>
<p>我们一起跟弗洛姆探讨过爱的艺术，一起了解过上帝如何掷骰子，一起见证了一九八四的故事，一起等怪物来敲门，一起拯救今天拯救世界，一起狩猎鬼王，一起沐浴皎洁月色，一起喂蚊子。</p>
<p>终于能高兴的告诉自己，一个死理性派的人化，完成了。</p>
<p>最后照例还是要提一下工作，这段时间我的主要经历是设计和搭建深度学习平台，能够有机会仔细去琢磨一个问题，而且是在时代最前沿的还没有所谓最佳解答的问题，其实是特别幸运的事情。得跟其他所有敢于突破的探险家一样，跳出思维的桎梏，用全新的方式去解决问题。</p>
<p>所谓全新的方式，并不是说可以把原来的东西都抛诸脑后，把相关的文档，前人的积累捋清楚还是非常重要的，因为只有掌握了来龙去脉，遇到问题的时候才能对症下药，不然直接就上手做，反而欲速则不达。我的经验是项目开始的时候一定要慢，前面构思和调研的越清楚，后面走的弯路就越少。目的有多明确，项目就能做到多好，越是根基，越要慢，越要打好。</p>
<p>觉得自己很幸运，要更加努力，去配得上这份幸运。</p>
<p>君是山，山若水，飞雾流烟不懂琴声泪。情喝不干，一生长一梦短，相知不为红粉，相约只为来生再伴随。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;君是君，山归山。明月石上，流连琴声晚。水千尺，双扶摇，倒影船。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习平台设计指南</title>
    <link href="http://wdxtub.com/2017/06/05/deep-learning-platform-design/"/>
    <id>http://wdxtub.com/2017/06/05/deep-learning-platform-design/</id>
    <published>2017-06-05T01:18:40.000Z</published>
    <updated>2017-07-04T07:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了更好理解深度学习平台的定位和作用，我先来讲两个小故事。</p>
<h3 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h3><p>一位侠客来到大师面前，有气无力地问到：『大师，我已拿到了各种极品装备，本人的属性值也超高，为什么我还是没办法行走江湖呢？』</p>
<p>大师头也不抬说：『因为你都快饿死了，身体已经撑不住，这些属性和装备又有什么用呢？』</p>
<h3 id="故事二"><a href="#故事二" class="headerlink" title="故事二"></a>故事二</h3><p>实验室最新打造了一台号称最智能的汽车，老板和研究组长在发布仪式后一起试乘。汽车开动之后体验了各种智能功能，老板觉得很满意，于是说：『来我们换个档飙一把』。</p>
<p>研究组长面露难色，语音操作车停下，然后下车打开前盖，开始把车里的芯片换成另一个档的芯片，之后再上车、启动。</p>
<p>老板说：『这不行，用户体验智能了，但是车的体验智障了』</p>
<h3 id="阅读理解"><a href="#阅读理解" class="headerlink" title="阅读理解"></a>阅读理解</h3><p>第一个故事说的是深度学习平台的建设一定是要基于公司目前的状况和未来的发展，不然用的技术再先进，没有对业务产生价值，那就是拿公司的未来做慈善了。毕竟公司都倒了，有这么个平台又有什么用呢？</p>
<p>第二个故事说的是深度学习目前落地的一些痛点，因为暂时没有一个成熟的流程体系，从研发到真正应用到产品上，中间的环节繁琐易出错不说，也没有一个统一的管理、监控的最佳实践。虽然交付给用户和客户的产品是『智能』的，但创造智能的过程是『智障』的，所以平台的作用在于探索和规范，把软件工程的成功实践应用到以深度学习为代表的人工智能技术上。</p>
<h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><p>因为深度学习的工程化远不如传统软件成熟，大部分时候小公司的训练流程是这样的：</p>
<ul>
<li>研究人员在本地测试算法</li>
<li>通过 SSH 和各类辅助工具把代码上传到服务器</li>
<li>修改代码进行各类数据配置</li>
<li>进行测试</li>
<li>测试后人工收集结果</li>
</ul>
<p>最开始只有一两台机器，一两张 GPU 卡的时候，这个方案是最简单粗暴，所需要的人工成本也较低。但随着单机多卡甚至多机多卡的全面铺开，随着在线流程和离线机器的不断增加，原来的方法难以为继，需要更有效率且更科学的方式来组织整个从研发到落地低流程，这也正是深度学习平台的价值所在。（感谢炳廷修改错别字）</p>
<h2 id="平台定位"><a href="#平台定位" class="headerlink" title="平台定位"></a>平台定位</h2><p>从前面的故事中我们可以把平台的具体定位细化一下，简单来说是：</p>
<ul>
<li>高效支持业务。提高业务的效率是第一位的<ul>
<li>包括业务的新增、调整、删除</li>
<li>各个步骤都应该是可以配置的，最好有 Web UI 来可视化编辑（避免通过改脚本，因为很容易出错）</li>
</ul>
</li>
<li>高效支持研发。尽量少侵入研发原有的流程，或提供外部工具支持<ul>
<li>研发过程是非结构化、敏捷的，需要有机制把测试好的算法规范化</li>
<li>结果验证和测试的自动化，版本化，便于跟踪对比算法效果</li>
<li>尽量给研发人员最大的自由度的同时，保证系统的鲁棒性</li>
<li>减少不必要的训练，根据业务的需求支持峰谷的利用</li>
</ul>
</li>
<li>连接已有系统。做信息中枢，用统一的架构提高资源利用率和信息的流转速度<ul>
<li>把原来单机的脚本改造成集群操作</li>
<li>利用分布式存储打通各台机器的存储，统一输入与输出</li>
<li>计算资源池化，考虑跨地区，跨云的解决方案</li>
</ul>
</li>
</ul>
<h2 id="需求分解"><a href="#需求分解" class="headerlink" title="需求分解"></a>需求分解</h2><p>不同用户角色对系统的需求也是不一样的，按照通常的分类方法，这里把系统需求以科研、后台、产品、运维四个角度来进行划分，具体如下：</p>
<h3 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h3><p>算法的研发人员最关心的只有一个事情：如何快速测试验证算法，查看算法效果。</p>
<p>在此基础上对其工作流程不能侵入太多，毕竟各有各的工作习惯，不能也没必要做太多要求，只要保证输入、运算和输出的接口一致即可（当然需要一定的修改，尽量简单或提供转换工具）。所以对于科研来说，难点在于如何在整合现有本地和服务器上的训练流程的同时，保持整个逻辑的简洁，并且让每个步骤都可配置。</p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>后台的开发人员最关心的只有一个问题：如何保证服务的高效稳定，如何缩短业务部署上线或做其他调整的时间。</p>
<p>这就意味着能自动化的流程要尽量自动化，因为深度学习平台主要关注于深度学习本身，所以只要和后台系统能够自动对接，并且整个过程可以监控，能够容错（比如自动重试）。这部分其实跟传统的软件工程联系比较紧密，只要有老司机把关，基本问题不大，对好接口即可。（打个小广告，我司来自腾讯的老司机后台团队非常靠谱，有想写 C++ 的同学请联系我）</p>
<p>对于小公司来说，很多时候运维的工作也会逐步转为 DevOps 模式，在我看来，运维的核心就是有一种方法能够清晰快速了解系统的运行状态，出了问题能够在自动修复的基础上进行一定的通知和告警，这些都是能够集成到系统中的。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>产品最关心的是功能和交互是否达到了用户期待以及如何去跟踪各个功能点的表现。</p>
<p>虽说看起来这个跟深度学习关系不大，但实际上产品经理对深度学习（至少是流程）需要有一定的了解，这样才能做到『量体裁衣』，用合适的形式展示最智能的功能给用户提供最完美的体验（无论是 2B 还是 2C 都是如此）。</p>
<p>那么深度学习平台需要提供的是有实效性且可参考的模型训练及测试数据，这样无论是产品经理还是项目经理心理都更有数，在和客户沟通的时候更有把握。说白了这是一个期待值管理的问题，心里有底，自然不一样。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文简单从设计的角度介绍了我对深度学习平台的一些想法（因为是公司的项目，所以只能讲一下思路，具体就不展开了）。感谢 glen 总、杨老师、文博和 jelly 的指导和检查，除了设计指南，之后还会写一下技术实现上的难点和重点，希望大家喜欢。</p>
<hr>
<p>最后依然是一波招聘小广告</p>
<ul>
<li>能力要求：全栈 + Docker + K8S + Tensorflow + Spark</li>
<li>任务目标：搭建深度学习平台，开发深度学习算法</li>
<li>如果不甘心当个螺丝钉，为什么不来一起搞点事情呢？</li>
<li>联系方式：老读者都知道的，这里就不赘述了</li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="http://wdxtub.com/2017/06/05/k8s-note/"/>
    <id>http://wdxtub.com/2017/06/05/k8s-note/</id>
    <published>2017-06-05T01:06:25.000Z</published>
    <updated>2017-07-04T07:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 开始学习</li>
</ul>
<h2 id="Kubernetes-基础"><a href="#Kubernetes-基础" class="headerlink" title="Kubernetes 基础"></a>Kubernetes 基础</h2><p>先来看一段来自<a href="http://www.paddlepaddle.org/doc_cn/howto/usage/k8s/k8s_basis_cn.html" target="_blank" rel="external">这里</a>的简介（我更新了一下链接）：</p>
<p>Kubernetes 是 Google 开源的容器集群管理系统，其提供应用部署、维护、扩展机制等功能，利用Kubernetes 能方便地管理跨机器运行容器化的应用。Kubernetes 可以在物理机或虚拟机上运行，且支持部署到 AWS，Azure，GCE 等多种公有云环境。介绍分布式训练之前，需要对 Kubernetes 有一个基本的认识，下面先简要介绍一下本文用到的几个 Kubernetes 概念。</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="external">Node</a> 表示一个 Kubernetes 集群中的一个工作节点，这个节点可以是物理机或者虚拟机，Kubernetes 集群就是由 node 节点与 master 节点组成的。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="external">Pod</a> 是一组(一个或多个)容器，pod 是 Kubernetes 的最小调度单元，一个 pod 中的所有容器会被调度到同一个 node 上。Pod 中的容器共享 NET，PID，IPC，UTS 等 Linux namespace。由于容器之间共享 NET namespace，所以它们使用同一个 IP 地址，可以通过 localhost 互相通信。不同 pod 之间可以通过IP地址访问。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="external">Job</a> 描述 Kubernetes 上运行的作业，一次作业称为一个 job，通常每个 job 包括一个或者多个pods，job 启动后会创建这些 pod 并开始执行一个程序，等待这个程序执行成功并返回 0 则成功退出，如果执行失败，也可以配置不同的重试机制。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="external">Volume</a> 存储卷，是 pod 内的容器都可以访问的共享目录，也是容器与 node 之间共享文件的方式，因为容器内的文件都是暂时存在的，当容器因为各种原因被销毁时，其内部的文件也会随之消失。通过 volume，就可以将这些文件持久化存储。Kubernetes 支持多种 volume，例如 hostPath(宿主机目录)，gcePersistentDisk，awsElasticBlockStore等。</li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="external">Namespaces</a> 命名空间，在 kubernetes 中创建的所有资源对象(例如上文的 pod，job)等都属于一个命名空间，在同一个命名空间中，资源对象的名字是唯一的，不同空间的资源名可以重复，命名空间主要为了对象进行逻辑上的分组便于管理。本文只使用了默认命名空间。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolume</a>: 和 <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolumeClaim</a> 结合，将外部的存储服务在 Kubernetes 中描述成为统一的资源形式，便于存储资源管理和 Pod 引用。</li>
</ul>
<p>如果看不懂，也没有关系，接下来会更详细介绍。PS. 官方文档很有灵性，建议有英文阅读能力的同学去通读一遍，这里只是我的一些学习笔记，不如原版这么有逻辑性。</p>
<p>Kubernetes 集群让多台机器像一个单一组件一样运行，但是有一个前提条件，就是应用需要被打包到容器里。打包好之后 Kubernetes 会自动化地以一种高效的形式去调度容器们。一个 Kubernetes 集群有两种类型的资源：</p>
<ul>
<li><strong>Master</strong> 负责调度集群，维护应用状态，扩展应用和滚动更新</li>
<li><strong>Nodes</strong> 负责运行各个应用。每个节点有一个 <code>Kubelet</code>，是在每个节点上的客户端，负责与 master 交流。一个 Kubernetes 集群至少需要 3 个 node。<ul>
<li>如果想要体验一下，可以使用 Minikube，会在单机上创建虚拟机来搭建集群（本文的教程也是用这个来展示的）</li>
</ul>
</li>
</ul>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; minikube version</div><div class="line">minikube version: v0.15.0-katacoda</div><div class="line"></div><div class="line"><span class="comment"># 启动集群</span></div><div class="line">$&gt; minikube start</div><div class="line">Starting <span class="built_in">local</span> Kubernetes cluster...</div><div class="line"></div><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; kubectl version</div><div class="line">Client Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"2017-01-12T04:57:25Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.4"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line">Server Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"1970-01-01T00:00:00Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.1"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># 查看集群状态</span></div><div class="line">$&gt; kubectl cluster-info</div><div class="line">Kubernetes master is running at http://host01:8080</div><div class="line">heapster is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/services/heap</div><div class="line">ster</div><div class="line">kubernetes-dashboard is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/s</div><div class="line">ervices/kubernetes-dashboard</div><div class="line">monitoring-grafana is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/ser</div><div class="line">vices/monitoring-grafana</div><div class="line">monitoring-influxdb is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/se</div><div class="line">rvices/monitoring-influxdb</div><div class="line"></div><div class="line"><span class="comment"># 获取可用的 node</span></div><div class="line">$&gt; kubectl get nodes</div><div class="line">NAME      STATUS    AGE</div><div class="line">host01    Ready     15m</div></pre></td></tr></table></figure>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>Kubernetes 集群启动之后，就可以在这之上部署应用了。部署应用的时候 master 会进行调度并选择合适的 node，启动之后仍旧会继续监控，一旦出问题，就会自动重新启用。</p>
<p>我们可以使用 Kubernetes 命令行工具 <code>Kubectl</code> 通过 Kubernetes API 来管理部署。创建部署的时候需要指定镜像和要运行的副本个数（当然也可以后面更新），然后们就实际来部署一波，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 部署应用</span></div><div class="line">$&gt; kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080</div><div class="line">mp:v1 --port=8080ubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootca</div><div class="line">deployment <span class="string">"kubernetes-bootcamp"</span> created</div><div class="line"></div><div class="line"><span class="comment"># 列出部署</span></div><div class="line">$&gt; kubectl get deployments</div><div class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">kubernetes-bootcamp   1         1         1            1           1m</div><div class="line"></div><div class="line"><span class="comment"># 查看部署</span></div><div class="line"><span class="comment"># 先通过 proxy 连接到正在运行的容器</span></div><div class="line">$&gt; kubectl proxy</div><div class="line">Starting to serve on 127.0.0.1:8001</div><div class="line"></div><div class="line"><span class="comment"># 然后打开一个新 tab，输出 Pod 名字</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-n7q3n</div><div class="line"></div><div class="line"><span class="comment"># 获取这个 pod 的输出</span></div><div class="line">$&gt; curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/<span class="variable">$POD_NAME</span>/</div><div class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-390780338-n7q3n | v=1</div></pre></td></tr></table></figure>
<h3 id="查看应用"><a href="#查看应用" class="headerlink" title="查看应用"></a>查看应用</h3><p>每个应用会在一个 Pod 中运行，一个 Pod 里可以有一个或多个应用（相当于给这些应用创建了一个共有的 localhost 环境，每个 pod 里的网络等环境是共享的）。</p>
<p>每个 Pod 都会运行在一个 Node 上，每个 Node 都由 Master 来管理。其中，每个 Node 都必须要有：</p>
<ul>
<li><code>Kubelet</code>，负责与 Master 通讯，管理 node 上运行的 pods 和 containers</li>
<li>一个容器的 runtime，比如 docker，用来从 registry 拉取镜像，解压与运行应用</li>
</ul>
<p>常用的 <code>kubectl</code> 命令有</p>
<ul>
<li><code>kubectl get</code> 列出所有的资源</li>
<li><code>kubectl describe</code> 显示资源的详细信息</li>
<li><code>kubectl logs</code> 输出一个 pod 中一个 container 的日志</li>
<li><code>kubectl exec</code> 在一个 pod 中的一个 container 中执行命令</li>
</ul>
<p>例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-6b9n3   1/1       Running   0          41m</div><div class="line"></div><div class="line"><span class="comment"># 查看 pods 详细信息</span></div><div class="line"><span class="comment"># 包括 镜像、IP 等各类信息，describe 不仅可以用于 pods，node 和 deployment 都可以</span></div><div class="line">$&gt; kubectl describe pods</div><div class="line">Name:           kubernetes-bootcamp-390780338-6b9n3</div><div class="line">Namespace:      default</div><div class="line">Node:           host01/172.17.0.41</div><div class="line">Start Time:     Mon, 05 Jun 2017 03:05:07 +0000</div><div class="line">Labels:         pod-template-hash=390780338</div><div class="line">                run=kubernetes-bootcamp</div><div class="line">Status:         Running</div><div class="line">IP:             172.18.0.2</div><div class="line">Controllers:    ReplicaSet/kubernetes-bootcamp-390780338</div><div class="line">Containers:</div><div class="line">  kubernetes-bootcamp:</div><div class="line">    Container ID:       docker://9308ecb7bb592255b5fb517ec7caa13703f7b5bb41a24145ba1eeb670693a60d</div><div class="line">    Image:              docker.io/jocatalin/kubernetes-bootcamp:v1</div><div class="line">    Image ID:           docker-pullable://jocatalin/kubernetes-bootcamp@sha256:0d6b8ee63bb5</div><div class="line">7c5f5b6156f446b3bc3b3c143d233037f3a2f00e279c8fcc64af</div><div class="line">    Port:               8080/TCP</div><div class="line">    State:              Running</div><div class="line">      Started:          Mon, 05 Jun 2017 03:05:08 +0000</div><div class="line">    Ready:              True</div><div class="line">    Restart Count:      0</div><div class="line">    Volume Mounts:</div><div class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-74qlr (ro)</div><div class="line">    Environment Variables:      &lt;none&gt;</div><div class="line">Conditions:</div><div class="line">  Type          Status</div><div class="line">  Initialized   True</div><div class="line">  Ready         True</div><div class="line">  PodScheduled  True</div><div class="line">Volumes:</div><div class="line">  default-token-74qlr:</div><div class="line">    Type:       Secret (a volume populated by a Secret)</div><div class="line">    SecretName: default-token-74qlr</div><div class="line">QoS Class:      BestEffort</div><div class="line">Tolerations:    &lt;none&gt;</div><div class="line">Events:</div><div class="line">  FirstSeen     LastSeen        Count   From                    SubObjectPath             Type             Reason          Message</div><div class="line">  ---------     --------        -----   ----                    -------------             -------- ------          -------</div><div class="line">  41m           41m             1       &#123;default-scheduler &#125;                              Normal           Scheduled       Successfully assigned kubernetes-bootcamp-390780338-6b9n3 to host01</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Pulled          Container image <span class="string">"docker.io/jocatalin/kubernetes-bootcamp:v1"</span> already present on machine</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Created         Created container with docker id 9308ecb7bb59; Security:[seccomp=unconfined]</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Started         Started container with docker id 9308ecb7bb</div><div class="line">59</div><div class="line"></div><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-6b9n3</div><div class="line"></div><div class="line"><span class="comment"># 查看 pod 日志</span></div><div class="line">$&gt; kubectl logs <span class="variable">$POD_NAME</span></div><div class="line">Kubernetes Bootcamp App Started At: 2017-06-05T03:05:08.494Z | Running On:  kubernetes-bootcamp-390780338-6b9n3</div></pre></td></tr></table></figure>
<h3 id="使用服务暴露应用"><a href="#使用服务暴露应用" class="headerlink" title="使用服务暴露应用"></a>使用服务暴露应用</h3><p>Pods 是有生命周期的，也有独立的 IP 地址，随着 Pods 的创建与销毁，一个必不可少的工作就是保证各个应用能够感知这种变化。这就要提到 Service 了，Service 是 YAML 或 JSON 定义的由 Pods 通过某种策略的逻辑组合。更重要的是，Pods 的独立 IP 需要通过 Service 暴露到网络中，有以下几种方式：</p>
<ul>
<li><code>ClusterIP</code>(默认)：只在集群内部可见的地址</li>
<li><code>NodePort</code>：可在集群外访问，需要指定端口</li>
<li><code>LoadBalancer</code>：创建一个负载均衡器，IP 是固定的</li>
<li><code>ExternalName</code>：使用任意的名字暴露服务</li>
</ul>
<p>依然是通过实例来感受一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看 pods 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-76skz   1/1       Running   0          6s</div><div class="line"></div><div class="line"><span class="comment"># 查看服务信息</span></div><div class="line">$&gt; kubectl get services</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</div><div class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP   47s</div><div class="line"></div><div class="line"><span class="comment"># 暴露服务</span></div><div class="line">$&gt; kubectl expose deployment/kubernetes-bootcamp --type=<span class="string">"NodePort"</span> --port 8080</div><div class="line">service <span class="string">"kubernetes-bootcamp"</span> exposed</div></pre></td></tr></table></figure>
<h3 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h3><p>当业务流量暴涨，就需要根据需要扩展应用（多几个 pods），具体的原理比较简单，我们直接来看例子：</p>
<p>TODO</p>
<h3 id="更新应用"><a href="#更新应用" class="headerlink" title="更新应用"></a>更新应用</h3><p>滚动更新可以保证 0 停机时间，其实逻辑和前面的扩展差不多，可以认为是用新版本的扩展，也直接来看例子：</p>
<p>TODO</p>
<h2 id="Hello-Minikube"><a href="#Hello-Minikube" class="headerlink" title="Hello Minikube"></a>Hello Minikube</h2><p>一个简单的教程，学习如何把本机的代码转换成 Kubernetes 可以使用的镜像</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hosted solution</p>
<p>turnkey cloud solutions</p>
<p>CentOS Version</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="external">Official Kubernetes Tutorial</a></li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="集群" scheme="http://wdxtub.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Kubernetes" scheme="http://wdxtub.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>第五十一周 - 随缘</title>
    <link href="http://wdxtub.com/2017/06/02/let-it-be/"/>
    <id>http://wdxtub.com/2017/06/02/let-it-be/</id>
    <published>2017-06-02T13:22:22.000Z</published>
    <updated>2017-06-02T14:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>刀光剑影不是我门派，天空海阔自有我风采。双手一推非黑也非白，不好也不坏，没有胜又何来败。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.02: 完成初稿</li>
</ul>
<p>随团建拉开的端午假期的序幕在这周三戛然而止，除了国庆没有任何假期的下半年就这么猝不及防地来了。端午哪都人多，妈妈去北京参加同学聚会，老爸、发小和我就约着去南沙自驾游了一圈。主题当然就是逛吃逛吃，无奈天公不作美，一面很晒，一面有霾，于是所有的航拍照片，只有俯视角+去雾滤镜是可以看的。不过能让我的俩哥们儿（我爸和我发小）一起感受刚买的飞行眼镜，再晒再累也值得。</p>
<p>飞无人机的时候在想，如果它有自己的感受，恐怕只有在飞的时候，无人机才真正是无人机，不然只是趟在橱窗里的咸鱼而已。人也是这样，只有真正做到自己想做的事情，成为自己的时候，才是人本身，不然也就是吃喝拉撒的咸鱼而已。</p>
<p>没有人喜欢做脏活累活，但是如果脏活累活都做不好（因为一般来说这种活都比较简单），是没有机会去做其他看起来不脏不累的活的（其实只是看起来，很多时候看起来越轻松，所肩挑的担子越大，负的责任也越大）。所以那些本职工作没做好，却总觉得自己怀才不遇的同学其实很可能得一直做脏活累活。反倒是那种有些随遇而安，做什么都踏踏实实做好，还有点灵性的同学，有机会做更大的事情。</p>
<p>有的同学确实做事情踏踏实实，确实也完成了任务，但是在完成任务的过程中不懂脑筋，把工作当差事而不是当艺术，很多时候也只能成为类似小组长的角色。比如说同样是写代码，有的人的代码干净整洁井井有条，一看就能意识到个中蕴含的思考和智慧；但有的人的代码就是简单粗暴的复制粘贴，一看就是有了锤子满眼都是钉子。不是说满眼都是钉子不好，而是这种观察事物的角度本身是狭隘的，没有创新的，也就使得自己丧失了面对未知挑战的能力。</p>
<p>现实世界是复杂的，即使是建筑在 01 基础之上的软件工程，因为越来越跟现实纠缠在一起，也不得不去面对这些复杂性。我们也不得不绞尽脑汁用最优雅的方式去解决繁琐复杂的问题。今天下午给公司技术老大和算法老大做的深度学习平台的技术方案设计基本顺利通过，除了部分细节需要细化之外，老大们基本认同的我的方案，也让我放手去做，如果人不够就继续招（所以这里继续招人，想一起搞事情的一定要留意文末的招聘信息）。这其实是让我特别开心的，毕竟在这个领域现在还没有现成的解决方案，能和所有人一起在同一个起跑线上竞赛，如果还能凭借自己的努力弯道超车的话，就很有灵性了。</p>
<p>今天在处理家里的杂事儿时候真正按照自己劝别人的做了一次即：在对方情绪不好的事情，注意说话的态度，把事情往好的方向引导，不要埋怨而把事情弄得更糟。很多事情都是说起来容易做起来难，但真正做到了，其实就会发现往往关键就在于那一念之间。</p>
<p>读书和游戏都是很重要的，都是体验生活的方式，从某种角度来说，只要想象力够，这两者很多时候是一个事情，即去体验那些自己可能没有办法体验的一切。而如果能找到在这两方面都非常聊得来的伙伴，的确是非常开心的事情。</p>
<p>没有去哪有来，手中无剑心中无尘，才是我胸怀。随缘而去乘风而来，才是我胸怀。</p>
<hr>
<p>附：招聘信息</p>
<ul>
<li>能力要求：全栈 + Docker + K8S + Tensorflow + Spark</li>
<li>任务目标：搭建深度学习平台，开发深度学习算法</li>
<li>如果不甘心当个螺丝钉，为什么不来一起搞点事情呢？</li>
<li>联系方式：老读者都知道的，这里就不赘述了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刀光剑影不是我门派，天空海阔自有我风采。双手一推非黑也非白，不好也不坏，没有胜又何来败。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="转变" scheme="http://wdxtub.com/tags/%E8%BD%AC%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之数据科学】TensorFlow 学习笔记</title>
    <link href="http://wdxtub.com/2017/05/31/tensorflow-learning-note/"/>
    <id>http://wdxtub.com/2017/05/31/tensorflow-learning-note/</id>
    <published>2017-05-31T09:05:32.000Z</published>
    <updated>2017-07-08T23:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 开始更新</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>TensorFlow 是一个基于图计算的通用系统，常常被用于进行机器学习等任务。</p>
<p>TensorFlow 由<strong>张量</strong>(tensor)而得名，张量是多维的数组。一个向量是一维数组，我们称为一阶张量；一个矩阵是二维数组，我们称为二阶张量。名字中的 flow 表示计算的过程是基于图的，数据在图中流动。神经网络的训练和推断包含计算图中许多节点的矩阵计算的传播(propagation)</p>
<p>在 TensorFlow 中搞事的流程大概是：创建张量 -&gt; 添加计算操作 -&gt; 执行。很重要的一点是定义这些操作时，计算并不会立即执行，TensorFlow 在所有的操作添加完成后，会优化计算图，决定如何计算，最后才生成各种数据。正因如此，TensorFlow 中的 tensor 可以看作是一个占位符，等数据到来，然后执行计算。</p>
<p>我们来看看如何用 TensorFlow 做向量相加，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中的操作都需要在 Session 的上下文中进行，Session 本身保存计算图的信息（张量和操作）</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant([<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>])</div><div class="line">    input2 = tf.constant(<span class="number">2.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    input3 = tf.constant(<span class="number">3.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    output = tf.add(tf.add(input1, input2), input3)</div><div class="line">    <span class="comment"># 具体的计算在执行这一句时进行，因为 result 的值需要计算才可以得到，前面都是在定义计算图</span></div><div class="line">    result = output.eval()</div><div class="line">    print(<span class="string">"result: "</span>, result)</div></pre></td></tr></table></figure>
<p>处理完向量，我们来看看矩阵，其实也差不多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 矩阵相加</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant(<span class="number">1.0</span>, shape=[<span class="number">2</span>, <span class="number">3</span>])</div><div class="line">    input2 = tf.constant(np.reshape(np.arange(<span class="number">1.0</span>, <span class="number">7.0</span>, dtype=np.float32), (<span class="number">2</span>, <span class="number">3</span>)))</div><div class="line">    output = tf.add(input1, input2)</div><div class="line">    print(output.eval())</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input_features = tf.constant(np.reshape([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], (<span class="number">1</span>, <span class="number">4</span>)).astype(np.float32))</div><div class="line">    weights = tf.constant(np.random.randn(<span class="number">4</span>, <span class="number">2</span>).astype(np.float32))</div><div class="line">    output = tf.matmul(input_features, weights)</div><div class="line">    print(<span class="string">"Input:"</span>)</div><div class="line">    print(input_features.eval())</div><div class="line">    print(<span class="string">"Weights:"</span>)</div><div class="line">    print(weights.eval())</div><div class="line">    print(<span class="string">"Output:"</span>)</div><div class="line">    print(output.eval())</div></pre></td></tr></table></figure>
<p>前面我们都是用的 constant 常量，接下来我们搞一搞变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#@test &#123;"output": "ignore"&#125;</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置俩变量 total 和 weights，会不停变化</span></div><div class="line">    total = tf.Variable(tf.zeros([<span class="number">1</span>, <span class="number">2</span>]))</div><div class="line">    weights = tf.Variable(tf.random_uniform([<span class="number">1</span>,<span class="number">2</span>]))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化刚才定义的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 更新数值，但是这里并不会真的计算</span></div><div class="line">    update_weights = tf.assign(weigths, tf.random_uniform([<span class="number">1</span>, <span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</div><div class="line">    update_total = tf.assign(total, tf.add(total, weights))</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        <span class="comment"># 这里要先更新 weights 再更新 total</span></div><div class="line">        sess.run(update_weights)</div><div class="line">        sess.run(update_total)</div><div class="line">        </div><div class="line">        print(weights.eval(), total.eval())</div></pre></td></tr></table></figure>
<p>这里我们注意是先建模再计算这个流程即可。</p>
<h2 id="一个简单的神经网络"><a href="#一个简单的神经网络" class="headerlink" title="一个简单的神经网络"></a>一个简单的神经网络</h2><p>我们来构造一个非常简单的神经网络，来计算 x 和 y 这两个变量的线性回归。这个函数会为我们随机生成的带噪声的线性数据找到最合适的  $w_1$ 和 $w_2$，即满足 $y = w_2x+w_1$ 。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 设置带噪声的线性数据</span></div><div class="line">num_examples = <span class="number">50</span></div><div class="line"><span class="comment"># 这里会生成一个完全线性的数据</span></div><div class="line">X = np.array([np.linspace(<span class="number">-2</span>, <span class="number">4</span>, num_examples), np.linspace(<span class="number">-6</span>, <span class="number">6</span>, num_examples)])</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 这里给数据增加噪声</span></div><div class="line">X += np.random.randn(<span class="number">2</span>, num_examples)</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 我们的目标就是通过学习，找到一条拟合曲线，去还原最初的线性数据</span></div><div class="line"><span class="comment"># 把数据分离成 x 和 y</span></div><div class="line">x, y = X</div><div class="line"><span class="comment"># 添加固定为 1 的 bias</span></div><div class="line">x_with_bias = np.array([(<span class="number">1.</span>, a) <span class="keyword">for</span> a <span class="keyword">in</span> x]).astype(np.float32)</div><div class="line"></div><div class="line"><span class="comment"># 用来记录每次迭代的 loss，之后用于展示结果</span></div><div class="line">losses = []</div><div class="line"><span class="comment"># 迭代次数</span></div><div class="line">training_steps = <span class="number">50</span></div><div class="line"><span class="comment"># 学习率，也叫做步长，表示我们在梯度下降时每次迭代所前进的长度，过大则学不到准确的值，过小则训练太慢</span></div><div class="line">learning_rate = <span class="number">0.002</span></div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中所有的代码都需要在 session 中</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置所有的张量，变量和操作</span></div><div class="line">    <span class="comment"># 输入层是 x 值和 bias 节点</span></div><div class="line">    input = tf.constant(x_with_bias)</div><div class="line">    <span class="comment"># target 是 y 的值，需要被调整成正确的尺寸（就是转置一下）</span></div><div class="line">    target = tf.constant(np.transpose([y]).astype(np.float32))</div><div class="line">    <span class="comment"># weights 是变量，每次循环都会变，这里直接随机初始化（高斯分布，均值 0，标准差 0.1）</span></div><div class="line">    weights = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">1</span>], <span class="number">0</span>, <span class="number">0.1</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化所有的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 设置循环中所要做的全部操作</span></div><div class="line">    <span class="comment"># 对于所有的 x，根据现有的 weights 来产生对应的 y 值，也就是计算 y = w2 * x + w1 * bias</span></div><div class="line">    yhat = tf.matmul(input, weights)</div><div class="line">    <span class="comment"># 计算误差，也就是预计的 y 和真实的 y 的区别</span></div><div class="line">    yerror = tf.subtract(yhat, target)</div><div class="line">    <span class="comment"># 我们想要最小化 L2 损失，是误差的平方，会惩罚大误差，放过小误差</span></div><div class="line">    loss = tf.nn.l2_loss(yerror)</div><div class="line">    <span class="comment"># 上面的 loss 函数相当于</span></div><div class="line">    <span class="comment"># loss = 0.5 * tf.reduce_sum(tf.multiply(yerror, yerror))</span></div><div class="line">    </div><div class="line">    <span class="comment"># 执行梯度下降</span></div><div class="line">    <span class="comment"># 更新 weights，比如 weights += grads * learning_rate</span></div><div class="line">    <span class="comment"># 使用偏微分更新 weights</span></div><div class="line">    update_weights = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)</div><div class="line">    <span class="comment"># 上面的梯度下降相当于</span></div><div class="line">    <span class="comment"># gradient = tf.reduce_sum(tf.transpose(tf.multiply(input, yerror)), 1, keep_dims=True)</span></div><div class="line">    <span class="comment"># update_weights = tf.assign_sub(weights, learning_rate * gradient)</span></div><div class="line">    </div><div class="line">    <span class="comment"># 现在我们定义了所有的张量，也初始化了所有操作（每次执行梯度下降优化）</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(training_steps):</div><div class="line">        <span class="comment"># 重复跑，更新变量</span></div><div class="line">        update_weights.run()</div><div class="line">        <span class="comment"># 如果没有用 tf.train.GradientDescentOptimizer，就要用下面的方式</span></div><div class="line">        <span class="comment"># sess.run(update_weights)</span></div><div class="line">        </div><div class="line">        <span class="comment"># 记录每次迭代的 loss</span></div><div class="line">        losses.append(loss.eval())</div><div class="line">    </div><div class="line">    <span class="comment"># 训练结束</span></div><div class="line">    betas = weights.eval()</div><div class="line">    yhat = yhat.eval()</div><div class="line"></div><div class="line"><span class="comment"># 展示训练趋势</span></div><div class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">plt.subplots_adjust(wspace=<span class="number">.3</span>)</div><div class="line">fig.set_size_inches(<span class="number">10</span>, <span class="number">4</span>)</div><div class="line">ax1.scatter(x, y, alpha=<span class="number">.7</span>)</div><div class="line">ax1.scatter(x, np.transpose(yhat)[<span class="number">0</span>], c=<span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">line_x_range = (<span class="number">-4</span>, <span class="number">6</span>)</div><div class="line">ax1.plot(line_x_range, [betas[<span class="number">0</span>] + a * betas[<span class="number">1</span>] <span class="keyword">for</span> a <span class="keyword">in</span> line_x_range], <span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">ax2.plot(range(<span class="number">0</span>, training_steps), losses)</div><div class="line">ax2.set_ylabel(<span class="string">"Loss"</span>)</div><div class="line">ax2.set_xlabel(<span class="string">"Training steps"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="从零开始上手-MNIST-数据集"><a href="#从零开始上手-MNIST-数据集" class="headerlink" title="从零开始上手 MNIST 数据集"></a>从零开始上手 MNIST 数据集</h2><p>这是 Tensorflow 官方 Docker 镜像中的最后一篇教程，主要介绍如何利用 tf 完成手写数字的识别，这里我把 jupyter 的代码稍加改动（并加了些注释），方便大家在本地使用。</p>
<p>注：详细的解释都在注释里了，这里就不再赘述。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> gzip, binascii, struct, numpy</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> six.moves.urllib.request <span class="keyword">import</span> urlretrieve</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># 这里需要翻墙，不然下载巨慢</span></div><div class="line">SOURCE_URL = <span class="string">'http://yann.lecun.com/exdb/mnist/'</span></div><div class="line">WORK_DIRECTORY = <span class="string">"./mnist-data"</span></div><div class="line"></div><div class="line"><span class="comment"># 如果下载好了，那么就不会再次下载</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybe_download</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">"""A helper to download the data files if not present."""</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(WORK_DIRECTORY):</div><div class="line">        os.mkdir(WORK_DIRECTORY)</div><div class="line">    filepath = os.path.join(WORK_DIRECTORY, filename)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath):</div><div class="line">        filepath, _ = urlretrieve(SOURCE_URL + filename, filepath)</div><div class="line">        statinfo = os.stat(filepath)</div><div class="line">        print(<span class="string">'Successfully downloaded'</span>, filename, statinfo.st_size, <span class="string">'bytes.'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Already downloaded'</span>, filename)</div><div class="line">    <span class="keyword">return</span> filepath</div><div class="line"></div><div class="line"><span class="comment"># 这里把所有的训练数据都搞下来</span></div><div class="line">train_data_filename = maybe_download(<span class="string">'train-images-idx3-ubyte.gz'</span>)</div><div class="line">train_labels_filename = maybe_download(<span class="string">'train-labels-idx1-ubyte.gz'</span>)</div><div class="line">test_data_filename = maybe_download(<span class="string">'t10k-images-idx3-ubyte.gz'</span>)</div><div class="line">test_labels_filename = maybe_download(<span class="string">'t10k-labels-idx1-ubyte.gz'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 如果遇到 MacOS 的 Python as a framework 的问题，参考</span></div><div class="line"><span class="comment"># https://stackoverflow.com/questions/29433824/unable-to-import-matplotlib-pyplot-as-plt-in-virtualenv</span></div><div class="line"><span class="comment"># 这里我们先看看数据集里有什么，只是一个展示，并不会对图片进行预处理</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sanity_check</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_data_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'image count'</span>, <span class="string">'rows'</span>, <span class="string">'columns'</span>]:</div><div class="line">            <span class="comment"># struct.unpack reads the binary data provided by f.read.</span></div><div class="line">            <span class="comment"># The format string '&gt;i' decodes a big-endian integer, which</span></div><div class="line">            <span class="comment"># is the encoding of the data.</span></div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        <span class="comment"># Read the first 28x28 set of pixel values. </span></div><div class="line">        <span class="comment"># Each pixel is one byte, [0, 255], a uint8.</span></div><div class="line">        buf = f.read(<span class="number">28</span> * <span class="number">28</span>)</div><div class="line">        image = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    </div><div class="line">        <span class="comment"># Print the first few values of image.</span></div><div class="line">        print(<span class="string">'First 10 pixels:'</span>, image[:<span class="number">10</span>])</div><div class="line"></div><div class="line">        <span class="comment"># We'll show the image and its pixel value histogram side-by-side.</span></div><div class="line">        <span class="comment"># 输出原始图片和直方图，来看看具体的样子</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># To interpret the values as a 28x28 image, we need to reshape</span></div><div class="line">        <span class="comment"># the numpy array, which is one dimensional.</span></div><div class="line">        ax1.imshow(image.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(image, bins=<span class="number">20</span>, range=[<span class="number">0</span>,<span class="number">255</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里是把 [0, 255] 映射到 [-0.5, 0.5] 之后的展示</span></div><div class="line">        <span class="comment"># Let's convert the uint8 image to 32 bit floats and rescale </span></div><div class="line">        <span class="comment"># the values to be centered around 0, between [-0.5, 0.5]. </span></div><div class="line">        <span class="comment"># </span></div><div class="line">        <span class="comment"># We again plot the image and histogram to check that we </span></div><div class="line">        <span class="comment"># haven't mangled the data.</span></div><div class="line">        scaled = image.astype(numpy.float32)</div><div class="line">        scaled = (scaled - (<span class="number">255</span> / <span class="number">2.0</span>)) / <span class="number">255</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        ax1.imshow(scaled.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(scaled, bins=<span class="number">20</span>, range=[<span class="number">-0.5</span>, <span class="number">0.5</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里读取 Label，也是一个测试而已</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_labels_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'label count'</span>]:</div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line"></div><div class="line">        print(<span class="string">'First label:'</span>, struct.unpack(<span class="string">'B'</span>, f.read(<span class="number">1</span>))[<span class="number">0</span>]) </div><div class="line"></div><div class="line"><span class="comment"># 简单显示一下，然后进行之后的步骤</span></div><div class="line">sanity_check()</div><div class="line"></div><div class="line"><span class="comment"># 处理图片数据</span></div><div class="line">IMAGE_SIZE = <span class="number">28</span></div><div class="line">PIXEL_DEPTH = <span class="number">255</span></div><div class="line"></div><div class="line"><span class="comment"># 这个函数会提取并处理数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_data</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the images into a 4D tensor [image index, y, x, channels].</span></div><div class="line">  </div><div class="line">    For MNIST data, the number of channels is always 1.</div><div class="line"></div><div class="line">    Values are rescaled from [0, 255] down to [-0.5, 0.5].</div><div class="line">    """</div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and dimensions; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">16</span>)</div><div class="line"></div><div class="line">        buf = bytestream.read(IMAGE_SIZE * IMAGE_SIZE * num_images)</div><div class="line">        data = numpy.frombuffer(buf, dtype=numpy.uint8).astype(numpy.float32)</div><div class="line">        data = (data - (PIXEL_DEPTH / <span class="number">2.0</span>)) / PIXEL_DEPTH</div><div class="line">        data = data.reshape(num_images, IMAGE_SIZE, IMAGE_SIZE, <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> data</div><div class="line"></div><div class="line">train_data = extract_data(train_data_filename, <span class="number">60000</span>)</div><div class="line">test_data = extract_data(test_data_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这里把处理后的输出展示下</span></div><div class="line">print(<span class="string">'Training data shape'</span>, train_data.shape)</div><div class="line">_, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">ax1.imshow(train_data[<span class="number">0</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">ax2.imshow(train_data[<span class="number">1</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">plt.show()</div><div class="line"></div><div class="line"><span class="comment"># 接下来处理标签，我们需要把类别处理成向量，如果是第二类，那么对应 [0,1,0,...,0]，即第二个位置为 1</span></div><div class="line">NUM_LABELS = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_labels</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the labels into a 1-hot matrix [image index, label index]."""</span></div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and count; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">8</span>)</div><div class="line">        buf = bytestream.read(<span class="number">1</span> * num_images)</div><div class="line">        labels = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    <span class="comment"># Convert to dense 1-hot representation.</span></div><div class="line">    <span class="keyword">return</span> (numpy.arange(NUM_LABELS) == labels[:, <span class="keyword">None</span>]).astype(numpy.float32)</div><div class="line"></div><div class="line">train_labels = extract_labels(train_labels_filename, <span class="number">60000</span>)</div><div class="line">test_labels = extract_labels(test_labels_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 同样测试一下数据</span></div><div class="line">print(<span class="string">'Training labels shape'</span>, train_labels.shape)</div><div class="line">print(<span class="string">'First label vector'</span>, train_labels[<span class="number">0</span>])</div><div class="line">print(<span class="string">'Second label vector'</span>, train_labels[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 这里我们把数据分成训练、测试和验证集</span></div><div class="line">VALIDATION_SIZE = <span class="number">5000</span></div><div class="line"></div><div class="line">validation_data = train_data[:VALIDATION_SIZE, :, :, :]</div><div class="line">validation_labels = train_labels[:VALIDATION_SIZE]</div><div class="line">train_data = train_data[VALIDATION_SIZE:, :, :, :]</div><div class="line">train_labels = train_labels[VALIDATION_SIZE:]</div><div class="line"></div><div class="line">train_size = train_labels.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(<span class="string">'Validation shape'</span>, validation_data.shape)</div><div class="line">print(<span class="string">'Train size'</span>, train_size)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 这里开始定义模型</span></div><div class="line"><span class="comment"># 从原始输入开始，进行卷积(convolution)和池化(max pooling)处理，在全连接层之前会用 ReLU </span></div><div class="line"><span class="comment"># 作为激活函数，最后用 softmax 来处理输出，把类别信息转化成概率，训练的时候使用 Dropout</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># 准备模型可以分三步</span></div><div class="line"><span class="comment"># 1. 定义变量，来保存我们要训练的权重 weights</span></div><div class="line"><span class="comment"># 2. 定义模型的图结构</span></div><div class="line"><span class="comment"># 3. 把模型的图分别用于训练、测试和验证（复制几份）</span></div><div class="line"></div><div class="line"><span class="comment"># 先处理好变量</span></div><div class="line"><span class="comment"># 从效率的角度考虑，我们会把样本分组，这里是一个组的样本数量</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"><span class="comment"># 因为是灰度图，所以只有一个通道 channel</span></div><div class="line">NUM_CHANNELS = <span class="number">1</span></div><div class="line"><span class="comment"># 固定随机种子，保证每次的结果一致（不然没办法验证数据和模型）</span></div><div class="line">SEED = <span class="number">42</span></div><div class="line"></div><div class="line"><span class="comment"># 我们在这里把训练数据和类别标签『喂』给模型，不过这里只是一个占位符(placeholder)</span></div><div class="line"><span class="comment"># 真正训练的时候，这些节点在每一步会获取批量数据</span></div><div class="line">train_data_node = tf.placeholder(</div><div class="line">  tf.float32,</div><div class="line">  shape=(BATCH_SIZE, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS))</div><div class="line">train_labels_node = tf.placeholder(tf.float32,</div><div class="line">                                   shape=(BATCH_SIZE, NUM_LABELS))</div><div class="line"></div><div class="line"><span class="comment"># 对于验证和测试数据，直接保存到一个常量节点里即可（不存在训练的过程，不需要是变量）</span></div><div class="line">validation_data_node = tf.constant(validation_data)</div><div class="line">test_data_node = tf.constant(test_data)</div><div class="line"></div><div class="line"><span class="comment"># 下面的变量保存着所有的需要训练的权重。后面的参数定义了这些变量的初始化条件</span></div><div class="line"><span class="comment"># 用高斯分布初始化卷积的 weights</span></div><div class="line">conv1_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, NUM_CHANNELS, <span class="number">32</span>],  <span class="comment"># 5x5 filter, depth 32.</span></div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 初始的 bias 为 0</span></div><div class="line">conv1_biases = tf.Variable(tf.zeros([<span class="number">32</span>]))</div><div class="line"><span class="comment"># 第二层的卷积权重，32 个输入（对应上面的 32），然后下面是 64 维</span></div><div class="line">conv2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 同理，bias 也是 64 维，但是这里用 0.1</span></div><div class="line">conv2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">64</span>]))</div><div class="line"><span class="comment"># 然后是一个全连接的网络，共 512 维，为什么呢，因为我们有卷积和池化的存在，所以是 32*64/4</span></div><div class="line"><span class="comment"># (?这里我也不是很确定)</span></div><div class="line">fc1_weights = tf.Variable(  <span class="comment"># fully connected, depth 512.</span></div><div class="line">  tf.truncated_normal([IMAGE_SIZE // <span class="number">4</span> * IMAGE_SIZE // <span class="number">4</span> * <span class="number">64</span>, <span class="number">512</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc1_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">512</span>]))</div><div class="line">fc2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">512</span>, NUM_LABELS],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[NUM_LABELS]))</div><div class="line"></div><div class="line">print(<span class="string">'变量设置完毕'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义好了各种需要训练的变量，我们可以在 TensorFlow 图中把这些变量连起来了</span></div><div class="line"><span class="comment"># 这里我们用一个函数来返回我们需要的 tf graph，这里有一个参数来控制是训练还是其他</span></div><div class="line"><span class="comment"># 如果是训练，我们需要使用 dropout</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(data, train=False)</span>:</span></div><div class="line">    <span class="string">"""模型定义"""</span></div><div class="line">    <span class="comment"># 2D 卷积，使用相同 padding，意思是输入的 feature 大小和输出的一致，</span></div><div class="line">    <span class="comment"># strides 是一个四维数组 [image index, y, x, depth]</span></div><div class="line">    conv = tf.nn.conv2d(data,</div><div class="line">                        conv1_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 对卷积和偏置做 ReLU 操作</span></div><div class="line">    <span class="comment"># Bias and rectified linear non-linearity.</span></div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv1_biases))</div><div class="line"></div><div class="line">    <span class="comment"># 池化，这里我们的 pooling window 是 2，每个 stride 是 2</span></div><div class="line">    <span class="comment"># Max pooling. The kernel size spec ksize also follows the layout of</span></div><div class="line">    <span class="comment"># the data. Here we have a pooling window of 2, and a stride of 2.</span></div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line">    conv = tf.nn.conv2d(pool,</div><div class="line">                        conv2_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv2_biases))</div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 把 feature map 转为 2D 矩阵，并传给全连接网络</span></div><div class="line">    pool_shape = pool.get_shape().as_list()</div><div class="line">    reshape = tf.reshape(</div><div class="line">        pool,</div><div class="line">        [pool_shape[<span class="number">0</span>], pool_shape[<span class="number">1</span>] * pool_shape[<span class="number">2</span>] * pool_shape[<span class="number">3</span>]])</div><div class="line">  </div><div class="line">    <span class="comment"># Fully connected layer. Note that the '+' operation automatically</span></div><div class="line">    <span class="comment"># broadcasts the biases.</span></div><div class="line">    hidden = tf.nn.relu(tf.matmul(reshape, fc1_weights) + fc1_biases)</div><div class="line"></div><div class="line">    <span class="comment"># Add a 50% dropout during training only. Dropout also scales</span></div><div class="line">    <span class="comment"># activations such that no rescaling is needed at evaluation time.</span></div><div class="line">    <span class="keyword">if</span> train:</div><div class="line">        hidden = tf.nn.dropout(hidden, <span class="number">0.5</span>, seed=SEED)</div><div class="line">    <span class="keyword">return</span> tf.matmul(hidden, fc2_weights) + fc2_biases</div><div class="line"></div><div class="line"><span class="comment"># 定义了图的基本结构，我们就可以分别为 训练、测试和验证来提取模型了（也会根据不同的类型做一些自定义）</span></div><div class="line"><span class="comment"># train_prediction 保存训练的图，使用 cross-entropy loss 和 weight regularization</span></div><div class="line"><span class="comment"># 我们也会在训练的过程中调整学习率（通过 exponential_decay 操作来完成，会使用 MomentumOptimizer）</span></div><div class="line"></div><div class="line"><span class="comment"># 验证和测试的图比较简单，我们只需要使用验证和测试集作为输入，用 softmax 分类器作为输出</span></div><div class="line"></div><div class="line"><span class="comment"># 训练的计算</span></div><div class="line"><span class="comment"># Training computation: logits + cross-entropy loss.</span></div><div class="line">logits = model(train_data_node, <span class="keyword">True</span>)</div><div class="line">loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(</div><div class="line">  labels=train_labels_node, logits=logits))</div><div class="line"></div><div class="line"><span class="comment"># L2 正则化</span></div><div class="line"><span class="comment"># L2 regularization for the fully connected parameters.</span></div><div class="line">regularizers = (tf.nn.l2_loss(fc1_weights) + tf.nn.l2_loss(fc1_biases) +</div><div class="line">                tf.nn.l2_loss(fc2_weights) + tf.nn.l2_loss(fc2_biases))</div><div class="line"><span class="comment"># Add the regularization term to the loss.</span></div><div class="line">loss += <span class="number">5e-4</span> * regularizers</div><div class="line"></div><div class="line"><span class="comment"># Optimizer: set up a variable that's incremented once per batch and</span></div><div class="line"><span class="comment"># controls the learning rate decay.</span></div><div class="line">batch = tf.Variable(<span class="number">0</span>)</div><div class="line"><span class="comment"># Decay once per epoch, using an exponential schedule starting at 0.01.</span></div><div class="line">learning_rate = tf.train.exponential_decay(</div><div class="line">  <span class="number">0.01</span>,                <span class="comment"># Base learning rate.</span></div><div class="line">  batch * BATCH_SIZE,  <span class="comment"># Current index into the dataset.</span></div><div class="line">  train_size,          <span class="comment"># Decay step.</span></div><div class="line">  <span class="number">0.95</span>,                <span class="comment"># Decay rate.</span></div><div class="line">  staircase=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># Use simple momentum for the optimization.</span></div><div class="line">optimizer = tf.train.MomentumOptimizer(learning_rate,</div><div class="line">                                       <span class="number">0.9</span>).minimize(loss,</div><div class="line">                                                     global_step=batch)</div><div class="line"></div><div class="line"><span class="comment"># Predictions for the minibatch, validation set and test set.</span></div><div class="line">train_prediction = tf.nn.softmax(logits)</div><div class="line"><span class="comment"># We'll compute them only once in a while by calling their &#123;eval()&#125; method.</span></div><div class="line">validation_prediction = tf.nn.softmax(model(validation_data_node))</div><div class="line">test_prediction = tf.nn.softmax(model(test_data_node))</div><div class="line"></div><div class="line"><span class="comment"># 准备好了训练、测试和验证的模型之后，我们就可以来真正执行训练了。</span></div><div class="line"><span class="comment"># 所有的操作都需要在 session 中，在 python 中像是</span></div><div class="line"><span class="comment"># with tf.Session() as s:</span></div><div class="line"><span class="comment"># ...training / test / evaluation loop...</span></div><div class="line"></div><div class="line"><span class="comment"># 但是我们这里想要保持 session 方便我们去探索训练的过程，使用 InteractiveSession</span></div><div class="line"></div><div class="line"><span class="comment"># 我们先创建一个 session 并初始化我们刚才定义的变量</span></div><div class="line">s = tf.InteractiveSession()</div><div class="line"></div><div class="line"><span class="comment"># Use our newly created session as the default for subsequent operations.</span></div><div class="line">s.as_default()</div><div class="line"></div><div class="line"><span class="comment"># 初始化刚才定义的变量</span></div><div class="line">tf.global_variables_initializer().run()</div><div class="line"></div><div class="line"><span class="comment"># 我们现在可以开始训练了，这里我们用 minibatch 的方法（而不是一次只训练一个样本）</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"></div><div class="line"><span class="comment"># 提取第一个 batch 的数据和标签</span></div><div class="line"><span class="comment"># Grab the first BATCH_SIZE examples and labels.</span></div><div class="line">batch_data = train_data[:BATCH_SIZE, :, :, :]</div><div class="line">batch_labels = train_labels[:BATCH_SIZE]</div><div class="line"></div><div class="line"><span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line"><span class="comment"># node in the graph it should be fed to.</span></div><div class="line">feed_dict = &#123;train_data_node: batch_data,</div><div class="line">             train_labels_node: batch_labels&#125;</div><div class="line"></div><div class="line"><span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">_, l, lr, predictions = s.run(</div><div class="line">  [optimizer, loss, learning_rate, train_prediction],</div><div class="line">  feed_dict=feed_dict)</div><div class="line"></div><div class="line">print(predictions[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="comment"># The highest probability in the first entry.</span></div><div class="line">print(<span class="string">'First prediction'</span>, numpy.argmax(predictions[<span class="number">0</span>]))</div><div class="line"></div><div class="line"><span class="comment"># But, predictions is actually a list of BATCH_SIZE probability vectors.</span></div><div class="line">print(predictions.shape)</div><div class="line"></div><div class="line"><span class="comment"># So, we'll take the highest probability for each vector.</span></div><div class="line">print(<span class="string">'All predictions'</span>, numpy.argmax(predictions, <span class="number">1</span>))</div><div class="line"></div><div class="line">print(<span class="string">'Batch labels'</span>, numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"></div><div class="line">correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line">total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(float(correct) / float(total))</div><div class="line"></div><div class="line">confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"><span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">  confusions[predicted, actual] += <span class="number">1</span></div><div class="line"></div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_rate</span><span class="params">(predictions, labels)</span>:</span></div><div class="line">    <span class="string">"""Return the error rate and confusions."""</span></div><div class="line">    correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">    error = <span class="number">100.0</span> - (<span class="number">100</span> * float(correct) / float(total))</div><div class="line"></div><div class="line">    confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">    bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    <span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">        confusions[predicted, actual] += <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> error, confusions</div><div class="line"></div><div class="line"><span class="comment"># 这里训练 n 轮，每轮都是 minibatch</span></div><div class="line">train_round = <span class="number">3</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_round):</div><div class="line">    print(<span class="string">"Training Round "</span>, i+<span class="number">1</span> )</div><div class="line">    <span class="comment"># Train over the first 1/4th of our training set.</span></div><div class="line">    steps = train_size // BATCH_SIZE</div><div class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</div><div class="line">        <span class="comment"># Compute the offset of the current minibatch in the data.</span></div><div class="line">        <span class="comment"># Note that we could use better randomization across epochs.</span></div><div class="line">        offset = (step * BATCH_SIZE) % (train_size - BATCH_SIZE)</div><div class="line">        batch_data = train_data[offset:(offset + BATCH_SIZE), :, :, :]</div><div class="line">        batch_labels = train_labels[offset:(offset + BATCH_SIZE)]</div><div class="line">        <span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line">        <span class="comment"># node in the graph it should be fed to.</span></div><div class="line">        feed_dict = &#123;train_data_node: batch_data,</div><div class="line">                    train_labels_node: batch_labels&#125;</div><div class="line">        <span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">        _, l, lr, predictions = s.run(</div><div class="line">        [optimizer, loss, learning_rate, train_prediction],</div><div class="line">        feed_dict=feed_dict)</div><div class="line">        </div><div class="line">        <span class="comment"># Print out the loss periodically.</span></div><div class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            error, _ = error_rate(predictions, batch_labels)</div><div class="line">            print(<span class="string">'Step %d of %d'</span> % (step, steps))</div><div class="line">            print(<span class="string">'Mini-batch loss: %.5f Error: %.5f Learning rate: %.5f'</span> % (l, error, lr))</div><div class="line">            print(<span class="string">'Validation error: %.1f%%'</span> % error_rate(</div><div class="line">                validation_prediction.eval(), validation_labels)[<span class="number">0</span>])</div><div class="line"></div><div class="line">test_error, confusions = error_rate(test_prediction.eval(), test_labels)</div><div class="line">print(<span class="string">'Test error: %.1f%%'</span> % test_error)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'Actual'</span>)</div><div class="line">plt.ylabel(<span class="string">'Predicted'</span>)</div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, cas <span class="keyword">in</span> enumerate(confusions):</div><div class="line">    <span class="keyword">for</span> j, count <span class="keyword">in</span> enumerate(cas):</div><div class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</div><div class="line">            xoff = <span class="number">.07</span> * len(str(count))</div><div class="line">            plt.text(j-xoff, i+<span class="number">.2</span>, int(count), fontsize=<span class="number">9</span>, color=<span class="string">'white'</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.hist(numpy.argmax(test_labels, <span class="number">1</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="官方文档阅读笔记"><a href="#官方文档阅读笔记" class="headerlink" title="官方文档阅读笔记"></a>官方文档阅读笔记</h2><p>使用 TensorFlow，你必须明白 TensorFlow</p>
<ul>
<li>使用<strong>图</strong>(graph)来表示计算任务</li>
<li>在被称之为<strong>会话</strong>(Session)的<strong>上下文</strong>(context)中执行图</li>
<li>使用 tensor 表示数据</li>
<li>通过<strong>变量</strong>(Variable)维护状态</li>
<li>使用 feed 和 fetch 可以为<strong>任意的操作</strong>(arbitrary operation)赋值或者从其中获取数据</li>
</ul>
<p>TensorFlow 是一个编程系统，使用图来表示计算任务。图中的节点被称之为 op (operation 的缩写)。一个 op 获得 0 个或多个 Tensor，执行计算，产生 0 个或多个 Tensor。每个 Tensor 是一个类型化的多维数组。例如，你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是 <code>[batch, height, width, channels]</code>。</p>
<p>一个 TensorFlow 图描述了计算的过程。为了进行计算，图必须在<strong>会话</strong>里被启动。<strong>会话</strong>将图的 op 分发到诸如 CPU 或 GPU 之类的设备上，同时提供执行 op 的方法。这些方法执行后，将产生的 tensor 返回。在 Python 语言中, 返回的 tensor 是 numpy ndarray 对象；在 C 和 C++ 语言中，返回的 tensor 是 <code>tensorflow::Tensor</code> 实例。</p>
<ul>
<li>计算图<ul>
<li>TensorFlow 程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，op 的执行步骤被描述成一个图。在执行阶段，使用会话执行执行图中的 op。例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练 op。</li>
<li>TensorFlow 支持 C, C++, Python 编程语言。目前，TensorFlow 的 Python 库更加易用，它提供了大量的辅助函数来简化构建图的工作，这些函数尚未被 C 和 C++ 库支持.</li>
<li>三种语言的会话库 (session libraries) 是一致的。</li>
</ul>
</li>
<li>构建图<ul>
<li>构建图的第一步，是创建源 op (source op)。源 op 不需要任何输入，例如<strong>常量</strong>(Constant)。源 op 的输出被传递给其它 op 做运算</li>
<li>Python 库中，op 构造器的返回值代表被构造出的 op 的输出，这些返回值可以传递给其它 op 构造器作为输入</li>
<li>TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了</li>
</ul>
</li>
</ul>
<p>在实现上，TensorFlow 将图形定义转换成分布式执行的操作，以充分利用可用的计算资源(如 CPU 或 GPU). 一般你不需要显式指定使用 CPU 还是 GPU，TensorFlow 能自动检测。如果检测到 GPU，TensorFlow 会尽可能地利用找到的第一个 GPU 来执行操作。</p>
<p>如果机器上有超过一个可用的 GPU，除第一个外的其它 GPU 默认是不参与计算的。为了让 TensorFlow 使用这些 GPU，你必须将 op 明确指派给它们执行。<code>with...Device</code> 语句用来指派特定的 CPU 或 GPU 执行操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">  <span class="keyword">with</span> tf.device(<span class="string">"/gpu:1"</span>):</div><div class="line">    matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</div><div class="line">    matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</div><div class="line">    product = tf.matmul(matrix1, matrix2)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>设备用字符串进行标识。目前支持的设备包括:</p>
<ul>
<li>“/cpu:0”: 机器的 CPU</li>
<li>“/gpu:0”: 机器的第一个 GPU，如果有的话</li>
<li>“/gpu:1”: 机器的第二个 GPU，以此类推</li>
</ul>
<p>具体可见 <a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/how_tos/using_gpu.html" target="_blank" rel="external">使用 GPUs</a></p>
<p>文档的其他部分涉及到具体的算法细节，这里不再深究。</p>
<h2 id="GPU-相关"><a href="#GPU-相关" class="headerlink" title="GPU 相关"></a>GPU 相关</h2><ul>
<li>最合适测试 CUDA 的代码是使用 <code>log_device_placement</code> 参数<ul>
<li><code>sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))</code></li>
<li><code>print sess.run(c)</code></li>
<li>观察日志输出是否有 gpu0, gpu1</li>
</ul>
</li>
<li>检测 GPU 的使用率 <code>nvidia-smi -q -g 0 -d UTILIZATION -1</code></li>
<li><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Nvidia Docker</a><ul>
<li>TODO 需要看如何配置 docker 所能分配的 gpu</li>
</ul>
</li>
<li>tensorflow 在训练时默认占用所有 GPU 的显存，配置的方式有<ul>
<li>构造 <code>tf.Session()</code> 时配置参数（这里是按照百分比来选择），如<ul>
<li><code>gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.333)</code></li>
<li><code>sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</code></li>
<li><code>per_process_gpu_memory_fraction</code> 指定每个 GPU 进程中使用显存的上限，但只能作用于所有 GPU，不能根据不同 GPU 单独配置</li>
</ul>
</li>
<li>设置显存根据需求增长<ul>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.allow_growth=True</code></li>
<li><code>sess = tf.Session(config=config)</code></li>
</ul>
</li>
<li>在执行训练脚本前使用 <code>export CUDA_VISIBLE_DEVICES=1</code> 来限制可见的 GPU 数目，如果是 python 脚本，可以用 <code>CUDA_VISIBLE_DEVICES=1 python my_script.py</code>，如果想用两个卡，则是 <code>CUDA_VISIBLE_DEVICES=0,1</code>，如果禁用 GPU，则是 <code>CUDA_VISIBLE_DEVICES=&quot;&quot;</code><ul>
<li>可以参考 <a href="https://stackoverflow.com/questions/34775522/tensorflow-mutiple-sessions-with-mutiple-gpus" target="_blank" rel="external">Tensorflow multiple sessions with multiple GPUs</a></li>
</ul>
</li>
<li>也可以在 Python 代码中进行设置<ul>
<li><code>import os</code></li>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;</code></li>
</ul>
</li>
<li>如果需要同时限制显存大小，也按需增长，那么可以这样<ul>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0&#39;</code> 指定第一块 GPU 可用</li>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.per_process_gpu_memory_fraction = 0.5</code> 最多只能占用指定 gpu 50% 显存</li>
<li><code>config.gpu_options.allow_growth = True</code> 程序按需申请内存</li>
<li><code>sess = tf.Session(config = config)</code></li>
</ul>
</li>
<li>需要注意的是，虽然代码或配置层面设置了对显存占用百分比阈值，但实际中如果达到了，程序有需要的话还是会突破的，以上的显存限制仅仅为了跑小数据集时避免对显存的浪费</li>
</ul>
</li>
</ul>
<h2 id="Nvidia-Docker"><a href="#Nvidia-Docker" class="headerlink" title="Nvidia Docker"></a>Nvidia Docker</h2><ul>
<li><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Github</a></p>
</li>
<li><p>在 Nvidia Docker 层限制 GPU 资源</p>
<ul>
<li><code>NV_GPU=0,1 nvidia-docker run -it nvidia/cuda nvidia-smi</code></li>
<li>弄清楚 <code>nvidia_uvm</code> 是个啥</li>
<li><code>nvidia-docker</code> 相当于 <code>docker run --device=/dev/nvidiactl --device=/dev/nvidia-utm --device=/dev/nvidia0</code></li>
</ul>
</li>
<li>可以做到资源隔离，具体要测试下，看看提供了什么工具</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/Machine-Learning-Project" target="_blank" rel="external">项目源代码</a></li>
<li><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="external">TensorFlow 官方文档中文版（比较老）</a></li>
<li><a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">Awesome TensorFlow</a></li>
<li><a href="https://github.com/fluxcapacitor/pipeline" target="_blank" rel="external">PipelineIO - 收费</a></li>
<li><a href="https://github.com/polyaxon/polyaxon" target="_blank" rel="external">Polyaxon</a></li>
<li><a href="http://www.cnblogs.com/darkknightzh/p/6591923.html" target="_blank" rel="external">http://www.cnblogs.com/darkknightzh/p/6591923.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23250782" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23250782</a></li>
<li><a href="http://www.cnblogs.com/wangxiaocvpr/p/5902086.html" target="_blank" rel="external">http://www.cnblogs.com/wangxiaocvpr/p/5902086.html</a></li>
<li><a href="http://blog.csdn.net/luodongri/article/details/52596780" target="_blank" rel="external">http://blog.csdn.net/luodongri/article/details/52596780</a></li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="http://wdxtub.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>【科学革命的结构】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/"/>
    <id>http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/</id>
    <published>2017-05-30T23:32:11.000Z</published>
    <updated>2017-05-31T00:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这本书主要是强调范式对于科学的指导作用</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 完成初稿</li>
</ul>
<h2 id="历史的作用"><a href="#历史的作用" class="headerlink" title="历史的作用"></a>历史的作用</h2><p>如果我们主要是寻求和考察那些从科学教科书中得出的、不含历史的旧规老套的问题的回答贰继续使用历史资料的话，那么，新科学观就不可能从历史中产生。</p>
<h2 id="通向常规科学之路"><a href="#通向常规科学之路" class="headerlink" title="通向常规科学之路"></a>通向常规科学之路</h2><p>在本书中，『常规科学』是指坚实地建立在一种或多种过去科学成就基础上的研究，这些科学成就为某个学科共同体在一段时期内公认为是进一步实践的基础。这些著作之所以能起到这样的做用，就在于它们共同具有两个基本特征：</p>
<ul>
<li>它们的成就空前地吸引一批坚定的拥护者，使他们脱离科学活动的其他竞争形式。</li>
<li>这些成就足以无限制地为重新组成的一批实践者留下有待解决的种种问题</li>
</ul>
<p>凡是共有这两个特征的成就，我此后便称之为『范式』，这是一个与『常规科学』密切有关的术语。</p>
<p>一种范式通过革命向另一种范式的过渡便是成熟科学通常的发展模式。</p>
<h2 id="常规科学的本质"><a href="#常规科学的本质" class="headerlink" title="常规科学的本质"></a>常规科学的本质</h2><p>如果不是一门成熟科学的实际实践者，就很少有人会认识到一种范式给人们留下非常多的扫尾工作要做，而完成这些扫尾工作又是多么地令人迷醉。这两个要点人们必须理解到。大多数科学家倾其全部科学生涯所从事的正是这些扫尾工作。这些工作构成了我在这里所称的常规科学。</p>
<h2 id="常规科学即是解谜"><a href="#常规科学即是解谜" class="headerlink" title="常规科学即是解谜"></a>常规科学即是解谜</h2><p>一个科学家必须致力于理解世界，并扩展这种使世界有序化的精度和广度。这种承诺反过来又必定会导致科学家自己或他的同事以丰富的经验细致地考察自然界的某个方面。如果这种考察发现明显的无序(disorder)，那就迫使他精练他的观测技巧，或者迫使他进一步阐明他的理论。</p>
<p>常规科学是一种高度确定性的活动，但它又不必要完全由规则所确定。这就是为什么在本文开始时我引进共有范式而不用共有规则、假定和观点作为常规研究传统连贯性源泉的原因。我认为，规则导源于范式，但即使没有规则，范式仍能指导研究。</p>
<h2 id="反常与科学发现的突破"><a href="#反常与科学发现的突破" class="headerlink" title="反常与科学发现的突破"></a>反常与科学发现的突破</h2><p>在任何一门科学的发展过程中，最先接受的范式，通常会让人感觉到它对于科学研究者容易理解的大多数观察和实验，能给予相当成功的说明。因此，进一步的发展通产高要求建构精巧的装置，发展出一套深奥的词汇和技巧，精练概念，使之不断地减少与它们通常的常识原型(prototypes)之间的相似性。</p>
<h2 id="科学革命的本质与必然性"><a href="#科学革命的本质与必然性" class="headerlink" title="科学革命的本质与必然性"></a>科学革命的本质与必然性</h2><p>科学革命也起源于科学共同体中某一小部分人逐渐感觉到：他们无法利用现有范式有效地探究自然界的某一方面，而以前范式在这方面的研究是起引导作用的。</p>
<p>原则上，只有三类现象可以引发新理论。第一类是那些现存范式已妥为解释的现象，但它们很少成为科学家创建新理论的动机或出发点。第二类现象是指那些其本质已为现有范式所表明，但其细节的理解却有待范式的完善的现象，它们是科学家常规研究的对象。但是这种研究的目的在于完善现有范式，而非发明新范式。只有当这种完善工作失败后，科学家才会遭遇第三类现象，即公认的反常现象，其特征是无法被现有范式同化。只有这类现象才会促成新理论的发明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书主要是强调范式对于科学的指导作用&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="读书" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="科学" scheme="http://wdxtub.com/tags/%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【别让我思考】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/30/dont-make-me-think-clip/"/>
    <id>http://wdxtub.com/2017/05/30/dont-make-me-think-clip/</id>
    <published>2017-05-30T08:45:46.000Z</published>
    <updated>2017-07-04T07:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.30: 完成初稿</li>
</ul>
<h2 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h2><p>Krug 可用性第一定律</p>
<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<h2 id="我们实际上是如何使用-Web-的"><a href="#我们实际上是如何使用-Web-的" class="headerlink" title="我们实际上是如何使用 Web 的"></a>我们实际上是如何使用 Web 的</h2><p>扫描，满意即可，勉强应付</p>
<p>我们一旦发现某个事物能够用（不管有多难用），我们也不太会去找一种更好的方法。，如果偶然发现一种更好的方法，我们会换用这种更好的方法，但很少会主动寻找更好的方法。</p>
<h2 id="广告牌设计-101-法则"><a href="#广告牌设计-101-法则" class="headerlink" title="广告牌设计 101 法则"></a>广告牌设计 101 法则</h2><p>为扫描设计，不为阅读设计</p>
<ul>
<li>在每个页面上建立清楚的视觉层次。</li>
<li>尽量利用习惯用法</li>
<li>把页面划分成明确定义的区域</li>
<li>明显标识可以点击的地方。</li>
<li>最大限度降低干扰</li>
</ul>
<h3 id="建立清楚的视觉层次"><a href="#建立清楚的视觉层次" class="headerlink" title="建立清楚的视觉层次"></a>建立清楚的视觉层次</h3><ul>
<li>越重要的部分越突出</li>
<li>逻辑上相关的部分在视觉上也相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ul>
<h2 id="动物、植物、无机物"><a href="#动物、植物、无机物" class="headerlink" title="动物、植物、无机物"></a>动物、植物、无机物</h2><p>为什么用户喜欢无须思考的选择</p>
<p>如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。</p>
<h2 id="省略不必要的文字"><a href="#省略不必要的文字" class="headerlink" title="省略不必要的文字"></a>省略不必要的文字</h2><p>不要在 Web 上写作的艺术</p>
<ul>
<li>去掉那些没有人会看的文字</li>
<li>欢迎词必须消灭</li>
<li>指示说明必须消灭</li>
</ul>
<h2 id="街头指示牌和面包屑"><a href="#街头指示牌和面包屑" class="headerlink" title="街头指示牌和面包屑"></a>街头指示牌和面包屑</h2><p>设计导航</p>
<p>关于页面名称，需要注意：</p>
<ul>
<li>每个页面都需要一个名称</li>
<li>页面名称要出现在合适的位置</li>
<li>名称要引人注目</li>
<li>名称要和点击的链接一致</li>
</ul>
<h2 id="首先要承认，主页不由你控制"><a href="#首先要承认，主页不由你控制" class="headerlink" title="首先要承认，主页不由你控制"></a>首先要承认，主页不由你控制</h2><p>设计主页</p>
<p>主页要完成的任务：</p>
<ul>
<li>站点的标识和使命</li>
<li>站点层次</li>
<li>搜索</li>
<li>导读</li>
<li>内容更新</li>
<li>友情链接</li>
<li>快捷方式</li>
<li>注册</li>
</ul>
<p>没有什么比得上一个好口号</p>
<ul>
<li>好的口号要清楚、言之有物</li>
<li>不好的口号含混不清</li>
<li>好的口号长度适中</li>
<li>好的口号能表述出网站的特点和显而易见的好处</li>
<li>不好的口号听起来太笼统</li>
<li>好的口号应该有个性、生动，有时候还很俏皮</li>
</ul>
<h2 id="农场主和牧牛人应该是朋友"><a href="#农场主和牧牛人应该是朋友" class="headerlink" title="农场主和牧牛人应该是朋友"></a>农场主和牧牛人应该是朋友</h2><p>为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况</p>
<p>争辩人们喜欢什么既浪费时间又消耗团队的经历，而通过测试将讨论对错转移到什么有效、什么无效上，更容易缓和争论、打破僵局，而且，测试会让我们看到用户的动机、理解、反应的不同，从而让我们不会再坚持认为用户的想法和我们的想法一样</p>
<h2 id="一天-10-美分的可用性测试"><a href="#一天-10-美分的可用性测试" class="headerlink" title="一天 10 美分的可用性测试"></a>一天 10 美分的可用性测试</h2><p>让测试简答 —— 这样你能进行充分的测试</p>
<ul>
<li>如果想建立一个优秀的网站，一定要测试</li>
<li>测试一个用户比不做测试好一倍</li>
<li>在项目中，早点测试一位用户好过最后测试 50 位用户</li>
<li>人们对招募用户代表的重要性估计过高</li>
<li>测试的关键不是要证明什么或者反驳什么，而是了解你的判断力</li>
<li>测试是一个迭代的过程</li>
<li>没有什么比现场用户的反应更重要</li>
</ul>
<h2 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h2><p>为什么你的网站应该让人尊敬</p>
<p>降低好感的几种方式</p>
<ul>
<li>隐藏我想要的信息</li>
<li>因为没有按照你们的方式行事而惩罚我</li>
<li>向我询问不必要的信息</li>
<li>敷衍我，欺骗我</li>
<li>给我设置障碍</li>
<li>你的网站看上去不专业</li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li>知道人们在你网站上想做什么，并让它们明白简单</li>
<li>高速我我想知道的</li>
<li>尽量减少步骤</li>
<li>花点心思</li>
<li>知道我可能有哪些疑问，并且给予解答</li>
<li>为我提供协助，例如打印友好页面</li>
<li>容易从错误中恢复</li>
<li>如有不确定，记得道歉</li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="网页" scheme="http://wdxtub.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/27/deep-learning-clip/"/>
    <id>http://wdxtub.com/2017/05/27/deep-learning-clip/</id>
    <published>2017-05-27T00:32:59.000Z</published>
    <updated>2017-07-04T07:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习作为人工智能时代最重要的技术之一，值得每一个 AI 从业者了解和学习，这里是我的读书笔记。</p>
<p>注：本笔记来源于<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="external">这里</a></p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.29: 完成阅读</li>
<li>2017.05.27: 开始阅读</li>
</ul>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><h3 id="数和数组"><a href="#数和数组" class="headerlink" title="数和数组"></a>数和数组</h3><ul>
<li>$\alpha$ 标量（整数或实数）</li>
<li>$\mathbf{\alpha}$ 向量</li>
<li>$A$ 矩阵</li>
<li>$\mathbf{A}$ 张量</li>
<li>$I_n$ n 行 n 列的单位矩阵</li>
<li>$I$ 维度蕴含于上下文的单位矩阵</li>
<li>$e^{(i)}$ 标准基向量 <code>[0,...,0,1,0,...,0]</code>，其中索引 i 处值为 1</li>
<li>$diag(\mathbf{\alpha})$ 对角方阵，其中对角元素由 $\mathbf{\alpha}$ 给定</li>
<li>$\mathrm{a}$ 标量随机变量</li>
<li>$\mathbf{a}$ 向量随机变量</li>
<li>$\mathrm{A}$ 矩阵随机变量</li>
</ul>
<h3 id="集合和图"><a href="#集合和图" class="headerlink" title="集合和图"></a>集合和图</h3><ul>
<li>$\mathbb{A}$ 集合</li>
<li>$\mathbb{R}$ 实数集</li>
<li>${0, 1}$ 包含 0 和 1 的集合</li>
<li>${0,1,\dots ,n}$ 包含 0 和 n 之间的所有整数的集合</li>
<li>$[a,b]$ 包含 a 和 b 的实数区间</li>
<li>$(a,b]$ 不包含 a 但包含 b 的实数区间</li>
<li>$\mathbb{A} \setminus \mathbb{B}$ 差集，即其元素包含于 $\mathbb{A}$ 但不包含于 $\mathbb{B}$</li>
<li>$\zeta$ 图</li>
<li>$Pa_\zeta(x_i )$ 图 $\zeta$ 中的父节点</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人工智能的真正挑战在于解决那些对人来说很容易执行但很难形式化描述的任务，人类往往可以凭借直觉轻易解决。</p>
<p>抽象和形式化的任务对人类而言是最困难的脑力任务之一，但对计算机而言却属于最容易的。一个人的日常生活需要关于世界的巨量知识。很多这方面的知识是主观的、直观的，因此很难通过形式化的方式表达清除。计算机需要获取同样的知识才能表现出智能。人工智能的一个关键挑战就是如何将这些非形式化的知识传达给计算机。</p>
<p>依靠硬编码的知识体系面对的困难表明，AI 系统需要具备自己获取知识的能力，即从原始数据中提取模式的能力，这种能力被称为机器学习。</p>
<p>在整个计算机科学乃至日常生活中，对表示的依赖都是一个普遍现象。在计算机科学中，如果数据集合被精巧地结构化并被智能地索引，那么诸如搜索之类的操作的处理速度就可以成指数级地加快。</p>
<p>许多人工智能任务都可以通过以下方式解决：先提取一个合适的特征集，然后将这些特征提供给简单的机器学习算法。然而，对于许多任务来说，我们很难知道应该提取哪些特征。</p>
<p>解决这个问题的途径之一是使用机器学习来发掘表示本身，而不仅仅把表示映射到输出，这种方法我们称为<strong>表示学习</strong>(representation learning)。</p>
<p>表示学习算法的典型例子是<strong>自编码器</strong>(autoencoder)。自编码器由一个<strong>编码器</strong>(encoder)和一个<strong>解码器</strong>(decoder)函数组合而成。编码器函数将输入数据转换为一种不同的表示，而解码器函数则将这个新的表示转换到原来的形式。我么期望当输入数据经过编码器和解码器之后尽可能多地保留信息，同时希望新的表示有各种号的特性，这也是自编码器的训练目标。为了实现不同的特性，我们可以设计不同形式的自编码器。</p>
<p>当设计特征或设计用于学习特征的算法时，我们的目标通常是分离出能解释观察数据的<strong>变差因素</strong>(factors of variation)。在许多现实的人工智能应用中，困难主要源于多个变差因素同时影响着我们能够观察到的每一个数据。</p>
<p><strong>深度学习</strong>(deep learning)通过其他较简单的表示来表达复杂表示，解决了表示学习中的核心问题。</p>
<p>联结主义的中心思想是，当网络将大量简单的计算单元连接在一起时可以实现智能行为。这种见解同样适用于生物神经系统中的神经元，因为它和计算模型中隐藏单元起着类似的作用。</p>
<p>联结主义潮流的另一个重要成就是反向传播在训练具有内部表示的深度神经网络中的成功使用以及反向传播算法的普及。</p>
<h2 id="概率与信息论"><a href="#概率与信息论" class="headerlink" title="概率与信息论"></a>概率与信息论</h2><p>概率论是用于表示不确定性<strong>声明</strong>(statement)的数学框架。它不仅提供了量化不确定性的方法，也提供了用于导出新的不确定性声明的公里。在人工智能领域，概率论主要有两种用途。首先，概率法则告诉我们 AI 系统如何推理，据此我们设计一些算法来计算或者估算由概率论导出的表达式。其次，我们可以用概率和统计从理论上分析我们提出的 AI 系统的行为。</p>
<p>概率论使我们能够作出不确定的声明以及在不确定性存在的情况下进行推理，而信息论使我们能够量化概率分布中的不确定性总量。</p>
<p>如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用<strong>KL 散度</strong>(Kullback-Leibler(KL) divergence) 来衡量这两个分布的差异。KL 散度有很多有用的性质，最重要的是它是非负的。KL 散度为 0 当且仅当 P 和 Q 在离散型变量的情况下是相同的分布，或者在连续型变量的情况下是『几乎处处』相同的。</p>
<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p>连续数学在数字计算机上的根本困难是，我们需要通过有限数量的位模式来表示无限多的实数。这意味着我们在计算机中表示实数时，几乎总会引入一些近似误差。在许多情况下，这仅仅是舍入误差。舍入误差会导致一些问题，特别是当许多操作复合时，即使是理论上可行的算法，如果在设计时没有考虑最小化舍入误差的积累，在实践时也可能会导致算法失效。</p>
<p>一种极具毁灭性的舍入误差是<strong>下溢</strong>(underflow)。当接近零的数被四舍五入为零时发生下溢。许多函数在其参数为零而不是一个很小的正数时才会表现出质的不同。另一个极具破坏力的数值错误形式是<strong>上溢</strong>(overflow)。</p>
<p>必须对上溢和下溢进行数值稳定的一个例子是 <strong>softmax 函数</strong>(softmax function)</p>
<h3 id="基于梯度的优化方法"><a href="#基于梯度的优化方法" class="headerlink" title="基于梯度的优化方法"></a>基于梯度的优化方法</h3><p>大多数深度学习算法都涉及某种形式的优化。我们把要最小化或最大化的函数称为<strong>目标函数</strong>(objective function)或<strong>准则</strong>(criterion)。当我们对其进行最小化时，我们也把它称为<strong>代价函数</strong>(cost function)、<strong>损失函数</strong>(loss function)或<strong>误差函数</strong>(error function)</p>
<p>KKT 方法。这部分数学，如果不想深究，也不需要过分在意</p>
<h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>机器学习本质上属于应用统计学，更多地关注于如何用计算机统计地估计复杂函数，不太关注为这些函数提供置信区间。</p>
<h3 id="促使深度学习发展的挑战"><a href="#促使深度学习发展的挑战" class="headerlink" title="促使深度学习发展的挑战"></a>促使深度学习发展的挑战</h3><p><strong>维数灾难</strong></p>
<p>当数据的维数很高时，很多机器学习问题变得相当困难。这种现象被称为<strong>维数灾难</strong>(curse of dimensionality)。特别值得注意的是，一组变量不同的可能配置数量会随着变量数目的增加贰指数级增长。</p>
<p><strong>局部不变性和平滑正则化</strong></p>
<h2 id="深度前馈网络"><a href="#深度前馈网络" class="headerlink" title="深度前馈网络"></a>深度前馈网络</h2><p><strong>深度前馈网络</strong>(deep feedforward network)，也叫做<strong>前馈神经网络</strong>(feedforward neural network)或者<strong>多层感知机</strong>(multilayer perceptron, MLP)，是典型的深度学习模型。前馈神经网络的目标是近似某个函数 $f^<em>$。例如，对于分类器，$y=f^</em>(\mathbf{x})$ 将输入 $\mathbf{x}$ 映射到一个类别 y。前馈网络定义了一个映射 $y=f(\mathbf{x};\theta)$，并且学习参数 $\theta$ 的值，使它能够得到最佳的函数近似。</p>
<p>这种模型被称为<strong>前向</strong>(feedforward)的，是因为信息留过 $\mathbf{x}$ 的函数，刘静用于定义 $f$ 的中间计算过程，最终到达输出 $y$。在模型的输出和模型本身之间没有<strong>反馈</strong>(feedback)连接。当前馈神经网络被扩展成包含反馈连接时，它们被称为<strong>循环神经网络</strong>(recurrent neural network)。</p>
<p>前馈神经网络被称作<strong>网络</strong>(network)是因为它们通常用许多不同函数复合起来一起表示。该模型与一个有向无环图相关联，而图描述了函数是如何复合在一起的。</p>
<p>网络中的每个隐藏层通常都是向量值的。这些隐藏层的维数决定了模型的<strong>宽度</strong>(width)。向量的每个元素都可以被视为起到类似一个神经元的做用。除了将层想象成向量到向量的单个函数，我们也可以把层想象成由许多并行操作的<strong>单元</strong>(unit)组成，每个单元表示一个向量到标量的函数。每个单元在某种意义上类似一个神经元，它接收的输入来源于许多其他的单元，并计算它自己的激活值。</p>
<h2 id="深度学习中的正则化"><a href="#深度学习中的正则化" class="headerlink" title="深度学习中的正则化"></a>深度学习中的正则化</h2><p>机器学习中的一个核心问题是设计不仅在训练数据上表现好，并且能在新输入上泛化好的算法。在机器学习中，许多策略显式地被设计为减少测试误差（可能会以增大训练误差为代价），这些策略被统称为正则化。事实上，开发更有效的正则化策略已成为本领域的主要研究工作之一。</p>
<p>目前为止，最流行和广泛使用的参数共享出现在应用于计算机视觉的<strong>卷积神经网络</strong>(CNN)中。自然图像有许多统计属性是对转换不变的。相同的特征（具有相同权重的隐藏单元）在输入的不同位置上计算获得。参数共享显著降低了 CNN 模型的参数数量，并显著提高了网络的大小贰不需要相应地增加训练数据。它仍然是将领域知识有效地整合到网络架构的最佳范例之一。</p>
<p><strong>Bagging</strong>(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。</p>
<p><strong>Dropout</strong>(Dropout)提供了正则化一大类模型的方法，计算方便但功能强大。在第一种近似下，Dropout 可以被认为是集成大量深层神经网络的实用 Bagging 方法。Bagging 涉及训练多个模型，并在每个测试样本上评估多个模型。</p>
<p>具体而言，Dropout 训练的集成包括所有从基础网络除去与非输出单元后形成的子网络。在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。参数共享使得在有限可用的内存下表示指数级数量的模型变得可能。在 Bagging 的情况下，每一个模型在其相应训练集上训练到收敛。在 Dropout 情况下，通常大部分模型都没有显式地被训练，因为通常父神经网络会很大，以至于到宇宙毁灭都不可能采样完所有的子网络。取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。</p>
<p>只有极少的训练样本可用时，Dropout 不会很有效。一个关于 Dropout 的重要见解是，通过随机行为训练网络并平均多个随机决定进行预测，实现了一种参数共享的 Bagging 形式。Dropout 不仅仅是训练一个 Bagging 的集成模型，并且是共享隐藏单元的继承模型。这意味着无论其他隐藏单元是否在模型中，每个隐藏单元都必须能够表现良好。隐藏单元必须准备好进行模型之间的交换和互换（有性生殖涉及到两个不同生物体之间交换基因，进化产生的压力使得基因不仅是良好的而且要准备好不同有机体之间的交换。这样的基因和这些特点对环境的变化是非常稳健的，因为它们一定会正确适应任何一个有机体或模型不寻常的特性）。因此 Dropout 正则化每个隐藏单元不仅是一个很好的特征，更要在许多情况下是良好的特征。</p>
<p>Dropout 强大的大部分原因来自施加到隐藏单元的掩码噪声，了解这一事实是重要的。这可以看作是对输入内容的信息高度智能化、自适应破坏的一种形式，而不是对输入原始值的破坏。</p>
<h2 id="深度模型中的优化"><a href="#深度模型中的优化" class="headerlink" title="深度模型中的优化"></a>深度模型中的优化</h2><p>随机梯度下降(SGD)及其变种很可能是一般机器学习中应用最多的优化算法，特别是在深度学习中。按照数据生成分布抽取 m 个小批量（独立同分布的）样本，通过计算它们梯度均值，我们可以得到梯度的无偏估计。SGD 算法中的一个关键参数是学习率。</p>
<p>虽然 SGD 仍然是非常受欢迎的优化方法，但其学习过程有时会很慢。<strong>动量</strong>(momentum)方法可以加速学习，特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。</p>
<h3 id="自适应学习率算法"><a href="#自适应学习率算法" class="headerlink" title="自适应学习率算法"></a>自适应学习率算法</h3><p><strong>AdaGrad</strong></p>
<p>AdaGrad 算法独立地适应所有模型参数的学习率，缩放每个参数反比于其所有梯度历史平方值综合的平方根。</p>
<p><strong>RMSProp</strong></p>
<p>RMSProp 算法修改 AdaGrad 以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。经验上，RMSProp 已被证明是一种有效且实用的深度神经网络优化算法。目前它是深度学习从业者经常采用的优化方法之一。</p>
<p><strong>Adam</strong></p>
<p>Adam 是另一种学习率自适应优化算法。Adam 通常被认为对超参数的选择相当鲁棒，尽管学习率有时需要从建议的默认修改。</p>
<h2 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h2><p><strong>卷积网络</strong>(convolutional network)，也叫做<strong>卷积神经网络</strong>(convolutional neural network, CNN)，是一种专门用来处理具有类似网格结构的数据的神经网络。例如时间序列数据（可以认为是在时间轴上有规律采样形成的一维网格）和图像数据（可以看作是二维的像素网格）。</p>
<p>卷积运算通过三个重要的思想来帮助改进机器学习系统：<strong>稀疏交互</strong>(sparse interactions)、<strong>参数共享</strong>(parameter sharing)、等变表示(equivariant representations)。</p>
<p>池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。例如<strong>最大池化</strong>(max pooling)函数给出相邻矩形区域内的最大值。其他常用的池化函数包括相邻矩形区域内的平均值、$L^2$范数以及基于据中心像素距离的加权平均函数。</p>
<p>不管采用什么样的池化函数，当输入作出少量平移时，池化能够帮助输入的表示近似<strong>不变</strong>(invariant)。因为池化综合了全部邻居的反馈，这使得池化单元少于探测单元成为可能，我们可以通过综合池化区域的 k 个像素的统计特征而不是单个像素来实现。</p>
<p>在很多任务中，池化对于处理不同大小的输入具有重要做用。例如我们想对不同大小的图像进行分类时，分类层的输入必须是固定的大小，而这通常通过调整池化区域的偏置大小来实现。</p>
<p>把卷积神经网络当作一个具有无限强先验的全连接网络来实现会导致极大的计算浪费。但把卷积神经网络想成具有无限强先验的全连接网络可以帮助我们更好地洞察卷积神经网络是如何工作的。</p>
<h2 id="序列建模：循环和递归网络"><a href="#序列建模：循环和递归网络" class="headerlink" title="序列建模：循环和递归网络"></a>序列建模：循环和递归网络</h2><p><strong>循环神经网络</strong>(recurrent neural network) 或 RNN 是一类用于处理序列数据的神经网络。</p>
<p>大多数 RNN 中的计算可以分解成三块参数及其相关的变换：</p>
<ol>
<li>从输入到隐藏状态</li>
<li>从前一隐藏状态到下一隐藏状态，以及</li>
<li>从隐藏状态到输出</li>
</ol>
<h2 id="实践方法论"><a href="#实践方法论" class="headerlink" title="实践方法论"></a>实践方法论</h2><p>要成功地使用深度学习技术，仅仅知道存在哪些算法和解释他们为何有效的原理是不够的。一个优秀的机器学习实践者还需要知道如何针对具体应用挑选一个合适的算法以及如何监控，并根据实验反馈改进机器学习系统。在机器学习系统的日常开发中，实践者需要决定是否收集更多的数据、增加或减少模型容量、添加或删除正则化项、改进模型的优化、改进模型的近似推断或调试模型的软件实现。尝试这些操作都需要大量时间，因此确定正确做法，而不盲目猜测尤为重要。</p>
<p>我们建议参考以下几个实践设计流程：</p>
<ul>
<li>确定目标 - 使用什么样的误差度量，并为此误差度量指定目标值。这些目标和误差度量取决于该应用旨在解决的问题</li>
<li>尽快建立一个端到端的工作流程，包括估计合适的性能度量</li>
<li>搭建系统，并确定性能瓶颈。检查哪个部分的性能差于预期，以及是否是因为过拟合、欠拟合，或者数据或软件缺陷造成的</li>
<li>根据具体观察反复地进行增量式的改动，如收集新数据、调整超参数或改进算法</li>
</ul>
<h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><p>对于大多数应用而言，不可能实现绝对零误差。即使你有无限的训练数据，并且恢复了真正的概率分布，贝叶斯误差仍定义了能达到的最小错误率。这是因为输入特征可能无法包含输出变量的完整信息，或是因为系统可能本质上是随机的。</p>
<p>在现实世界中，一个应用的错误率有必要是安全的、具有成本效益的或吸引消费者的。一旦你确定了想要达到的错误率，那么你的设计将由如何达到这个错误率来指导。</p>
<h3 id="决定是否收集更多数据"><a href="#决定是否收集更多数据" class="headerlink" title="决定是否收集更多数据"></a>决定是否收集更多数据</h3><p>在建立第一个端到端的系统后，就可以度量算法性能并决定如何改进算法。许多机器学习新手都忍不住尝试很多不同的算法。然而，收集更多的数据往往比改进学习算法要有用得多。</p>
<p>怎样判断是否要收集更多的数据？首先，确定训练集上的性能是否可接受。如果模型在训练集上的性能就很差，学习算法都不能在训练集上学习出良好的模型，那么就没必要收集更多的数据。反之，可以尝试增加更多的网络层或每层增加更多的隐藏单元，以增加模型的规模。此外，也可以调整学习率等超参数的措施来改进学习算法。如果更大的模型和仔细调试的优化算法效果不佳，那么问题可能源自训练数据的质量。数据可能含太多噪声，或是可能不包含预测输出所需的正确输入。这意味着我们需要重新开始，收集更干净的数据或是收集特征更丰富的数据集。</p>
<p>如果训练集上的性能是可接受的，那么我们开始度量测试集上的性能。如果测试集上的性能也是可以接受的，那么就顺利完成了。这时主要的考虑是收集更多数据的代价和可行性，其他方法降低误差的代价和可行性，和增加数据数量能否显著提升测试集性能。</p>
<h3 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h3><p>当一个机器学习系统效果不好时，通常很难判断效果不好的原因是算法本身，还是算法实现错误。由于各种原因，机器学习系统很难调试</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="大规模深度学习"><a href="#大规模深度学习" class="headerlink" title="大规模深度学习"></a>大规模深度学习</h3><p>深度学习的基本思想基于联结主义：尽管机器学习模型中单个生物性的神经元或者说是单个特征不是智能的，但是大量的神经元或者特征作用在一起往往能够表现出智能。由于规模的大小对于神经网络来说至关重要，因此深度学习需要高性能的硬件设施和软件实现。</p>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>一直以来，计算机视觉就是深度学习应用中几个最活跃的研究方向之一。因为视觉是一个对人类以及许多动物毫不费力，但对计算机却充满挑战的任务。</p>
<p><strong>预处理</strong></p>
<p>由于原始输入往往已深度学习架构难以表示的形式出现，许多应用领域需要复杂精细的预处理。计算机视觉通常只需要相对少的这种预处理。图像应该被标准化，从而使得它们的像素都在相同并且合理的范围内，比如 [0,1] 或者 [-1,1]。将 [0,1] 中的图像与 [0,255] 中的图像混合通常会导致失败。将图像格式化为相同比例严格上说是唯一一种必要的预处理。许多计算机视觉框架需要标准尺寸的图像，因此必须裁剪或缩放图像以适应该尺寸。</p>
<p><strong>对比度归一化</strong></p>
<p>在许多任务中，对比度是能够安全移除的最为明显的变化源之一。简单地说，对比度指的是图像中亮像素和暗像素之间差异的大小。量化图像对比度有许多方式。在深度学习中，对比度通常指的是图像或图像区域中像素的标准差。</p>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>非常通用的神经网络技术可以成功地应用于自然语言处理。然而，为了实现卓越的性能并扩展到大型应用程序，一些领域特定的策略也很重要。</p>
<p><strong>n-gram</strong></p>
<p><strong>语言模型</strong>(language model)定义了自然语言中标记序列的概率分布。根据模型的设计，标记可以是词、字符、甚至是字节。标记总是离散的实体，最早成功的语言模型基于固定长度序列的标记模型，称为 n-gram。</p>
<p><strong>神经语言模型</strong></p>
<p><strong>神经语言模型</strong>(Neural Language Model, NLM)是一类用来客服维数灾难的语言模型，它使用词的分布式表示对自然语言序列建模。不同于基于类的 n-gram 模型，神经语言模型在能够识别两个相似的词，并且不丧失每个词编码为彼此不同的能力。神经语言模型共享一个词（及其上下文）和其他类似词（和上下文之间）的统计强度。</p>
<p>我们有时将这些词表示为<strong>词嵌入</strong>(word embedding)。在这个解释下，我们将原始符号视为维度等于词表大小的空间中的点。词表示将这些点嵌入到较低维度的特征空间中</p>
<h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>当向用户推荐时，会产生超出普通监督学习范围的问题，并进入强化学习的领域。理论上，许多推荐问题最准确的描述是 contextual bandit。问题是，当我们使用推荐系统收集数据时，我们得到是一个有偏且不完整的用户偏好观：我们只能看到用户对推荐给他们的项目的反应，而不是其他项目。更糟糕的是，如果我们不够小心，即使收集越来越多的数据，我们得到的系统可能会继续选择错误的决定，因为正确的决定最初只有很低的概率：直到学习者选择正确的决定之前，该系统都无法学习正确的决定。这类似于强化学习的情况，其中仅观察到所选动作的奖励。一般来说，强化学习会涉及许多动作和许多奖励的序列。</p>
<p>在一般的强化学习场景中，高奖励或地奖励可能是由最近的动作或很久以前的动作引起的。术语 contextual bandit 指的是在一些输入变量可以通知决定的上下文中采取动作的情况。例如，我们至少知道用户身份，并且我们要选择一个项目。从上下文到动作的映射也称为<strong>策略</strong>(policy)。学习者和数据分布（现在取决于学习者的动作）之间的反馈是强化学习和 bandit 研究的中心问题。</p>
<p>强化学习需要权衡<strong>探索</strong>(exploration)与<strong>开发</strong>(exploitation)。开发指的是从目前学到的最好策略采取动作，也就是我们所知的将获得高奖励的动作。<strong>探索</strong>(exploration)是指采取行动以获得更多的训练数据。</p>
<h3 id="知识表示、推理和回答"><a href="#知识表示、推理和回答" class="headerlink" title="知识表示、推理和回答"></a>知识表示、推理和回答</h3><p>因为使用符号和词嵌入，深度学习方法在语言模型、机器翻译和自然语言处理方面非常成功。这些嵌入表示关于单个词或概念的语义只是。研究前言是为短语或词和事实之间的关系开发嵌入。</p>
<p>一个有趣的研究方向是确定如何训练分布式表示才能捕获两个实体之间的<strong>关系</strong>(relation).</p>
<p>知识库和分布式表示的另一个应用是<strong>词义消岐</strong>(word-sense disambiguation)，这个任务决定在某些语境中词的哪个意义是恰当的。</p>
<p>知识的关系结合一个推理过程和对自然语言的理解可以让我们建立一个一般的问答系统。一般的问答系统必须能够处理输入信息并记住重要的事实，并以之后能检索和推理的方式组织。这热鞥然是一个困难的开放性问题，只能在受限的『玩具』环境下解决。目前，记住和检索特定声明性事实的最佳方法是使用显式记忆机制。记忆网络最开始是被用来解决一个玩具问答任务。Kumar 在 2015 年提出了一种扩展，使用 GRU 循环网络将输入读入存储器并且在给定存储器的内容后产生回答。</p>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习作为人工智能时代最重要的技术之一，值得每一个 AI 从业者了解和学习，这里是我的读书笔记。&lt;/p&gt;
&lt;p&gt;注：本笔记来源于&lt;a href=&quot;https://github.com/exacity/deeplearningbook-chinese&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://wdxtub.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>第五十周 - 牧羊曲</title>
    <link href="http://wdxtub.com/2017/05/26/shepherd-song/"/>
    <id>http://wdxtub.com/2017/05/26/shepherd-song/</id>
    <published>2017-05-26T11:45:51.000Z</published>
    <updated>2017-05-26T14:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>日出嵩山坳，晨钟惊飞鸟。林间小溪水潺潺，坡上青青草。野果香，山花俏，狗儿跳羊儿跑。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.26: 完成初稿</li>
</ul>
<p>临近放假每一天都变得非常漫长，一周上六天班的节奏久了之后，对周末的期待大大增加，对工作日的期待同样大大减少。1x6 固然大于 1x5，但是同时也抹杀了把 1x5 中的 1 变成 1.5 的可能。不过话说回来，随着对工作的愈发熟悉，大部分方案都已经尝试过了一遍，能用的套路都耍过一遍之后，剩下的就是轻车熟路地兵来将挡水来土掩了。照理说这样反倒会轻松，不过我这个人吧就是喜欢折腾，好在最近老大们又给了我一个新任务，于是我又开始吭哧吭哧学新东西，争取捣鼓出有用的玩意儿了。</p>
<p>创业过程如何维持团队战斗力是很让我头疼的事情，一方面我没有那么多精力去照顾每个人的情绪，需要内心强大，对做的事情有认同感的人主动积极参与，给我惊喜，而不是我指派任务由别人执行；另一方面这种环境其实也是一个筛选的机制，我只能说来则来，去则去，都是缘分，能一起走一段路，已经很好了。</p>
<p>工作之余也在生活中努力折腾一些之前只是想想但从来没做过的事情，比如在阳台上搭一个花台，把所有的花花草草有立体感摆放起来，比如买一些冰棒的模具自己做绿豆冰（当然是不放糖的那种，怕胖）。另外公司很贴心的发了两盒粽子和一盒鸭蛋，顿时解决了这周没来得做饭的问题。相比于之前在大疆一百元购物卡，过节气氛要浓得多。</p>
<p>上周末回家包了饺子，印象中已经很久没有一家人一起包饺子了，全家一起为了一大锅饺子一起努力的过程是特别美好的记忆，妈妈负责擀皮，爸爸和我负责包。我一边学一边瞎『创新』，包出来的饺子那个一个比一个大，生怕肚子里面肉少了吃起来不过瘾。今年端午可以往家里带粽子了，感觉很开心，能为爸爸妈妈做点什么了。</p>
<p>前两天下了一场大暴雨，看着窗外的大雨我在想：下不下雨我们不能决定，但是屋漏不漏我们倒是可以决定。即使有的时候因为这样那样的原因陷入低迷，也不要自暴自弃，毕竟人生如几何有起有落，不能因为『落』连日子都不『过』。攀登的路上吃点苦头在所难免，但越是知道生活的残忍，越能体会个中的温柔。</p>
<p>冬去春来十六载，黄花正年少。腰身壮胆气豪，常练武勤操劳。耕田放牧打豺狼，风雨一肩挑一肩挑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日出嵩山坳，晨钟惊飞鸟。林间小溪水潺潺，坡上青青草。野果香，山花俏，狗儿跳羊儿跑。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之云计算】壹 云平台初探</title>
    <link href="http://wdxtub.com/2017/05/26/cloud-computing-platform/"/>
    <id>http://wdxtub.com/2017/05/26/cloud-computing-platform/</id>
    <published>2017-05-25T23:10:21.000Z</published>
    <updated>2017-07-04T07:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中最麻烦的往往不是开发本身，而是环境搭建，尤其是调通各种接口和服务。这一讲我会详细介绍如何把云资源用得像自家电脑一样省心。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.26: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>注：待更新完成后列出</p>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解 AWS 和 Azure 的基本概念和使用</li>
<li>掌握基本的 Linux 命令</li>
<li>理解不同配置的应用场景</li>
</ol>
<h2 id="AWS-Amazon-Web-Service"><a href="#AWS-Amazon-Web-Service" class="headerlink" title="AWS - Amazon Web Service"></a>AWS - Amazon Web Service</h2><p>AWS 是目前最广泛应用的云服务，包含各种不同的服务，比如 Amazon Simple Storage Service (S3) 和 Amazon Elastic Compute Cloud (EC2)。更多的信息请参考 <a href="http://aws.amazon.com/" target="_blank" rel="external">AWS 网站</a></p>
<h3 id="AWS-Authentication"><a href="#AWS-Authentication" class="headerlink" title="AWS Authentication"></a>AWS Authentication</h3><p>除了 AWS 本身的帐号外，访问 API 以及各类 AWS 服务需要使用的一对『钥匙』：<strong>AWS Access Key ID</strong> 以及 <strong>AWS Secret Key</strong>。</p>
<p>生成『钥匙』可以按照以下步骤：</p>
<ol>
<li>登录 AWS 账户</li>
<li>在右上角的下拉菜单中选择 Security Credentials (安全证书)<ul>
<li>如果是第一次访问的话会弹出一个提示是继续还是看一下教程，可以根据自己的需要来选择</li>
</ul>
</li>
<li>在 Access Key (访问密钥)那一栏创建一个新的密钥，就会包含 <strong>AWS Access Key ID</strong> 以及 <strong>AWS Secret Key</strong>。</li>
</ol>
<p>注意！AWS 密钥拥有控制 AWS 帐号的完全权限，所以务必要保存在安全的地方，做到以下几点：</p>
<ol>
<li>不要与任何人共享 AWS 密钥</li>
<li>不要在代码中用明文保存密钥</li>
<li>不要把包含 AWS 密钥的代码提交到任何库中</li>
</ol>
<p>比较安全的做法是利用环境变量来保存密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">export</span> AWS_ACCESS_KEY_ID=<span class="string">"YOUR_ACCESS_KEY_HERE"</span></div><div class="line"><span class="built_in">export</span> AWS_SECRET_KEY=<span class="string">"YOUR_SECRET_KEY_HERE"</span></div></pre></td></tr></table></figure>
<p>在代码中就可以使用 <code>System.getenv(&quot;AWS_ACCESS_KEY_ID&quot;)</code> 或者 <code>os.environ[&#39;AWS_ACCESS_KEY_ID&#39;]</code> 来访问，不会出现明文，我在自己电脑里用的名字是：<code>AWSAccessKeyId</code> 和 <code>AWSSecretKey</code></p>
<h3 id="Elastic-Compute-Cloud-EC2"><a href="#Elastic-Compute-Cloud-EC2" class="headerlink" title="Elastic Compute Cloud (EC2)"></a>Elastic Compute Cloud (EC2)</h3><p>简单来说，EC2 提供计算能力。EC2 实例可以被看做是虚拟机或虚拟服务器，有虚拟 CPU，内存，本地存储和网络带宽，当然运行的时候是要花钱的。具体的配置不能够自定义，只能从几个类型中选择：</p>
<ul>
<li><code>t1.micro</code>：1 个虚拟 CPU，1 G 内存，无本地存储，低带宽。这种会提供免费的使用时间，基本也就够用了。</li>
<li><code>m1.small</code></li>
<li><code>m1.large</code></li>
<li><code>c1.xlarge</code></li>
</ul>
<p>具体的类型可以参考亚马逊的<a href="http://aws.amazon.com/ec2/instance-types" target="_blank" rel="external">介绍</a>，这里不一一列举。</p>
<p>花钱也有不同的方式：</p>
<ul>
<li>按需：每个 instance 每小时有固定的价钱</li>
<li>Reserved：预付款模式</li>
<li>Spot Pricing：Bid for unused capacity，给定一个价格，如果浮动到价格以下，那么就帮你开启，并以当时的价格计价</li>
</ul>
<p>instance 的存储会在 Elastic Block Storage(EBS)。</p>
<p>Amazon Machine Image (AMI) = 操作系统 + 软件。</p>
<p>一旦一个 instance 启动之后，就有了一个公网的 IP，可以通过 Security Group 来进行访问，比如 22 端口 SSH，80 端口 HTTP，3306 端口 MySQL。</p>
<p>利用密钥对来访问 EC2 instances。</p>
<p>总结一下，启动一个 instance 有以下几个步骤：</p>
<ol>
<li>选择一个 instance 类型：<code>t1.micro</code></li>
<li>决定一个计价模型：Spot Pricing</li>
<li>选择一个 AMI：Ubuntu AMI</li>
<li>定义一个 Security Group</li>
<li>使用密钥对来连接</li>
</ol>
<h3 id="启动并连接到-instance"><a href="#启动并连接到-instance" class="headerlink" title="启动并连接到 instance"></a>启动并连接到 instance</h3><p><a href="https://youtu.be/z-NoOLk2U-g" target="_blank" rel="external">启动 EC2 instance 视频教程（墙外）</a></p>
<p>具体的步骤如下：</p>
<ol>
<li>进入控制台，选择 EC2 控制面板（地区注意选择弗吉尼亚北部，右上角那里）</li>
<li>点击实例，现在什么都没有，选择创建一个新实例</li>
<li>之后的 project 中会给出 AMI id，可以在社区 AMI 一栏里搜索选择</li>
<li>这里我们选择 Amazon Linux AMI，选择 <code>t2.micro</code></li>
<li>点击下一步进行具体的配置，这里暂时不需要修改</li>
<li>点击下一步选择存储</li>
<li>点击下一步可以给 instance 一些标签，注意格式应该是 <code>Project:&lt;Project Number&gt;</code>，如 <code>Project:0</code> 或 <code>Project:1.1</code> 这样</li>
<li>点击下一步配置 Security Group，这里可以不用修改，但是如果提高安全性的话可以限制可访问的 ip</li>
<li>然后可以查看各种选项</li>
<li>需要选择一个连接的密钥对（也可以在这里创建一个新的），是一个pem 文件，同样注意保存好</li>
<li>这时候就可以启动 instance</li>
</ol>
<p>等待一段时间，启动之后就可以连接到这个 instance，具体的步骤如下：</p>
<ol>
<li>从面板中得到 Public DNS 地址</li>
<li>使用 <code>ssh -i key_file.pem ec2-user@ec2-50-19-54-72-compute-1.amazonaws.com</code> 来进行连接</li>
<li>需要使用 <code>chmod 600 key_file.pem</code> 来修改权限</li>
<li>如果需要 root，直接 <code>sudo</code> 即可</li>
</ol>
<h3 id="Simple-Storage-Service-S3"><a href="#Simple-Storage-Service-S3" class="headerlink" title="Simple Storage Service(S3)"></a>Simple Storage Service(S3)</h3><p>Amazon S3 提供了一个简单的用来存储和访问任何数据的 web 服务接口。可以存储的对象数量是无限的，每个对象都可以通过一个唯一的，由开发者指定的 key 来访问。</p>
<p>和常见的文件系统比较起来，S3 没有文件夹的概念，唯一的容器就是一个 bucket，但是文件名例可以有 <code>/</code> 来标记不同的层级。</p>
<p>可以通过 web 界面，命令行工具和 API 三种方式来访问 S3。假设在 S3 中有一个文件的路径是</p>
<ul>
<li><code>s3://wdxtub/dawang.txt</code></li>
</ul>
<p>那么可以通过以下两种方式用 http 来访问：</p>
<ul>
<li><code>http://s3.amazonaws.com/wdxtub/dawang.txt</code></li>
<li><code>http://wdxtub.s3.amazonaws.com/dawang.txt</code></li>
</ul>
<p>其中 <code>wdxtub</code> 是 bucket 名，必须是全局唯一的。如果想要所有人都能够访问，需要设置一下对应的权限</p>
<p>其他一些常用的工具有：</p>
<ul>
<li>AWS Command Line Tool (aws-cli)<ul>
<li>在 Mac 下可以直接使用 <code>pip install awscli</code> 来进行安装，具体的教程可以参考<a href="https://aws.amazon.com/cn/cli/" target="_blank" rel="external">官方文档</a></li>
</ul>
</li>
<li>CloudWatch<ul>
<li>简单来说，CloudWatch 就是一个监控各种云服务的工具</li>
</ul>
</li>
</ul>
<h3 id="AWS-API"><a href="#AWS-API" class="headerlink" title="AWS API"></a>AWS API</h3><p>AWS 可以通过命令行工具或者 SDK 来访问几乎所有的功能，这一节主要介绍一些最常用的工具和功能。</p>
<p><a href="http://aws.amazon.com/cn/sdk-for-java/" target="_blank" rel="external">Java AWS SDK</a> 包括：</p>
<ul>
<li>AWS Java Library：总而言之就是所需的各种包，网络请求，验证，错误处理等等</li>
<li>样例代码</li>
<li>Eclipse 支持：包含一个插件</li>
</ul>
<p>在<a href="http://aws.amazon.com/tools" target="_blank" rel="external">这里</a>找到对应的工具，找到 SDK 中对应的库。主要过程有三步：</p>
<ol>
<li>用密钥初始化 AWS 连接</li>
<li>使用 API 进行操作</li>
<li>关闭 AWS 连接</li>
</ol>
<p>先下载好 SDK 和 Eclipse 插件（在 eclipse 里安装，Amazon 有给出教程）</p>
<p><strong>Amazon EC2 API</strong></p>
<p>可以通过 API 做这些事情：</p>
<ul>
<li>创建 EC2 密钥对</li>
<li>位实例创建安全组并且打开端口</li>
<li>创建启动停止重启和终止 EC2 实例</li>
</ul>
<p>下面是 Java 和 Python 的代码</p>
<p>Java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Load the Properties File with AWS Credentials</span></div><div class="line">Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">properties.load(RunInstance.class.getResourceAsStream(<span class="string">"/AwsCredentials.properties"</span>));</div><div class="line">BasicAWSCredentials bawsc = <span class="keyword">new</span> BasicAWSCredentials(properties.getProperty(<span class="string">"accessKey"</span>), properties.getProperty(<span class="string">"secretKey"</span>));</div><div class="line"><span class="comment">//Create an Amazon EC2 Client</span></div><div class="line">AmazonEC2Client ec2 = <span class="keyword">new</span> AmazonEC2Client(bawsc);</div><div class="line"><span class="comment">//Create Instance Request</span></div><div class="line">RunInstancesRequest runInstancesRequest = <span class="keyword">new</span> RunInstancesRequest();</div><div class="line"><span class="comment">//Configure Instance Request</span></div><div class="line">runInstancesRequest.withImageId(<span class="string">"ami-3b44d352"</span>)</div><div class="line">.withInstanceType(<span class="string">"t1.micro"</span>)</div><div class="line">.withMinCount(<span class="number">1</span>)</div><div class="line">.withMaxCount(<span class="number">1</span>)</div><div class="line">.withKeyName(<span class="string">"project1_test"</span>)</div><div class="line">.withSecurityGroups(<span class="string">"MySecurityGroup"</span>);</div><div class="line"></div><div class="line"><span class="comment">//Launch Instance</span></div><div class="line">RunInstancesResult runInstancesResult = ec2.runInstances(runInstancesRequest);   </div><div class="line"><span class="comment">//Return the Object Reference of the Instance just Launched</span></div><div class="line">Instance instance=runInstancesResult.getReservation().getInstances().get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> boto.ec2.connection <span class="keyword">import</span> EC2Connection</div><div class="line"></div><div class="line"><span class="comment"># Create a connection</span></div><div class="line">conn = boto.ec2.connect_to_region(<span class="string">"us-east-1"</span>)</div><div class="line"><span class="comment"># Launching instance</span></div><div class="line">reservation = conn.run_instances(<span class="string">"ami-3b44d352"</span>,instance_type = <span class="string">"t1.micro"</span>, </div><div class="line">        key_name = <span class="string">"project1_test"</span>, security_groups = <span class="string">"MySecurityGroup"</span>)</div><div class="line">instance = reservation.instances[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>我们同样可以通过 EC2 的 API 来查看实例的状态，例如类 <code>DescribeInstanceStatusRequest</code> 的状态：</p>
<ul>
<li>Running</li>
<li>Pending</li>
<li>Shutting down 等等</li>
</ul>
<p>更多的文档参考 <a href="http://aws.amazon.com/documentation/sdk-for-java/" target="_blank" rel="external">AWS SDK for Java Documentation</a> <a href="http://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/index.html" target="_blank" rel="external">AWS Java API Reference</a> 和 <a href="http://docs.pythonboto.org/en/latest/" target="_blank" rel="external">boto</a></p>
<h3 id="AWS-CLI"><a href="#AWS-CLI" class="headerlink" title="AWS CLI"></a>AWS CLI</h3><p>我们同样也可以利用命令行来操作 AWS，主页在<a href="http://aws.amazon.com/cn/cli/" target="_blank" rel="external">这里</a>。如果打算使用命令行，那么需要：</p>
<ol>
<li>在实例中下载和安装命令行工具</li>
<li>通过 <code>aws configure</code> 来设置密钥（注意这里地区要选择 us-east-1，<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html" target="_blank" rel="external">参考链接</a>）</li>
</ol>
<p>下面是简单的使用 AWS 命令行工具的视频介绍</p>
<p><a href="https://youtu.be/OSGjoMeHc2A" target="_blank" rel="external">AWS 命令行工具（墙外）</a></p>
<p>启动实例之前先要配置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws configure</div><div class="line">AWS Access Key ID [None]: YOUR AWS ACCESS KEY</div><div class="line">AWS Secret Access Key [None]: YOUR AWS SECRET ACCESS KEY</div><div class="line">Default region name [None]: us-east-1</div><div class="line">Default output format [None]: json</div></pre></td></tr></table></figure>
<p>然后可以用下面的命令来创建安全组，密钥对和角色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws ec2 create-security-group --group-name devenv-sg --description <span class="string">"security group for development environment in EC2"</span></div><div class="line">$ aws ec2 authorize-security-group-ingress --group-name devenv-sg --protocol tcp --port 22 --cidr 0.0.0.0/0</div><div class="line">$ aws ec2 create-key-pair --key-name devenv-key --query <span class="string">'KeyMaterial'</span> --output text &gt; devenv-key.pem</div><div class="line">$ chmod 400 devenv-key.pem</div></pre></td></tr></table></figure>
<p>然后就可以启动并连接实例了，这里需要提供 <code>AMI_ID(ami-xxxxx)</code> 和 安全组(sg-xxxxx)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ aws ec2 run-instances --image-id YOUR_AMI_ID --security-group-ids SECURITY_GROUP_ID --count 1 --instance-type t2.micro --key-name devenv-key --query <span class="string">'Instances[0].InstanceId'</span></div></pre></td></tr></table></figure>
<p>Amazon CloudWatch 部分之前有介绍过，详细介绍可以查看<a href="http://aws.amazon.com/documentation/cloudwatch/" target="_blank" rel="external">文档</a></p>
<h2 id="Microsoft-Azure"><a href="#Microsoft-Azure" class="headerlink" title="Microsoft Azure"></a>Microsoft Azure</h2><p>简单来说，就是微软提供的云服务，提供 PaaS 和 IaaS 服务，于此同时支持不同的编程语言/工具/框架。可以通过访问 <a href="https://portal.azure.com/" target="_blank" rel="external">Azure Portal</a> 或者 <a href="https://manage.windowsazure.com/" target="_blank" rel="external">Azure Manage</a> 来访问 Azure 控制台，其中 Azure Portal 是一个新的控制台，尽量用这个。需要更多信息，可以查看<a href="https://azure.microsoft.com/en-us/documentation/articles/fundamentals-introduction-to-azure" target="_blank" rel="external">这里</a></p>
<h3 id="Microsoft-Azure-Compute"><a href="#Microsoft-Azure-Compute" class="headerlink" title="Microsoft Azure Compute"></a>Microsoft Azure Compute</h3><p>按照以下步骤来创建一个虚拟机：</p>
<ol>
<li>登录<a href="https://portal.azure.com/" target="_blank" rel="external">Azure Portal</a></li>
<li>新建 -&gt; 计算 -&gt; Ubuntu Server 14.04 LTS，选择 <code>资源管理器</code> 作为 <code>部署模型</code></li>
<li>设置姓名、用户名和密码，新建一个资源组，点击确定</li>
<li>然后在大小选择中点击查看全部，选择 <code>A0 标准</code>，也就是最便宜的那个</li>
<li>后面的大部分内容都可以用默认值，然后点击确定就创建完成了</li>
</ol>
<p>Azure 有两种不同的部署模型：Azure Service Manager(ASM) 和 Azure Resource Manager(ARM)，后者更新也有更好的 API，所以我们尽量用后一种。</p>
<p>注意，在一种模型例部署的资源在另一种里看不到，更多信息可以访问<a href="http://blogs.msdn.com/b/cloud_solution_architect/archive/2015/03/17/rbac-and-the-azure-resource-manager.aspx" target="_blank" rel="external">这里</a></p>
<h3 id="Microsoft-Azure-Storage"><a href="#Microsoft-Azure-Storage" class="headerlink" title="Microsoft Azure Storage"></a>Microsoft Azure Storage</h3><p>类似于 Amazon S3，是一个可拓展的存储系统，有下面四种形态：</p>
<ol>
<li>Azure Blobs，类似 Amazon S3 的对象存储系统</li>
<li>Azure Tables，数据库</li>
<li>Azure Queues，应用的消息队列</li>
<li>Azure Files，文件系统</li>
</ol>
<p>现在我们主要接触一下 Azure Blobs，首先先要建立一个 Azure Storage 账户，按照下面步骤即可：</p>
<ol>
<li>新建 -&gt; 数据+存储器 -&gt; 存储(Storage account)</li>
<li><code>部署模型</code> 选择 <code>资源管理器</code>，然后指定唯一的名字</li>
<li>指定一个现有的资源组（刚才新建的那个就可以），然后在类型里选择 <code>L 本地冗余</code>（最便宜那个）</li>
<li>然后就可以创建了</li>
</ol>
<p>等待一段时间部署，部署完成后就可以通过 Azure 命令行工具来进行访问了。</p>
<h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><p>如果你对前面的命令感觉一头雾水，那么这一节要好好阅读了。下面是一些教程：</p>
<ol>
<li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="external">The Advanced Bash Scripting Guide</a></li>
<li><a href="https://github.com/jlevy/the-art-of-command-line" target="_blank" rel="external">The Art of the Command Line</a> <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="external">中文版本</a></li>
<li><a href="http://www.perl.org/" target="_blank" rel="external">Perl 指南</a></li>
<li><a href="http://www.python.org/" target="_blank" rel="external">Python 指南</a></li>
</ol>
<p>读的时候需要注意下面的内容：</p>
<ol>
<li>脚本语法，本地变量和环境变量</li>
<li>bash 中的 Quoting and back-ticks</li>
<li>利用 unix 管道进行输入输出重定向</li>
<li>使用类似 <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>cut</code> 等等来做基本的文本操作</li>
</ol>
<h3 id="Secure-Shell-SSH"><a href="#Secure-Shell-SSH" class="headerlink" title="Secure Shell(SSH)"></a>Secure Shell(SSH)</h3><p>简单来说 SSH 是一个用来进行安全数据通信、远程登录和远程命令执行的网络协议。</p>
<p>要想让一台服务器支持 SSH，需使用 <code>sudo apt-get install openssh-server</code> 安装服务，对应的配置文件在 <code>/etc/ssh/sshd.config</code> 中。可以使用 <code>sudo /etc/init.d/ssh</code> 或 <code>sudo service sshd [start|stop|restart]</code> 来进行管理。</p>
<p>SSH 支持若干中验证机制。比较常见的是通过密码验证。密码验证的安全性取决于密码的长度和复杂度，由于可以被暴力或者基于字典破解，所以对于公共访问的 EC2 instance 来说是比较危险的。</p>
<p>为此，所有的 EC2 instance 都使用基于公钥加密的 key-based 验证。一对密钥包含公钥和私钥，由数学方式如 RSA/DSA 生成并链接。只知道一个 key 的话，几乎不可能破解另外一个 key。</p>
<p>我们也可以生成自己的密钥对，在 Linux 中，密钥对通常存储在 <code>~/.ssh</code> 目录下，通过下面的代码就可以生成密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Generate a new key with your email id as a label</span></div><div class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"email_id@domain.com"</span></div><div class="line"></div><div class="line"><span class="comment"># Enter the file where you want to save the key: (recommended - choose default)</span></div><div class="line"></div><div class="line"><span class="comment"># You will be asked enter a pass-phrase for your key twice.</span></div><div class="line"><span class="comment"># (Use a strong pass-phrase. Longer pass-phrases are more secure than shorter ones.)</span></div><div class="line"></div><div class="line"><span class="comment"># After you provide the pass-phrase. The console will print the location of the key and the key fingerprint</span></div></pre></td></tr></table></figure>
<p>然后就可以导入这个密钥并用以连接 EC2，具体的做法可以看<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#how-to-generate-your-own-key-and-import-it-to-aws" target="_blank" rel="external">这里</a></p>
<p>举个例子，下面的代码会在远程实例执行 <code>uname -a</code> 命令，这种做法在批量运行远程实例命令的时候非常有用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ssh -i private_key_file.pem some-instance.ec2.amazonaws.com <span class="string">'uname –a'</span></div></pre></td></tr></table></figure>
<p>如果遇到 SSH 的 permission-denied 问题，很可能是由于不正确权限所导致，私钥的 unix permission 为 <code>600</code> 且包含私钥的目录的权限应为 <code>700</code></p>
<p>在执行 SSH 命令时，如果太久没有操作，就会自动断开，执行的脚本也会终止，如果不希望这样，有以下几种方式可以避免 SSH 超时：</p>
<ol>
<li><a href="https://docs.oseems.com/general/application/ssh/disable-timeout" target="_blank" rel="external">关闭 SSH 客户端的超时</a></li>
<li>用 <code>nohup</code> 执行脚本</li>
<li>通过远程屏幕管理(remote sreen management)来保持 terminal sessions</li>
</ol>
<p>通常来说我们用 bash shell 来进行远程操作，但是由于网络的缘故，一旦连接断开，所有已经启动的进程都会被终止。为了避免这种情况，使用 <code>nohup</code> 命令就非常有用了，即使连接断开，仍旧会继续运行命令。</p>
<p>另外一个比较有用的工具是 <code>byobu</code>，是一个多终端管理应用程序，类似于 <code>screen</code> 或者 <code>tmux</code>。</p>
<p>注：<code>byobu</code> 比较炫，但是我个人比较喜欢 tmux，参考 <a href="http://wdxtub.com/2016/03/30/tmux-guide/">tmux 指南</a></p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>用 Ubuntu 的话可以使用强大的 <code>apt-get</code> 来安装软件，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get install emacs</div><div class="line">sudo apt-get install vim</div><div class="line"></div><div class="line">sudo apt-get update <span class="comment"># 用来更新包索引</span></div><div class="line">sudo apt-get upgrade <span class="comment"># 用来更新包</span></div></pre></td></tr></table></figure>
<h3 id="文件所有者和权限"><a href="#文件所有者和权限" class="headerlink" title="文件所有者和权限"></a>文件所有者和权限</h3><p>Linux 的文件权限分为三个用户组：<code>user</code>, <code>group</code> 和 <code>others</code>，每组有三个权限：读(<code>r</code>)，写(<code>w</code>)，执行(<code>x</code>)。我们可以利用 <code>chmod</code> 命令来修改权限，如：<code>chmod 777 filename.txt</code></p>
<p>不用数字的话，可以用字母，<code>chmod u+x filename.txt</code> 这个命令就给 user 添加了执行权限。如果要更改文件所属，使用 <code>chown</code> 命令，具体可以参见 <code>man chown</code></p>
<h3 id="Linux-中的磁盘操作"><a href="#Linux-中的磁盘操作" class="headerlink" title="Linux 中的磁盘操作"></a>Linux 中的磁盘操作</h3><h4 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h4><p>许多 Linux 应用都可以管理磁盘分区，比如说 <code>parted</code> 和 <code>fdisk</code>。<code>fdisk</code> 是比较老的分区管理工具，现在几乎已经被 <code>parted</code> 取代，因为 <code>parted</code> 支持 GUID 分区表以及大于 2TB 的磁盘，所以我们这里使用 <code>parted</code>。</p>
<p><code>parted -l</code> 会列出系统中的所有分区。具体的顺序是按照 <code>/dev</code> 下的顺序。在 EC2 实例中，设备是 <code>dev/xvd**</code>，<code>/dev/xvda1</code> 是操作系统分区，<code>/dev/xvdb</code> 是实例的存储分区，注意 RAMDISK 不会出现在 <code>parted</code> 的输出当中。</p>
<p><code>parted</code> 还可以用来为每个分区设置类型和文件系统，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">parted /dev/xvdX mklabel gpt</div><div class="line">parted /dev/xvdX mkpart db ext4 0% 10G</div></pre></td></tr></table></figure>
<p>如果不加任何参数，<code>parted</code> 就会进入交互模式，这里你可以利用 <code>mkfs</code> 来格式化一个分区，如 <code>mkfs.ext4 /dev/xvdX1</code></p>
<h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><p>在分区和格式化之后，如果想要使用就需要把分区挂载在某个挂载点上，通常来说会挂载在 <code>/mnt</code> 或者 <code>/mount</code> 上，可移除的媒介，例如 USB 和 CDROM，会挂载在 <code>/media</code> 上，当然，你可以把分区挂载在任何地方，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir /storage/mountpoint</div><div class="line">mount /dev/yourdevice /storage/mountpoint</div></pre></td></tr></table></figure>
<h3 id="配置服务和启动"><a href="#配置服务和启动" class="headerlink" title="配置服务和启动"></a>配置服务和启动</h3><p>如果想要开机启动，需要参考应用本身的帮助文档，但是总体来说，服务需要安装在 <code>/etc/init.d</code> 中，这使得这些脚本可以在启动时运行。例如，如果 mysql 脚本在 <code>/etc/init.d</code> 中，那么可以使用这个命令 <code>service mysql [start|stop|restart]</code>。</p>
<p>想要了解更多，请参阅<a href="http://www.tldp.org/HOWTO/HighQuality-Apps-HOWTO/boot.html" target="_blank" rel="external">这里</a></p>
<h2 id="EC2-性能测试"><a href="#EC2-性能测试" class="headerlink" title="EC2 性能测试"></a>EC2 性能测试</h2><p>通常来说在云平台上用来计算的资源叫做虚拟机，也叫实例 instance。不是所有的实例都是一样的，在 AWS 中有一些可以定制的选择，比如说操作系统和硬件配置等等。</p>
<p>这一节的主要任务是了解虚拟机并在上面跑一些应用程序，借此来理解不同配置的不同表现。我们都知道更好的配置就性能更强，但是：</p>
<ul>
<li>更贵的是不是真的更好？</li>
<li>有没有什么办法来测量其性能表现？</li>
<li>性能的差别有多少？</li>
</ul>
<p>这些问题都不简单，但是这一节会给你一点点启发。</p>
<h3 id="启动不同类型的实例"><a href="#启动不同类型的实例" class="headerlink" title="启动不同类型的实例"></a>启动不同类型的实例</h3><p>虽然我们知道有几种不同的配置，但是除了纸面上的差别，真正的性能差别有多少呢？现在我们就来分别测试一下，按照以下步骤进行</p>
<ol>
<li>启动三个分别为 <code>t2.small</code>, <code>t2.medium</code>, <code>t2.large</code> 的实例，硬盘选择 30GB 的 General SSD，镜像选择 Ubuntu Server 14.04 LTS (HVM), General SSD Volume Type (ami-d05e75b8)。这里最好选择 <strong>spot instances</strong>，可以省点钱，更多请查看<a href="https://aws.amazon.com/ec2/spot/" target="_blank" rel="external">这里</a>。如果 spot instances 不可用的话，那么选择 on-demand instances</li>
<li>在启动这些实例的时候，需要指定 <strong>Security Group</strong>，创建允许 HTTP(TCP 端口 80) 和 SSH(TCP 端口 22) 的 security group</li>
<li>同样也需要指定一个已经存在的密钥对文件（或者生成一个）以连接这些实例</li>
<li>启动实例之后，可能需要等待几分钟，在 web 控制台可以查看目前的状况</li>
<li>用 SSH 及 PEM 文件来连接到这些实例。</li>
</ol>
<h3 id="系统性能评测"><a href="#系统性能评测" class="headerlink" title="系统性能评测"></a>系统性能评测</h3><p>我们需要在已经启动的实例中安装性能测评工具。通过这个来评估完成一个任务所需的最佳实例组合以做到多快好省。</p>
<p>虽然云服务提供商是利用虚拟化技术来提供资源，但是需要知道实例的性能一来不是稳定的，二来也不保证达到某个水平。这里我们使用 <code>sysbench</code> 来评估性能，它是一个轻量级跨平台的性能测试软件，能够快速评估 CPU，内存和文件读写性能。</p>
<p>用 <code>ssh -i keyfile.pem ubuntu@dnsaddress</code> 来进行连接</p>
<p>然后执行下面的命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install sysbench</div></pre></td></tr></table></figure>
<p>安装完成之后就可以按照给出的三个配置来进行测试。</p>
<p><strong>CPU 测试</strong></p>
<p>分别在三个不同的机器运行下列命令，统计结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sysbench --num-threads=8 --test=cpu --cpu-max-prime=20000 run</div><div class="line">sysbench --num-threads=1 --test=cpu --cpu-max-prime=40000 run</div><div class="line">sysbench --num-threads=4 --test=cpu --cpu-max-prime=50000 run</div></pre></td></tr></table></figure>
<p>表后面的三列分别是 <code>t2.small</code>, <code>t2.medium</code>, <code>t2.large</code> 的总时间</p>
<table>
<thead>
<tr>
<th style="text-align:center">Max Prime</th>
<th style="text-align:center">Thread</th>
<th style="text-align:center">Time(s)</th>
<th style="text-align:center">Time(m)</th>
<th style="text-align:center">Time(l)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20000</td>
<td style="text-align:center">8</td>
<td style="text-align:center">29.4015s</td>
<td style="text-align:center">14.8129s</td>
<td style="text-align:center">14.8693s </td>
</tr>
<tr>
<td style="text-align:center">40000</td>
<td style="text-align:center">1</td>
<td style="text-align:center">77.7609s</td>
<td style="text-align:center">76.0034s</td>
<td style="text-align:center">77.1984s</td>
</tr>
<tr>
<td style="text-align:center">50000</td>
<td style="text-align:center">4</td>
<td style="text-align:center">104.8054s</td>
<td style="text-align:center">51.5801</td>
<td style="text-align:center">52.4278s</td>
</tr>
</tbody>
</table>
<p>可以看到其实在当前任务下，<code>t2.medium</code> 与 <code>t2.large</code> 的性能差别并不大，就可以根据价格来进行取舍了。</p>
<p><strong>文件 IO 性能测试</strong></p>
<p>AWS 通常会保证 Input/Output Operations per Second (IOPS)。不同的硬盘访问逻辑对性能影响很大（缓存导致），传统的机械硬盘受寻址时间和旋转速度的影响，固态硬盘受驱动和设备控制器的影响。</p>
<p>同样用下面的命令来进行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sysbench --test=fileio --file-total-size=20G prepare </div><div class="line"><span class="comment"># 可能需要等待30分钟，使用 byobu / screen / tmux 来保持连接</span></div><div class="line"><span class="comment"># 或者可以在 iterm 设置中 profiles -&gt; sessions -&gt; When idel, send ASCII code</span></div><div class="line"><span class="comment"># 又或者 在客户端的 ~/.ssh/ 文件夹中添加 config 文件，并添加配置： ServerAliveInterval 60 </span></div><div class="line"></div><div class="line">sysbench --test=fileio --file-total-size=20G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">t2.small</th>
<th style="text-align:center">t2.medium</th>
<th style="text-align:center">t2.large</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read(Gb)</td>
<td style="text-align:center">3.8986</td>
<td style="text-align:center">3.9448</td>
<td style="text-align:center">5.6735</td>
</tr>
<tr>
<td style="text-align:center">Written(Gb)</td>
<td style="text-align:center">2.599</td>
<td style="text-align:center">2.6299</td>
<td style="text-align:center">3.7823</td>
</tr>
<tr>
<td style="text-align:center">Total trans(Gb)</td>
<td style="text-align:center">6.4976</td>
<td style="text-align:center">6.5747</td>
<td style="text-align:center">9.4559</td>
</tr>
<tr>
<td style="text-align:center">Speed(Mb/sec)</td>
<td style="text-align:center">22.178</td>
<td style="text-align:center">22.442</td>
<td style="text-align:center">32.276</td>
</tr>
</tbody>
</table>
<p>比较一下表中的数据，是不是随着价格的提高，性能也有对应比例的提高？</p>
<p>可以看到从 small 到 medium 几乎没有提升，但是到 large 就有比较大的提升。</p>
<h3 id="Web-服务器性能测试"><a href="#Web-服务器性能测试" class="headerlink" title="Web 服务器性能测试"></a>Web 服务器性能测试</h3><p>这里我们会在每个实例中安装和部署一个简单的 web 服务器，修改一下主页以便测试和评分。</p>
<p>LAMP = Linux + Apache + MySQL + PHP</p>
<p>用以下命令安装 apache：<code>sudo apt-get install apache2</code>。安装完成之后，用自己的浏览器访问这个实例的地址，应该就可以看到 Apache 的欢迎页面（这里需要在 Security Group 中允许 HTTP 访问）</p>
<p>如果访问 <code>cd /var/www/html</code> 就可以看到有一个 <code>index.html</code> 页面。我们把这个页面的内容替换成：<code>welcome to cloud computing</code> （<code>sudo vim index.html</code> 然后命令模式下 <code>dG</code>），再次访问的时候就可以看到变化了。</p>
<p>然后我们来安装 apachebench，也就是服务器管理器，命令如下：<code>sudo apt-get install apache2-utils</code>。安装完成后，输入 <code>ab</code> 应该能看到命令界面，一个简单的测试命令为：</p>
<p><code>ab -n 1000 -c 100 http://localhost/</code> (一次 1000 个 request，一共 100 次，最后是想要测试的页面)，然后就可以看到各种数据统计。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一节就塞这么多内容，不知道大家是感觉很爽还是亚历山大，总结一下，我们了解了不同云服务提供商的不同特点，也实际接触和操作了一把『云』，其中 Linux 基础是我们必须要掌握的。在云计算愈发普遍的今天，其实国内的很多社区也有出很多配套的教程，大家感兴趣的话，一定会被铺天盖地的广告轰炸的（感谢网友指出错别字）。</p>
<p>俗话说的好，万事开头难，接下来我们就会用一些更加接近实战的例子来与云亲密接触了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://aws.amazon.com/cn/" target="_blank" rel="external">Amazon Web Service</a></li>
<li><a href="https://aws.amazon.com/cn/cli/" target="_blank" rel="external">AWS 命令行界面</a></li>
<li><a href="https://www.azure.cn/" target="_blank" rel="external">Microsoft Azure 中国区</a></li>
<li><a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="external">Microsoft Azure</a></li>
<li><a href="https://www.aliyun.com" target="_blank" rel="external">阿里云</a></li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中最麻烦的往往不是开发本身，而是环境搭建，尤其是调通各种接口和服务。这一讲我会详细介绍如何把云资源用得像自家电脑一样省心。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之云计算】零 系列概览</title>
    <link href="http://wdxtub.com/2017/05/26/cloud-computing-overview/"/>
    <id>http://wdxtub.com/2017/05/26/cloud-computing-overview/</id>
    <published>2017-05-25T22:51:50.000Z</published>
    <updated>2017-07-04T07:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>云计算作为未来的大势所趋，是每个 IT 从业者都需要关注的，这个系列结合我从校园到工作中围绕云计算积攒下来的相关经验，分享给大家。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.26: 完成初稿</li>
</ul>
<h2 id="为什么要写？"><a href="#为什么要写？" class="headerlink" title="为什么要写？"></a>为什么要写？</h2><ul>
<li>云计算涉及的概念较多，很多基础框架不是特别牢固的同学容易顾此失彼，学得很痛苦</li>
<li>原先的 CMU 云计算课程笔记因校方压力下架，一直没有机会重制</li>
<li>结合校园与工作中的经验，更有针对性，更多干货</li>
</ul>
<h2 id="能带给读者什么？"><a href="#能带给读者什么？" class="headerlink" title="能带给读者什么？"></a>能带给读者什么？</h2><ul>
<li>云计算核心组件的理论知识</li>
<li>云计算实战中的小技巧</li>
<li>Linux 运维实战经验</li>
<li>如何利用云计算完成简单服务的搭建</li>
<li>如何优化架构，提升云服务性能</li>
<li>培养朝抵抗力最大的路径走的坚定，学会如何去学习。</li>
</ul>
<p>这也是我写新技术系列的一次尝试，让互联网上高质量的中文内容多一些，再多一些。</p>
<h2 id="有什么局限？"><a href="#有什么局限？" class="headerlink" title="有什么局限？"></a>有什么局限？</h2><ul>
<li>这不是一个可以速成，看看就懂的系列，需要自己动手去实践。话说回来，天底下的真功夫，也没有能够速成的。</li>
<li>工作量比较大，会花费很多实践，需要不断尝试，不断跌倒再爬起，而这正是『深入理解云计算』的必经之路。</li>
<li>需要自行探索的部分很多，我个人的知识体系并不完备，欢迎大家在评论中各抒己见，让这个系列更加完美。</li>
</ul>
<p>在这个快节奏的时代，慢一点，再慢一点。</p>
<h2 id="主要写什么？"><a href="#主要写什么？" class="headerlink" title="主要写什么？"></a>主要写什么？</h2><ul>
<li>从基本概念入手，辅以图片，尽量用具体实例阐述推导和思考的过程，不用『显然』偷懒，不用『易知』搪塞。</li>
<li>逆推设计过程，还原具体情境，为什么会有不同的设计不同的系统，寻找『三江源』。</li>
<li>理论结合实践，深入浅出介绍云计算，包括：云设施，虚拟化，云存储，编程模型等等</li>
</ul>
<p>对自己的要求是写作的时候，细致一点，再细致一点。</p>
<p>注：主要在 Amazon Web Services 和 Microsoft Azure 上试验，后面会加上国内的云服务</p>
<h2 id="不会写什么？"><a href="#不会写什么？" class="headerlink" title="不会写什么？"></a>不会写什么？</h2><ul>
<li>不会重复网上已有的教程与概念，这个系列并不是一个资料汇总，而应该是『学习伴侣』，有自己的思考，再来看看我的思考和大家的思考，这样才是最高效的学习。</li>
<li>不会大段贴代码，这个系列并不是一个手把手帮读者完成任务的系列，而是授人以渔的系列</li>
<li>不会详述只需要简单搜索就可以找到答案的问题，希望能专注于那些『不懂甚至不知道如何搜索』的问题，并以此鼓励大家培养自己主动探索解决问题的能力</li>
</ul>
<p>对读者的要求是学习的时候，走一步，再走一步。</p>
<h2 id="具体编排"><a href="#具体编排" class="headerlink" title="具体编排"></a>具体编排</h2><p>注：这部分可能会不断变化</p>
<ul>
<li><a href="">壹 云计算平台初探</a><ul>
<li>云平台入门与 Linux 基础(cc2345678)</li>
</ul>
</li>
<li><a href="">贰 编程模型与资源调度</a><ul>
<li>串行、并行、自动扩展(cc9 10 11)</li>
</ul>
</li>
<li><a href="">叁 负载均衡与缓存</a><ul>
<li>为什么需要负载均衡，缓存是如何提高服务效率(cc12 cc13)</li>
</ul>
</li>
<li><a href="">肆 分布式存储那些事儿</a><ul>
<li>不同存储方式与分布方式、一致性</li>
</ul>
</li>
<li><a href="">伍 OLAP 与 OLDP</a><ul>
<li>思想、套路与实战</li>
</ul>
</li>
</ul>
<h2 id="细节知识点"><a href="#细节知识点" class="headerlink" title="细节知识点"></a>细节知识点</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>解释云计算的<strong>核心概念</strong></p>
<ol>
<li>解释什么是『云计算』</li>
<li>云计算历史介绍，了解动机与演变</li>
<li>列举云计算中重要的技术，并讨论其特点</li>
<li>了解云的优势与劣势</li>
<li>了解云对商业和云服务提供商的经济利益和风险</li>
<li>联系云架构的不同层级并区分不同的服务模型</li>
<li>定义 SLAs 和 SLOs 并说明其重要性</li>
<li>列举和解释云安全的各类威胁</li>
<li>给出常见的云服务提供商与其云架构</li>
</ol>
<h3 id="云设施"><a href="#云设施" class="headerlink" title="云设施"></a>云设施</h3><p>通过在<strong>云设施</strong>上应用基础概念来理解性能，效率和花费之间的权衡，并以此去思考如何建立起健壮，有弹性和高效的数据中心</p>
<ol>
<li>描述数据中心的演化并给出现代数据中心的架构</li>
<li>思考设计的考虑并讨论不同的影响</li>
<li>描述如何计算一个数据中心的能源需求</li>
<li>理解云架构数据中心的需求和挑战，并分析其和大型计算机的不同</li>
<li>解释云软件的不同层级与每层扮演的角色</li>
<li>了解自动化资源管理的必要性和关键的规划考虑</li>
<li>评估在云上编程，部署和失败的考虑</li>
<li>理解构建多层云应用的概念，并考虑延迟，可伸缩性与健壮性</li>
<li>了解不同的计价模型与对应的商业模式</li>
<li>描述云管理技术，例如 middleware，resource provisioning，metering 和 orchestration</li>
<li>从规模，负载均衡，容错，延迟，优化和花费等角度来描述评估不同的云部署方案</li>
</ol>
<h3 id="云资源管理"><a href="#云资源管理" class="headerlink" title="云资源管理"></a>云资源管理</h3><p>了解<strong>系统，网络和存储虚拟化</strong>并理解它们在云计算系统模型中扮演的角色</p>
<ol>
<li>理解为什么虚拟化在云上非常重要的主要原因</li>
<li>解释通过虚拟化提供的不同隔离类型，例如错误隔离，资源隔离和安全隔离</li>
<li>理解为什么系统复杂度可以通过不同层级的抽象，良好定义的接口和虚拟化的应用来管理</li>
<li>理解资源共享，并解释是如何通过虚拟化来做到物理和逻辑层面的分离</li>
<li>理解虚拟化，并区分不同的虚拟机类型，例如进程和系统虚拟机</li>
<li>理解虚拟化 CPU 的条件，区别全虚拟与部分虚拟，理解作为 CPU 虚拟化主要技术的 emulation，并检查 Xen 中的虚拟 CPU 调度</li>
<li>列出传统操作系统虚拟内存和系统内存虚拟化的区别，解释多层页映射，并通过 VMWare 的 memory ballooning 技术来理解 memory over-commitment</li>
<li>解释 CPU 和 IO 设备如何在虚拟化/非虚拟化情况下进行通信，理解三个主要接口：系统调用，设备驱动和操作层级</li>
<li>从云计算的角度列出 software defined networking 和 software defined storage 近期的发展</li>
</ol>
<h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>理解<strong>云存储</strong>的基础概念，并描述它们是怎么应用在诸如 Amazon S3 和 HDFS 这类存储系统上的</p>
<ol>
<li>描述数据和存储的总体组织</li>
<li>列举不同的数据类型并给出它们的对比</li>
<li>了解规模化可能出现的问题与大数据管理，讨论不同的存储抽象</li>
<li>比较不同的文件系统，并思考它们的设计考虑，如 HDFS vs CephFS</li>
<li>比较不同的数据库并讨论它们的设计权衡</li>
<li>了解云对象存储的概念，列举数据存储中所用的 block devices</li>
</ol>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>分析不同的<strong>云计算模型</strong>，并应用它们来在云上解决问题</p>
<ol>
<li>理解并行和分布式编程模型的基础概念</li>
<li>对比不同的云编程模型：MapReduce, Spark, GraphLab 和 Spark Streaming</li>
<li>解释 MapReduce 编程模型中主要的执行流，调度和容错概念</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://www.cloudcomputingpatterns.org/" target="_blank" rel="external">Cloud Computing Patterns</a></li>
</ul>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>优秀人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力从海量机会中找到最适合的那个。100offer 会对平台上的人才和企业进行严格筛选，让「最好的人才」和「最好的公司」相遇。</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&amp;utm_medium=display&amp;utm_campaign=wdxtub_20170703&amp;utm_content=find_new_job&amp;campaign_code=wdxtub" target="_blank" rel="external">点击注册 100offer</a>，谈谈你对下一份工作的期待，收获 5-10 个满足你要求的好机会。</p>
 <a href="https://cn.100offer.com/how-it-works/?utm_source=wdxtub&utm_medium=display&utm_campaign=wdxtub_20170703&utm_content=find_new_job&campaign_code=wdxtub" target="_blank" rel="external"> <img src="/misc/100offer.jpg" alt=""> </a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云计算作为未来的大势所趋，是每个 IT 从业者都需要关注的，这个系列结合我从校园到工作中围绕云计算积攒下来的相关经验，分享给大家。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="导论" scheme="http://wdxtub.com/tags/%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
</feed>
