<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2017-08-10T13:35:35.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第六十一周 - 老神仙</title>
    <link href="http://wdxtub.com/2017/08/10/old-god/"/>
    <id>http://wdxtub.com/2017/08/10/old-god/</id>
    <published>2017-08-10T13:34:50.000Z</published>
    <updated>2017-08-10T13:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>长长长地远远远地深深地流浪在心间，叮叮叮地咚咚咚地悠悠的铃声在耳边。风儿带我来到一个地方，那里有一棵大树，树上有个老神仙轻轻叫我的名字。</p>
<p>注：因为本周末有其他事情要忙，所以周记提前发。</p>
<a id="more"></a>
<hr>
<p>今天上午的一场暴雨愣是下出了台风过境的感觉，让深圳降温不少。这场雨来得快去得也快，潇洒走一回，痛快。本周因为个人原因只能工作四天，所以大部分工作是为接下来的开发做统筹计划。除了部分文档的工作之外，也开始在阅读和修改其他组的代码中思考软件工程的最佳组织形式。幸好软件工程已经过了最原始的刀耕火种时期，有如此多成功的项目珠玉在前，很多时候我们只需要在前人的肩膀上看看风景就好。</p>
<p>随着项目的不断深入，我愈发能够理解 Unix 的哲学，即 KISS(Keep It Simple, Stupid)，项目中的各种判断和选择都需要在实践中不断去优化，但总体原则不应该与 Unix 的哲学背道而驰，这里列举一下《Unix 编程艺术》中的几段话：</p>
<ol>
<li>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂</li>
<li>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入</li>
<li>尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。</li>
<li>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。</li>
</ol>
<p>Rob Pike，最伟大的 C 语言大师之一，在《Notes on C Programming》中从另一个稍微不同的角度描述了 Unix 的哲学</p>
<ul>
<li>原则一：你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在</li>
<li>原则二：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度</li>
<li>原则三：花哨的算法在 n 很小时通常很慢，而 n 通常很小。花哨算法的常数复杂度很大。除非你确定 n 总是很大，否则不要用花哨算法（即使 n 很大，也优先考虑原则 2）</li>
<li>原则四：花哨的算法比简单算法更容易出 bug、更难实现。尽量使用简单的算法配合简单的数据结构 原则五：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法</li>
<li>原则六：没有原则六</li>
</ul>
<p>另外周三的时候终于把公司的年度体检完成了，对于习惯了学校大杂烩体检的我来说，第一次参加比较商业化的体检，发现其流程已经优化到非常细致的地步，比如说每个人都有一张卡，这张卡唯一的用途就是扫一下完成身份录入，完成第 n 项体检项目之后，医生会把第 n+1 项的房间号写在表格中，我只需要按图索骥即可，不用去一个一个看哪个项目人多人少，机器自动调度分配，这种情况下其实能够到达某种程度的时间最优化（这就是流程优化的价值了）。在检查内科的时候，老医生听了听我的心跳又按了两下，就问我是不是之前减肥了十来斤（确实是减了）。我当时很震惊，居然这都可以！后来医生说这样好，太胖了不健康，主要是少吃，运动太剧烈，以后关节就受不了。</p>
<p>另外一个事情是周中的时候租了两天车，毕竟好久没摸了，还是要熟悉一下在国内开车的感觉，经过两天的高密度联系，感觉已经恢复了七成功力。对于这种偏实践类的技能，在基本的意识达标之后，最重要的就是熟练度的提高。所谓基本的意识，就是知道什么是安全的和不安全的，什么是应该做的和不应该做的。所谓熟练度，就是指面对不同情况的最佳处理方式。开车和其他生活中的事情一样，靠的就是预测和判断，而在预测和判断的过程中最重要的就是冷静，而保持冷静其实是最难的一步，也是新手和老司机最大的差距点。</p>
<p>这段经历又让我有了一点思考：即如何快速成长为老司机，不过我们首先要弄清楚新手到底『新』在哪里。新手的『新』我认为主要体现在三点，一个是概念新，一个是经验新，最后是意识新。</p>
<p>概念新好理解，就是在面对一个新的领域的时候，基本的术语和『黑话』都不熟悉，也没有把新的概念和自己原有的知识技能体系对接起来，要摆脱概念新的阶段，最快的方法就是大量吸收各种高质量的领域信息并不断思考借此与原有的知识框架对接，不要想着有用才学没用就不学，要知道作为新手，是连有用还是没用都没办法判断的。</p>
<p>经验新指的是在面对理论结合实际中的各种可能发生的异常情况时的本能反应，即使离开了概念新的阶段，很多现实生活中的奇怪情况会让新手头皮发麻继而进入又瓜又皮的状态。想要快速脱离经验新，最好的方式就是从他人的经历中学习（文字、多媒体等），甚至再浮夸一点，在脑中不断模拟也能起到同样的效果。</p>
<p>而意识新则需要更多的努力才能摆脱，即如何才能不像一个新手一样思考。这个话题展开就比较大了，感兴趣的同学可以看看<a href="http://wdxtub.com/2013/08/16/pragmatic-thinking-and-learning/">这里</a>，我列举一些简单的诀窍：</p>
<ul>
<li>新手和专家有着根本区别，他们看待世界的方式不同，反应也不同</li>
<li>新手使用规则，专家使用直觉</li>
<li>成为一名专家的关键要素：应用你自己的实践经验、理解情境和利用直觉</li>
<li>相信直觉，但是要验证</li>
</ul>
<p>NBA 有个说法，不要低估一颗总冠军的心，当然我并不是要拿什么总冠军，我只是想要成为一个值得依靠的人。</p>
<p>放松，呼吸，放松，呼吸。我的奔跑你能看得见，我的歌声你会听得见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;长长长地远远远地深深地流浪在心间，叮叮叮地咚咚咚地悠悠的铃声在耳边。风儿带我来到一个地方，那里有一棵大树，树上有个老神仙轻轻叫我的名字。&lt;/p&gt;
&lt;p&gt;注：因为本周末有其他事情要忙，所以周记提前发。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第六十周 - 你来不来</title>
    <link href="http://wdxtub.com/2017/08/05/come-or-not/"/>
    <id>http://wdxtub.com/2017/08/05/come-or-not/</id>
    <published>2017-08-05T00:08:36.000Z</published>
    <updated>2017-08-05T03:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里有阳光有月亮，这里有梦想有期望，这里有风雨有冰霜，这里有热血有力量，这里有生命有希望，这里有男儿当自强。</p>
<a id="more"></a>
<hr>
<p>炎热的夏日终于在两场大雨之后再次进入了消停模式：晚上散步不再是蒸桑拿，夏夜晚风终于成为令人心旷神怡的存在。转眼便来到了八月，再转眼便想到『八月秋高风怒号，卷我屋上三重茅』。仔细想想，南方大概是没有四季的概念的，这样其实挺好，不会像之前在匹兹堡那样，秋天冬天冷得压根儿不想出门。不过四季分明也有分明的好处，让人确确实实感知到四季的变化和时间的流逝，毕竟在广州和深圳，总是感觉一年一年飒飒飒就过去了。</p>
<p>这周基本完成了深度学习平台最后的两块拼图：优先队列和调度器。这俩组件的机制并不复杂，通过优先队列对不同的任务进行排队，通过调度器保证集群内负载均衡的同时提高硬件利用率。队列的机制参考了 Hadoop 和 Spark 的方式，无非就是每个任务有几个不同的状态，通过不断更新任务状态来决定下一步行动，是一个简单的状态机。调度器其实可以看作是一个条件匹配的算法，找到能够满足需求的最合适的机器，往细里说就和内存分配机制差不多，往大里说就跟物尽其用人尽其才差不多。之所以把这两个模块留在最后，不是因为这俩有多难，而是因为只有在完成了其他模块之后，才能更加清楚这两个核心模块的重点需求是什么，从实际出发，才能找到最合适的解决方案。</p>
<p>忽然意识到，凭空想象的需求和理想状态的乌托邦一样，都是看起来很美好，但是本身就和永动机一样，一不现实二不可能不过是镜花水月。正确的做法是立足先当下的实践，找到拖慢效率的短板，然后努力去提高。那些一上来就搞什么生态搞什么万里长城护城河的，基本都是骗子和忽悠，毕竟多少人只做一个事情都做不好，怎么就觉得同时做很多事情就可以做好呢，不能每个人都是 Elon Musk 吧。</p>
<p>在我看来，深度学习平台存在的意义就是把平时进行机器学习和深度学习的需求中的最大公约数提取出来，去流程化那些能够流程化的，把痛点解决好即可，没必要去指定死板的流程和框架。具体实现的指导思想也很简单：努力把大部分事情做成一键完成，尽量简化步骤和封装功能的同时，提供配置文件或 DSL 供高级需求使用，能做到这一点，就已经足够了（当然稳定安全什么的是基本需求，这里不提）。</p>
<p>上周买了个 Apple Watch，发现最合适的场景只有一个 - 运动，借着这股东风我也重新恢复了运动，该跑跑该跳跳，随着最开始的肌肉酸痛褪去，整个人的精神状态也好了不少，果然还是要好好运动呀。</p>
<p>《战狼2》这部电影不出意外应该是今年最佳，虽然不是尽善尽美，但是有足够多的闪光点，在这个烂片当道的时期简直是好单纯好不做作一看就跟其他出来骗钱的妖艳贱货不一样，当然要去二刷！</p>
<p>昨天看到一篇介绍谢楠和吴京的文章，大意就是他们俩是夫妻和家庭的一个好的示范。可能很多人看到的第一反应就是娱乐圈真真假假，不知道是演技还是真实，但我觉得其实大可以换一个角度去看。我们看到的是不是明星们真实的一面从某种意义上来说并不重要，重要的是我们能不能从中看到有可能达到的美好的程度。也就是说，通过这些或真或假的浮光掠影，让我们看到一个努力的方向，就足够了，我们就可以按照我们想要的生活去努力了。就好像指着月亮的手，我们看到了但愿人长久千里共婵娟，就不用在意这是真手还是假手了。比如下面几句谢楠说的话：</p>
<blockquote>
<p>我希望能够在你很辛苦、很累的时候让你开心。在没有人支持你的时候做唯一支持你的人。在全世界都为你欢呼的时候，在角落默默为你鼓掌叫好，就可以了。你不用给我承诺太多，你就努力向前冲吧，家里有我。</p>
<p>微博上有人问我为什么这么努力工作，我回答得特别简单，我希望有一天当我找到那个人时，我能够特别坦荡地说，我就是因为爱他，才跟他在一起，不是因为他是谁，不是因为他有什么，因为我能给我自己所有的东西。</p>
<p>其实我不是一个小女人，但是身边有个这样的男人很好，你敢去依赖他和依靠他，换一个人，你可能会说，我为什么要去示这个弱撒这个娇。家庭事业排序呢？永远排不出来，在我心中都是很重的，我的家庭需要我去工作，我的工作也需要家庭的支撑。</p>
</blockquote>
<p>想想和子妍在一起的日子，我也深有这种体会。生活不是一个纯逻辑的过程，很多时候是没有所谓的顺序和优先级的，心往一处想，力往一处使，问题就不会太大。当我的生活中出现了这样一个独立有想法也愿意为对方付出的人之后，我才真正意识到 $e=mc^2$ 的意义所在。</p>
<p>没有伪装没有奖赏没有遗忘没有白忙，要的就是痛快，要的就是存在，你说你来不来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里有阳光有月亮，这里有梦想有期望，这里有风雨有冰霜，这里有热血有力量，这里有生命有希望，这里有男儿当自强。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第五十九周 - 有一种云</title>
    <link href="http://wdxtub.com/2017/07/30/one-kind-of-cloud/"/>
    <id>http://wdxtub.com/2017/07/30/one-kind-of-cloud/</id>
    <published>2017-07-30T01:48:02.000Z</published>
    <updated>2017-07-30T01:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一种云，缓缓飘过你的头顶；有一种云，是蓝丝绒上的棉絮；有一种云，慵懒地贴在你眼底。</p>
<a id="more"></a>
<hr>
<p>转眼七月也来到了末尾，除了越来越热的天气让人有些烦躁（毕竟户外的活动基本都报销），生活的各个方面都在以不错的加速度向前。不同时期有不同时期的追求，不同人有不同人的方向，只要在按照自己的想法去生活的同时而不被生活限制太多，就是一件挺幸福的事情了。</p>
<p>从前在大疆的时候，我基本上除了运维的活不用做之外，从产品到设计到前端再到后端都要做。而现在在追一，我连运维都要做了，还要捣鼓深度学习具体落地的方案，技能树在乱点一波之后竟神奇地练成了一片，感觉还是挺神奇的。要我说，去创业公司是快速 stackoverflow 的最佳方式（当然前提是能够接触到核心，而不是打酱油的那种）。</p>
<p>工作上，这周继续在做深度学习平台，平台这个东西，做出来容易，做好了难，很多时候难点不在于技术实现，而在于合适。这里的合适指的是使用平台的各方都能用得舒服。对于算法组来说，平台需要能够高效调度计算资源，缩短每次训练和测试的时间；对于产品组来说，平台需要能够无缝对接数据库与模型库，并可以根据不同的指标来进行监控；对于数据组来说，平台需要能够高效便捷测试不同的数据方案，并对结果进行跟踪。考虑到不同人的不同需求，最后选择了基于 Docker 的一套解决方案，一是方便配置和管理，二是易于扩展，毕竟基于 Docker 的方案已经广泛应用开来。但在配置的时候发现网上的文章都没有时效性了，所以我决定自己写一篇，正所谓自己动手，丰衣足食（更不用说写博客可以记得更牢，研究得更透彻了）。</p>
<p>做深度学习平台遇到的另一个困难是，不同组不同人之间的工作流程和模式有比较大的差别，如何能在平台中提供通用的支持呢？经过一段时间的探索，最关键的是把握重点，重点就是模型，无论是训练测试验证还是更新，都是围绕模型这一最终产出的。另外因为是集群调度，还需要一个队列+调度器，那么这个队列里放的就是函数本身，目前是需要根据不同的流程来定制的，但后期可以做一个 DSL，就可以完美支持大部分的需求了。</p>
<p>关于工作最后再播报两个好消息，第一个是我们公司上电视啦，随着业务越做越好，相信后面会有更大得发展的；第二个是随着公司发展壮大，终于正式确定了朝九晚六每周五天的工作模式（当然事情做不好肯定是要加班的）。现在我有更多的时间可以提高自己，还是很开心的，于是在这里再发一波招聘，有对 Go/云平台/机器学习/数据挖掘感兴趣的小伙伴，请把简历狂甩过来。</p>
<p>因为看到子妍每天都在背单词，所以我也决定要一起背，毕竟人不学不成器技多不压身。两个人能够一起学习一起运动一起成长，是一件非常有意义的事情。工程做得多了，就会带着工程师得眼镜去看待一切，比方说，爱情同样也有工程学。网上的各种理论（虽然大部分都是以偏概全博眼球的）可以看作是爱情工程的理论部分（对应于软件工程），但在实际的生活中（对应于实际开发），理论和实际是有很多差距的。如果想在一段亲密关系中成为优秀的爱情工程师，就需要拥有一些工程师的常识。比如：</p>
<p>只要大家力往一处使，就没有搞不定的事情。</p>
<ul>
<li>选择优秀的同伴。避免出现『不怕神对手就怕猪队友』的情况，所以喜欢谁和谁在一起需要精挑细选</li>
<li>选择可以互相理解的同伴。默契是互相理解到一定程度的自然产物，如果不能够互相理解，两个人可能在诸多方面无法合拍，是没有办法异口同声不约而同心心相印的</li>
<li>好的开始是成功的一半。项目最关键的部分可以说是开头，毕竟惯性和习惯形成之后是很难更改的。而且一开始会遇到比较多的问题，这时候不能逃避，而是解决问题并找到根源，避免以后再出现类似的情况</li>
<li>不期待完美。很多理论上非常完美的方案，在现实中是行不通的，工程中最重要的也不是去追求最优解，而是避免得到最差的解。与其花成倍的精力去赌 100%，不如直接踏踏实实做到 90%</li>
<li>问题不止一种解法。大部分情况下不同角度会有不同的解法，只要跳出原有的框架，反而会发现很多有趣的东西</li>
<li>不依赖运气或自欺欺人的侥幸。亲密关系很多时候会让人的情感变得更加敏感，如何在两个人波动的敏感度中找到动态平衡，需要两个人的努力，而不是认为对方有读心术</li>
<li>认识世界的复杂度，总有备选方案。现实世界会有各种各样奇怪的问题，如果只做最好的打算，肯定会失望大于希望，但是凡事做好预案，就能够游刃有余</li>
<li>坚持不懈。做工程是一环扣一环的持久战，只有每一个环节都做好，才能有好的结果，不然没做好的就会成为短板</li>
<li>留下一些彩蛋。有趣的工程师会把情趣加入到项目中，生活需要不同的色彩，相处也需要常常制造惊喜</li>
</ul>
<p>有一种云，来就放晴走就下雨，只追寻你的足迹，直到月落乌啼。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一种云，缓缓飘过你的头顶；有一种云，是蓝丝绒上的棉絮；有一种云，慵懒地贴在你眼底。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
  </entry>
  
  <entry>
    <title>第五十八周 - 想要去的地方</title>
    <link href="http://wdxtub.com/2017/07/21/place-to-go/"/>
    <id>http://wdxtub.com/2017/07/21/place-to-go/</id>
    <published>2017-07-21T03:37:49.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要去往，遥远地方，想证明自己不一样。天很宽，路很长，跌撞中成长。</p>
<a id="more"></a>
<hr>
<p>印象中，自我从马来西亚玩回来之后，深圳就一直在下雨。于是日子就陷入了『下雨啦好凉快但是拖鞋长期是湿的』和『出太阳了不用带伞但是要被烤焦』的两难境地。天气热了人也容易上火，但经过一周的粥粥粥试验我也意识到了吃肉的重要性。肉是要吃的，但是不能贪多，尤其不能连续两天出去吃香喝辣，一周出去吃一次换换口味就好。</p>
<p>周末和子妍去二刷了《大护法》，这次我们看的是粤语版，万万没想到和国语配音有完全不一样的效果，一部比较成人向的动画愣是全屏笑点，我怀疑是不是自己看周星驰太多，以至于感觉粤语有着天然的搞笑成分。网上对《大护法》这部电影的分析已经太多太多了，我倒是觉得见仁见智，没有必要硬去凑各种高深的主题，看过，哭过笑过，觉得不错，其实就够了。如果还感兴趣的话，建议看一下导演不思凡之前的作品，一定会有同样类似的感觉。</p>
<p>这周工作上继续回归我的主线任务 - 深度学习平台，不过我又结合之前的一些工作，力求让整个系统不仅仅局限在深度学习上，比如说传统的机器学习，甚至是数据清洗和统计的工作，都可以方便的集成进来。随着工作的推进，整个系统慢慢也变得清晰，最核心的部分其实是分布式调度和工作流的支持。分布式调度使得计算资源可以线性扩展，不会出现规模上去了但是架构不支持的情况；而工作流的支持则是以一个足够通用的模型去规整现有的代码和流程，使得不同的任务可以排队执行，不同的数据可以重复利用，不同的模型可以快速应用，不同的业务可以快速上线，把开发人员从日常的琐碎事物中解放出来。</p>
<p>做系统最重要的不是优美的实现或者是顺畅的架构，而是一以贯之的概念集。意思是无论从数据流、逻辑流还是业务流的角度来看系统，不同的概念都是一致的，不会说同一个东西，在不同的语境下就变成了不同的表现。这种统一的底层设计会极大影响产品思路和最终呈现出来的东西，概念对齐了，实现和表现的对齐其实就是简单的事情了，这才是 simple is the best 的题中之义。</p>
<p>正因为如此，我在系统的构建过程中，从逻辑框架到具体的实现，都力求保持一致。比方说对于某个 Job 来说，系统支持两种启动方式 Run 和 Start，其中我规定 Run 是同步执行，即要等待 Job 结束，而 Start 则是启动就立即返回，并不等待 Job 完成（注：这个分法来自于 Go 的设计）。那么从 View 到 Controller 再到 Model，整个概念都是一致的，不会说在一个地方 Run 是等待，而另一个地方 Run 是不等待。这样以来，不但我开发的舒服，别人用起来也很舒服。</p>
<p>另外值得一提的是，博客迁移已经基本完成（主要的时间是在等待新域名的备案通过），之后就会逐渐把中心转移到新的博客上啦，但是老的博客依然会一直在这里（毕竟我写了这么多嘛）。今天有网友问我为什么要启用 hexo 选用 typecho，主要原因有二：一是随着各大国内访问方便的博客评论系统的关闭，旧的静态网站 + 外挂评论插件的方式已经基本不可行（其他方案不是没有，但是用户体验不好，毕竟爸爸妈妈也要看）；二是 hexo 的性能还是有问题，一般来说我发布一篇新的文章从编译到上传快则五分钟慢则半小时，实在是比较痛苦。</p>
<p>还记得《悟空传》中脍炙人口的一句话『若一去不回，便一去不回』，我可以仿写一句『若从头再来，便从头再来』，新的博客，新的思路，也算是一种传承和进化，我觉得也是挺好的事情。至于博客的重构计划，主要是针对原来博客中多而杂的内容。具体的组织形式会以系列的方式分不同维度进行划分（这部分借用上周）：</p>
<ul>
<li>按照领域分类<ul>
<li>机器学习（深度学习/数据挖掘）</li>
<li>云计算（框架、架构）</li>
<li>计算机科学（CSAPP，算法，数据结构）</li>
<li>无人机</li>
</ul>
</li>
<li>按照目的分类<ul>
<li>求职</li>
<li>团队建设</li>
</ul>
</li>
<li>按照项目分类<ul>
<li>Patriots</li>
<li>日志分析平台</li>
</ul>
</li>
<li>按照系列分类<ul>
<li>朝花夕拾（周记和回忆）</li>
<li>试说新屿（原来的所有效率类和乐活类文章会合并到这里，包括爱好、摄影、阅读、写作）。需要严格限制文章的篇数，一篇就讲清楚一个完整的事情。按章节分，不超过十二章（十二生肖作为章节名）</li>
</ul>
</li>
</ul>
<p>因为现在自己有服务器了，所以除了私有云笔记，还搭建了私有云存储和私有在线图书馆（具体教程后面会写）。云存储采用了 <a href="https://www.seafile.com/home/" target="_blank" rel="external">Seafile</a> 开源方案，可以全平台同步不说，配置简单，用起来也很省心。在线图书馆采用的是 <a href="https://github.com/idalin/calibre-web" target="_blank" rel="external">Calibre-Web</a>，可以在线查看编辑推送到 kindle，就很有灵性。</p>
<p>One more thing，子妍和我的双人博客也在缓慢地搭建中，希望能尽快跟大家见面。至于为什么要搞这个博客，一是想采取《生命最后的读书会》中的方法，通过阅读和交流，让彼此能够有更加深入的了解，二是觉得完全可以找个地方把我们生活中精彩的灵光乍现的碎片收集起来，过后看看肯定觉得很有意思。最重要的，能够两个人一起经营同一片天地，是很幸福的事情。生活有了如此奇妙的转变是我未曾想到的，但是现在的我每天都很开心，想要为我们的将来，多添上一些美好的色彩。</p>
<p>哪怕前方，雾都茫茫，要相信自己会坚强。不害怕，不绝望，去穿过黑夜，奔向心中的光。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要去往，遥远地方，想证明自己不一样。天很宽，路很长，跌撞中成长。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="搬家" scheme="http://wdxtub.com/tags/%E6%90%AC%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>第五十七周 - 将进酒</title>
    <link href="http://wdxtub.com/2017/07/14/lets-drink-wine/"/>
    <id>http://wdxtub.com/2017/07/14/lets-drink-wine/</id>
    <published>2017-07-14T15:00:07.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>君不见黄河之水天上来，奔流到海不复回。</p>
<a id="more"></a>
<hr>
<p>连绵的雨天终于有了要结束的迹象，炎炎夏日重新成为了生活的背景板，早点起床早点上班不但能躲烈日还能早点下班回家吃饭，怎么看都是一个好习惯。结束了上周的高强度工作，这周的工作更多回归到了我的主线任务 - 深度学习平台。在不断的迭代开发中，慢慢意识到最适合公司发展的系统，才是最好的。从最简单的做起，不搞太多花里胡哨的，大巧不工，大智若愚。</p>
<p>自从开发了电饭煲的『煮粥』功能，喝粥就成了我最新的快速填饱肚子兼食疗的方法。半杯米，两三把绿豆，一两把薏仁，煮上三四个小时，那就是一锅清凉去火的绿豆粥了。早上煲好，中午晚上都不会饿肚子，除了时不时想吃肉之外，其他都很好。不油腻，简简单单清清淡淡，给身体的负担没那么重，就很舒服。</p>
<p>几个月前，我之前用的多说评论系统宣布停止服务，于是我换成了网易云跟帖，而现在网易云跟帖也要停止服务了，我还能怎么办呢？数字时代的生存法则和现实生活有很大的不同，那些无形的数据资产，很可能因为服务提供方的一个决策而成为空中楼阁，给我的生活和工作流程带来很大的影响。</p>
<p>既然别人的服务靠不住，那我就自己搞吧！于是轰轰烈烈的博客搬迁升级计划悄然展开。梳理了自己生活工作流程中的痛点时发现，有技术有心情的人可以自己折腾（自建服务器并搭建专属服务）；没有技术也没有心情的人最好直接付费（省心省力）；如果不想付费，要么就得忍受广告，要么就是拿自己的数据资产不当回事儿。</p>
<p>博客搬迁的基础准备工作（云主机、域名和博客平台）基本已经完成。经过几番权衡比较，主机我选择了阿里云，博客平台我选用了 <a href="http://typecho.org/" target="_blank" rel="external">Typecho</a>（再也不用操心评论系统啦）。自建网站少不了备案，好在阿里云的备案流程还算简单，就是消耗点时间罢了。至于博客的重构计划，主要是针对原来博客中多而杂的内容。具体的组织形式会以系列的方式分不同维度进行划分：</p>
<ul>
<li>按照领域分类<ul>
<li>机器学习（深度学习/数据挖掘）</li>
<li>云计算（框架、架构）</li>
<li>计算机科学（CSAPP，算法，数据结构）</li>
<li>无人机</li>
</ul>
</li>
<li>按照目的分类<ul>
<li>求职</li>
<li>团队建设</li>
</ul>
</li>
<li>按照项目分类<ul>
<li>Patriots</li>
<li>日志分析平台</li>
</ul>
</li>
<li>按照系列分类<ul>
<li>朝花夕拾（周记和回忆）</li>
<li>试说新屿（原来的所有效率类和乐活类文章会合并到这里，包括爱好、摄影、阅读、写作）。需要严格限制文章的篇数，一篇就讲清楚一个完整的事情。按章节分，不超过十二章（十二生肖作为章节名）</li>
</ul>
</li>
</ul>
<p>除了博客外，因为自己有了服务器，就顺带搭建了一个私有云笔记（使用 <a href="https://www.leanote.com/" target="_blank" rel="external">Leanote</a>），自建虽然不如云服务稳定，但至少数据比较安全，也算是一个备份。而原来的 MWeb + 文件同步流程因为 iCloud 的不给力和 Dropbox 的被墙而难以为继，所以已有 MWeb 更多会专注于本地的文档（比如技术积累和 Kindle 书摘），而 Leanote 则会接管我的日常笔记（可以方便同步查看）</p>
<p>新老博客预计会并轨运行一段时间，后面 wdxtub.com 就会成为一个备份，大部分内容会转移到新的博客去。这么一想，整理房间，整理文件，整理思路，整理生活的思路都是一样的，持续断舍离，持续继承，持续交付。运用奥卡姆剃刀原理，如无必要勿增实体，还是要走极简风格。</p>
<p>因为子妍有几天要加班，所以这周尝试了新的交通工具 - 单车。好久没有骑车走八九公里的路了，但是这种在路上的心情，这种想要相见的心情确实让每次一踩踏板都更有力了一些。生活中感情上最重要的就是螺旋式良性循环，因为只有这样才能每天都快快乐乐的。但更重要的是维持良性循环的两个人，在偏离轨道后能快速纠正，而不是放任不理鸵鸟心态。很多问题，如果忘了我而记起我们，就不再是问题；很多困难，如果坚定我们而放下我，就不再是困难。希望我们能继续坚持和发扬优良品质，早睡早起，严肃活泼，积极向上，争取更大的胜利。</p>
<p>天生我材必有用，古来圣贤皆寂寞，将进酒，杯莫停。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;君不见黄河之水天上来，奔流到海不复回。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>语音识别动手玩</title>
    <link href="http://wdxtub.com/2017/07/10/hands-on-speech-recognition/"/>
    <id>http://wdxtub.com/2017/07/10/hands-on-speech-recognition/</id>
    <published>2017-07-10T09:28:08.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>上周因为工作需要，用 HTML5 + Go 搭了一个简单的语音识别评测的 demo，用户可以直接打开网页 -&gt; 说一句话 -&gt; 查看来自不同服务提供商的语音识别结果（目前是科大讯飞、腾讯 AI 加速器和百度语音三家）。因为之前的项目很少直接跟硬件打交道，所以这次依然是摸着石头过河。好在之前有做过语音识别的项目，所以基本的概念还是懂的（因为涉及到数据格式，不懂的话即使看代码也容易云里雾里）。</p>
<p>俗话说的好，授人以鱼不如授人以渔，这个小项目的代码固然不多，但如何一个人把项目做好可能比源代码本身更重要，所以更多会记录整个项目是如何开展的过程（以及我的思考和选择）。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编码之前的准备工作有很多，从需求分析、技术调研到技术选型，每一步都走好了，项目才能顺利。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在领到一个新任务之后，最重要的工作不是动手，而是弄清楚到底需要做什么。为什么这么说？因为很多时候老大们只是有一个想法想要验证，并不会有一个很清晰的图景，这就需要我们主动沟通，去和老大们一起弄清楚到底需要做一个什么东西，然后才是具体技术方案的选择。</p>
<p>经过和老大的沟通，确定了是要做一个大家都方便访问的评测不同语音识别服务提供商的 demo，老大倾向于做一个页面，只要有浏览器和麦克风就可以体验，至于交互这些只要达到能用的平均线即可。</p>
<h3 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h3><p>因为需要依赖第三方的服务，所以首先要弄清楚第三方提供了什么服务，尤其是具体的接入方式需要特别注意。经过一番搜索和阅读，我得到了下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">提供商\SDK平台</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">android</th>
<th style="text-align:center">Linux(c)</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">REST API</th>
<th style="text-align:center">Windows</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">百度</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">科大</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">腾讯</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">x</td>
</tr>
</tbody>
</table>
<p>对应的文档在 </p>
<ul>
<li><a href="http://yuyin.baidu.com/docs" target="_blank" rel="external">百度语音</a> - <a href="http://ai.baidu.com/docs#/ASR-Android-SDK/top" target="_blank" rel="external">文档1</a> <a href="http://yuyin.baidu.com/docs/asr/166" target="_blank" rel="external">文档2</a></li>
<li><a href="http://www.xfyun.cn/services/voicedictation" target="_blank" rel="external">科大讯飞</a> - <a href="http://doc.xfyun.cn/msc_linux/290898" target="_blank" rel="external">Linux 文档</a></li>
<li><a href="http://ai.qq.com/" target="_blank" rel="external">腾讯 AI 加速器</a></li>
</ul>
<p>支持的格式</p>
<ul>
<li>百度 Rest API: 原始 PCM 的录音参数必须符合 8k/16k 采样率、16bit 位深、单声道，支持的压缩格式有：pcm（不压缩）、wav（不压缩，pcm编码）、amr（压缩格式）</li>
<li>腾讯 Rest API: 必须符合16k采样率、16bit采样位数、单声道，语音格式    PCM、WAV、AMR、 SILK</li>
<li>讯飞 SDK: 采样率16KHZ或者8KHZ，单声道，采样精度16bit的PCM或者WAV格式的音频</li>
</ul>
<p>在调研到这些信息之后，我们就可以轻松做出技术选型了。</p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>首先的考虑因素是快速出成果，所以能用 Restful API 就尽量用（毕竟直接对好接口即可）。但是讯飞在这个方面非常不友好，只提供了 Linux C 和 Java 的 SDK，所以得另外想办法处理讯飞这个问题。</p>
<p>注：最快的方法其实是用 android 或 iOS 的 SDK，集成到项目中直接用即可，但因为前面老大已经要求要用 html 方案，因此这些不予考虑（除非 html 做不出来，才弄其他方案）</p>
<p>因为讯飞只提供了 Linux C 的 SDK(Java 我是不太想用的)，所以得想个办法集成到后端(Go)，正当我一筹莫展之际，一个名为 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts</a> 的项目进入了我的眼帘（科大讯飞语音linux在线语音合成后台服务），虽然并不是使用讯飞的语音识别而是语音合成功能，但证明了用 Go 封装讯飞的 C SDK 是可能的。于是我赶紧看了一波代码，并很快完成了用 Go 封装的讯飞语音识别 SDK（也算是给讯飞做了一点微小的工作）。</p>
<p>好，那么现在问题解决，前端 html5 + js，后端 Go + Go 封装的 C SDK，直接在之前为公司开发的深度学习平台上开一个接口即可。</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>准备工作的最后一步就是到各家的开放平台上创建应用，得到我们调用 API 或 SDK 的凭证。百度语音的最好申请，腾讯 AI 加速器的需要申请内测（我们公司有合作所以不用申请），讯飞的需要审核（不然每天只有 500 次）。</p>
<p>创建完成之后把各家的 App ID/APP Key 之类的信息记录下来，后面需要用。</p>
<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>之所以要后端，是因为前端 JS 发请求会遇到跨域的问题，另外后端处理我也更加熟悉（事实证明离开了后端还真不行）</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分的难点在于如何通过浏览器调用麦克风，尤其是在 Chrome 上，要求全程 HTTPS 加密（当然也有另外的办法就是本地打开）。那用其他浏览器可不可以呢？可以！比如 Firefox，但是感觉 Firefox 对 Mac 的麦克风支持的一般，经常出现问题，所以我一直都是用 Chrome 在测试的。</p>
<p>因为毕竟前端写得少，大部分代码都是参照 <a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a> 这篇博客写的。主要是两个文件 <code>index.html</code> 和 <code>recorder.js</code>，接下来分别说明一下。</p>
<p>先说 <code>index.html</code> 的部分，代码不长，主要做的事情就是申请麦克风访问，然后给按钮添加动作，最后就是用 audio 控件来播放音频了。audio 控件还是比较好用的，给出音源地址即可，播放和音量都自带，很省心。我还加了个日志区域方便调试，其他的没什么难度，在此略去不表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>语音识别评测 Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>追一语音识别评测 Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>评测科大讯飞、百度语音与腾讯 AI 加速器的语音识别接口<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>由于 Chrome47 以上以及 QQ 浏览器需要 HTTPS 的支持，请更换至 360、FireFox、Edge 进行体验<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另：IE 和 Safari 全版本不支持录音功能<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span>&gt;</span>录音<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"stop"</span> <span class="attr">class</span>=<span class="string">"ui-btn ui-btn-primary"</span> <span class="attr">disabled</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--&lt;button id="upload" class="ui-btn ui-btn-primary" disabled&gt;上传&lt;/button&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"audio-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>操作日志<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/recorder.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">        function __log(e, data) &#123;</div><div class="line">            log.innerHTML += "\n" + getNowFormatDate() + " " + e + " " + (data || '');</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        function getNowFormatDate() &#123;</div><div class="line">            var date = new Date();</div><div class="line">            var seperator1 = "/";</div><div class="line">            var seperator2 = ":";</div><div class="line">            var month = date.getMonth() + 1;</div><div class="line">            var strDate = date.getDate();</div><div class="line">            if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;</div><div class="line">                month = "0" + month;</div><div class="line">            &#125;</div><div class="line">            if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;</div><div class="line">                strDate = "0" + strDate;</div><div class="line">            &#125;</div><div class="line">            var hours = date.getHours()</div><div class="line">            if (hours &lt; 10) &#123;</div><div class="line">                hours = "0" + hours</div><div class="line">            &#125;</div><div class="line">            var minutes = date.getMinutes()</div><div class="line">            if (minutes &lt; 10) &#123;</div><div class="line">                minutes = "0" + minutes</div><div class="line">            &#125;</div><div class="line">            var seconds = date.getSeconds()</div><div class="line">            if (seconds &lt; 10) &#123;</div><div class="line">                seconds = "0" + seconds</div><div class="line">            &#125;</div><div class="line">            var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate +</div><div class="line">                "-" + hours + seperator2 + minutes + seperator2 + seconds;</div><div class="line">            return currentdate;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        window.onload = function() &#123;</div><div class="line">            var start = document.querySelector('#start');</div><div class="line">            var stop = document.querySelector('#stop');</div><div class="line">            //var upload = document.querySelector('#upload');</div><div class="line">            var download = document.querySelector('#download');</div><div class="line">            var container = document.querySelector('#audio-container');</div><div class="line">            var recorder;</div><div class="line"></div><div class="line">            HZRecorder.get(function(rec) &#123;</div><div class="line">                recorder = rec;</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            start.addEventListener('click', function() &#123;</div><div class="line">                __log("开始录音")</div><div class="line">                this.disabled = true;</div><div class="line">                stop.disabled = false;</div><div class="line">                //upload.disabled = true;</div><div class="line">                var audio = document.querySelectorAll('audio');</div><div class="line">                for (var i = 0; i &lt; audio.length; i++) &#123;</div><div class="line">                    if (!audio[i].paused) &#123;</div><div class="line">                        audio[i].pause();</div><div class="line">                    &#125;</div><div class="line">                    container.removeChild(audio[i]) // 移除之前的录音</div><div class="line">                &#125;</div><div class="line">                recorder.start();</div><div class="line">            &#125;);</div><div class="line">            stop.addEventListener('click', function() &#123;</div><div class="line">                this.disabled = true;</div><div class="line">                start.disabled = false;</div><div class="line">                //upload.disabled = false;</div><div class="line">                recorder.stop();</div><div class="line"></div><div class="line">                var audio = document.createElement('audio');</div><div class="line">                recorder.play(audio)</div><div class="line">                container.appendChild(audio);</div><div class="line"></div><div class="line">                // 下载音频文件</div><div class="line">                // var link = window.document.createElement('a');</div><div class="line">                // var link = document.createElement('a');</div><div class="line">                // link.href = audio.src;</div><div class="line">                // link.download = 'output.wav';</div><div class="line">                // link.click();</div><div class="line"></div><div class="line">                recorder.upload("http://127.0.0.1:8778/v1/api/qq/voice_recog", function(state, e) &#123;</div><div class="line">                    switch (state) &#123;</div><div class="line">                        case 'uploading':</div><div class="line">                            __log("上传中，会在后端进行转码与识别");</div><div class="line">                            break;</div><div class="line">                        case 'ok':</div><div class="line">                            //__log("上传成功");</div><div class="line">                            break;</div><div class="line">                        case 'error':</div><div class="line">                            __log("上传失败");</div><div class="line">                            break;</div><div class="line">                        case 'cancel':</div><div class="line">                            __log("上传被取消");</div><div class="line">                            break;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">            &#125;);</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是 <code>recorder.js</code>（基本是照抄上面提到的原博客），主要做的工作就是处理浏览器采集到的音频信号，编码成 wav。注意这里没有更改采样率（采用默认的 44100），因为直接截取的话音调会有变化，导致识别结果较差。但其他的部分都尽量按照前面提到的标准来弄，即 16 位采样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</div><div class="line">    <span class="comment">//兼容</span></div><div class="line">    <span class="built_in">window</span>.URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</div><div class="line">    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> HZRecorder = <span class="function"><span class="keyword">function</span>(<span class="params">stream, config</span>) </span>&#123;</div><div class="line">        config = config || &#123;&#125;;</div><div class="line">        config.sampleBits = config.sampleBits || <span class="number">16</span>; <span class="comment">//采样数位 8, 16</span></div><div class="line">        config.sampleRate = config.sampleRate || <span class="number">44100</span>; <span class="comment">//采样率 16000（会变慢）</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> context = <span class="keyword">new</span>(<span class="built_in">window</span>.webkitAudioContext || <span class="built_in">window</span>.AudioContext)();</div><div class="line">        <span class="keyword">var</span> audioInput = context.createMediaStreamSource(stream);</div><div class="line">        <span class="keyword">var</span> createScript = context.createScriptProcessor || context.createJavaScriptNode;</div><div class="line">        <span class="keyword">var</span> recorder = createScript.apply(context, [<span class="number">4096</span>, <span class="number">1</span>, <span class="number">1</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> audioData = &#123;</div><div class="line">            <span class="attr">size</span>: <span class="number">0</span>, <span class="comment">//录音文件长度</span></div><div class="line">            buffer: [], <span class="comment">//录音缓存</span></div><div class="line">            inputSampleRate: context.sampleRate, <span class="comment">//输入采样率</span></div><div class="line">            inputSampleBits: <span class="number">16</span>, <span class="comment">//输入采样数位 8, 16</span></div><div class="line">            outputSampleRate: config.sampleRate, <span class="comment">//输出采样率</span></div><div class="line">            oututSampleBits: config.sampleBits, <span class="comment">//输出采样数位 8, 16</span></div><div class="line">            input: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.buffer.push(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(data));</div><div class="line">                <span class="keyword">this</span>.size += data.length;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">compress</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//合并压缩</span></div><div class="line">                <span class="comment">//合并</span></div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="keyword">this</span>.size);</div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.buffer.length; i++) &#123;</div><div class="line">                    data.set(<span class="keyword">this</span>.buffer[i], offset);</div><div class="line">                    offset += <span class="keyword">this</span>.buffer[i].length;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//压缩</span></div><div class="line">                <span class="keyword">var</span> compression = <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputSampleRate / <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> length = data.length / compression;</div><div class="line">                <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(length);</div><div class="line">                <span class="keyword">var</span> index = <span class="number">0</span>,</div><div class="line">                    j = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (index &lt; length) &#123;</div><div class="line">                    result[index] = data[j];</div><div class="line">                    j += compression;</div><div class="line">                    index++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">encodeWAV</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> sampleRate = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleRate, <span class="keyword">this</span>.outputSampleRate);</div><div class="line">                <span class="keyword">var</span> sampleBits = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.inputSampleBits, <span class="keyword">this</span>.oututSampleBits);</div><div class="line">                <span class="keyword">var</span> bytes = <span class="keyword">this</span>.compress();</div><div class="line">                <span class="keyword">var</span> dataLength = bytes.length * (sampleBits / <span class="number">8</span>);</div><div class="line">                <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">44</span> + dataLength);</div><div class="line">                <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">                <span class="keyword">var</span> channelCount = <span class="number">1</span>; <span class="comment">//单声道</span></div><div class="line">                <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">var</span> writeString = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">                        data.setUint8(offset + i, str.charCodeAt(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 资源交换文件标识符 </span></div><div class="line">                writeString(<span class="string">'RIFF'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 下个地址开始到文件尾总字节数,即文件大小-8 </span></div><div class="line">                data.setUint32(offset, <span class="number">36</span> + dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// WAV文件标志</span></div><div class="line">                writeString(<span class="string">'WAVE'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形格式标志 </span></div><div class="line">                writeString(<span class="string">'fmt '</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 过滤字节,一般为 0x10 = 16 </span></div><div class="line">                data.setUint32(offset, <span class="number">16</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 格式类别 (PCM形式采样数据) </span></div><div class="line">                data.setUint16(offset, <span class="number">1</span>, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 通道数 </span></div><div class="line">                data.setUint16(offset, channelCount, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 采样率,每秒样本数,表示每个通道的播放速度 </span></div><div class="line">                data.setUint32(offset, sampleRate, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8 </span></div><div class="line">                data.setUint32(offset, channelCount * sampleRate * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8 </span></div><div class="line">                data.setUint16(offset, channelCount * (sampleBits / <span class="number">8</span>), <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 每样本数据位数 </span></div><div class="line">                data.setUint16(offset, sampleBits, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">2</span>;</div><div class="line">                <span class="comment">// 数据标识符 </span></div><div class="line">                writeString(<span class="string">'data'</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 采样数据总数,即数据总大小-44 </span></div><div class="line">                data.setUint32(offset, dataLength, <span class="literal">true</span>);</div><div class="line">                offset += <span class="number">4</span>;</div><div class="line">                <span class="comment">// 写入采样数据 </span></div><div class="line">                <span class="keyword">if</span> (sampleBits === <span class="number">8</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset++) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        <span class="keyword">var</span> val = s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>;</div><div class="line">                        val = <span class="built_in">parseInt</span>(<span class="number">255</span> / (<span class="number">65535</span> / (val + <span class="number">32768</span>)));</div><div class="line">                        data.setInt8(offset, val, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++, offset += <span class="number">2</span>) &#123;</div><div class="line">                        <span class="keyword">var</span> s = <span class="built_in">Math</span>.max(<span class="number">-1</span>, <span class="built_in">Math</span>.min(<span class="number">1</span>, bytes[i]));</div><div class="line">                        data.setInt16(offset, s &lt; <span class="number">0</span> ? s * <span class="number">0x8000</span> : s * <span class="number">0x7FFF</span>, <span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Blob([data], &#123; <span class="attr">type</span>: <span class="string">'audio/wav'</span> &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">//开始录音</span></div><div class="line">        <span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 需要先清理 buffer</span></div><div class="line">            audioData.size = <span class="number">0</span>;</div><div class="line">            audioData.buffer = [];</div><div class="line">            audioInput.connect(recorder);</div><div class="line">            recorder.connect(context.destination);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//停止</span></div><div class="line">        <span class="keyword">this</span>.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            recorder.disconnect();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取音频文件</span></div><div class="line">        <span class="keyword">this</span>.getBlob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.stop();</div><div class="line">            <span class="keyword">return</span> audioData.encodeWAV();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//回放</span></div><div class="line">        <span class="keyword">this</span>.play = <span class="function"><span class="keyword">function</span>(<span class="params">audio</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> blob = <span class="keyword">this</span>.getBlob()</div><div class="line">            audio.src = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">            __log(<span class="string">"录音结束，Wav 大小: "</span> + blob.size + <span class="string">"B Wav 地址: "</span> + audio.src)</div><div class="line">            audio.controls = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//上传</span></div><div class="line">        <span class="keyword">this</span>.upload = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();</div><div class="line">            fd.append(<span class="string">"audioData"</span>, <span class="keyword">this</span>.getBlob());</div><div class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line"></div><div class="line">                    __log(xhr.responseText)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (callback) &#123;</div><div class="line">                xhr.upload.addEventListener(<span class="string">"progress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'uploading'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'ok'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'error'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">                xhr.addEventListener(<span class="string">"abort"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">                    callback(<span class="string">'cancel'</span>, e);</div><div class="line">                &#125;, <span class="literal">false</span>);</div><div class="line">            &#125;</div><div class="line">            xhr.open(<span class="string">"POST"</span>, url);</div><div class="line">            xhr.send(fd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//音频采集</span></div><div class="line">        recorder.onaudioprocess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            audioData.input(e.inputBuffer.getChannelData(<span class="number">0</span>));</div><div class="line">            <span class="comment">//record(e.inputBuffer.getChannelData(0));</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//抛出异常</span></div><div class="line">    HZRecorder.throwError = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">            alert(message);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> message; &#125; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是否支持录音</span></div><div class="line">    HZRecorder.canRecording = (navigator.getUserMedia != <span class="literal">null</span>);</div><div class="line">    <span class="comment">//获取录音机</span></div><div class="line">    HZRecorder.get = <span class="function"><span class="keyword">function</span>(<span class="params">callback, config</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (callback) &#123;</div><div class="line">            <span class="keyword">if</span> (navigator.getUserMedia) &#123;</div><div class="line">                navigator.getUserMedia(&#123; <span class="attr">audio</span>: <span class="literal">true</span> &#125; <span class="comment">//只启用音频</span></div><div class="line">                    ,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</div><div class="line">                        <span class="keyword">var</span> rec = <span class="keyword">new</span> HZRecorder(stream, config);</div><div class="line">                        callback(rec);</div><div class="line">                    &#125;,</div><div class="line">                    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">                        <span class="keyword">switch</span> (error.code || error.name) &#123;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PERMISSION_DENIED'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'PermissionDeniedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'用户拒绝提供信息。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NOT_SUPPORTED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'NotSupportedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'浏览器不支持硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MANDATORY_UNSATISFIED_ERROR'</span>:</div><div class="line">                            <span class="keyword">case</span> <span class="string">'MandatoryUnsatisfiedError'</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法发现指定的硬件设备。'</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">default</span>:</div><div class="line">                                HZRecorder.throwError(<span class="string">'无法打开麦克风。异常信息:'</span> + (error.code || error.name));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                HZRecorder.throwErr(<span class="string">'当前浏览器不支持录音功能。'</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">window</span>.HZRecorder = HZRecorder;</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>至此，前端的工作就告一段落，主要工作就是录音，并把 44100Hz 16bit 的 wav 文件上传到后端，并等待后端返回语音识别结果。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>虽然前端做的工作不多，但其实后端要做的也不多，毕竟是调用别人的接口嘛，要再这么麻烦就没有人用啦。所以后端要做的工作主要分两个部分，对于有 Restful API 的服务来说，就是准备数据，对于只有 Linux C SDK 的服务来说，就是用 Go 去调用 C SDK，接下来我们先讲讲共用的部分，然后分别说说不同服务需要注意的地方。</p>
<p>共用的部分就是改变录音的采样率，前面提到浏览器默认的采样率是 44100Hz，我们需要转变成 16000Hz 的，考虑到 44100 并不能整除 16000，所以简单的采样一定会导致频率的变化，但是不用紧张，我们还有两大法宝 <code>ffmpeg</code> 和 <code>sox</code>。转码的命令也很简单，以下两个任选一个即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ffmpeg -i input.wav -ar 16000 output.wav</div><div class="line"><span class="comment"># or</span></div><div class="line">sox input.wav -r 16000 output.wav</div></pre></td></tr></table></figure>
<p>然后我们就要以转码后的 <code>output.wav</code> 为基础，进行下面的操作了。使用 Restful API 需要注意的就是不同平台有不同的加密、验证方式和不同的参数，但无论如何音频文件需要用 Base64 编码，然后只要写一个通用的工具方法即可，这里不多说，主要还是说一下如何去用 Go 调用 C SDK（主要参考的是 <a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a> 的代码）。</p>
<p>首先就是从讯飞的语音云平台上下载 SDK，然后把 SDK 内的文件放到一个名为 <code>xf</code> 的文件夹中，就叫做 <code>package xf</code> 好了。目录大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">├── README.md</div><div class="line">├── include</div><div class="line">│   ├── convert.h</div><div class="line">│   ├── msp_cmn.h</div><div class="line">│   ├── msp_errors.h</div><div class="line">│   ├── msp_types.h</div><div class="line">│   ├── qise.h</div><div class="line">│   ├── qisr.h</div><div class="line">│   └── qtts.h</div><div class="line">├── libs</div><div class="line">│   ├── x64</div><div class="line">│   │   └── libmsc.so</div><div class="line">│   └── x86</div><div class="line">│       └── libmsc.so</div><div class="line">└── xf.go</div></pre></td></tr></table></figure>
<p>着重讲两个文件，一个是 <code>xf.go</code>（相当于是 C SDK 的 Wrapper），另一个是 <code>convert.h</code>（是参照讯飞的官方例子改的）。我们先来看看 <code>convert.h</code>，实际上就是用 C 来完成语音识别的调用（代码略长，感兴趣的同学估计得慢慢理解）。留意一下 <code>run_iat</code> 这个核心函数的返回值 <code>char *</code>，后面在 <code>xf.go</code> 中有用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qisr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_cmn.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msp_errors.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFER_SIZE	4096</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_LEN	640 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HINTS_SIZE  100</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">run_iat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* audio_file)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* session_begin_params	=	<span class="string">"sub = iat, domain = iat, language = zh_cn, accent = mandarin, sample_rate = 16000, result_type = plain, result_encoding = utf8"</span>;</div><div class="line">    <span class="keyword">char</span> *retstr = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*		session_id					=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>			rec_result[BUFFER_SIZE]		=	&#123;<span class="string">'\0'</span>&#125;;	</div><div class="line">	<span class="keyword">char</span>			hints[HINTS_SIZE]			=	&#123;<span class="string">'\0'</span>&#125;; <span class="comment">//hints为结束本次会话的原因描述，由用户自定义</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	total_len					=	<span class="number">0</span>; </div><div class="line">	<span class="keyword">int</span>				aud_stat					=	MSP_AUDIO_SAMPLE_CONTINUE ;		<span class="comment">//音频状态</span></div><div class="line">	<span class="keyword">int</span>				ep_stat						=	MSP_EP_LOOKING_FOR_SPEECH;		<span class="comment">//端点检测</span></div><div class="line">	<span class="keyword">int</span>				rec_stat					=	MSP_REC_STATUS_SUCCESS ;			<span class="comment">//识别状态</span></div><div class="line">	<span class="keyword">int</span>				errcode						=	MSP_SUCCESS ;</div><div class="line"></div><div class="line">	FILE*			f_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">char</span>*			p_pcm						=	<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_count					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			pcm_size					=	<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span>			read_size					=	<span class="number">0</span>;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == audio_file)</div><div class="line">    &#123;</div><div class="line">        retstr = <span class="string">"[Error] 文件名为空"</span>;</div><div class="line">        <span class="keyword">goto</span> iat_exit;</div><div class="line">    &#125;</div><div class="line">		</div><div class="line"></div><div class="line">	f_pcm = fopen(audio_file, <span class="string">"rb"</span>);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == f_pcm) </div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 打开音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nopen [%s] failed! \n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_END);</div><div class="line">	pcm_size = ftell(f_pcm); <span class="comment">//获取音频文件大小 </span></div><div class="line">	fseek(f_pcm, <span class="number">0</span>, SEEK_SET);		</div><div class="line"></div><div class="line">	p_pcm = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pcm_size);</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == p_pcm)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 无法分配内存"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nout of memory! \n"</span>);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	read_size = fread((<span class="keyword">void</span> *)p_pcm, <span class="number">1</span>, pcm_size, f_pcm); <span class="comment">//读取音频文件内容</span></div><div class="line">	<span class="keyword">if</span> (read_size != pcm_size)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] 读取音频文件失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nread [%s] error!\n"</span>, audio_file);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n开始语音听写 ...\n"</span>);</div><div class="line">	session_id = QISRSessionBegin(<span class="literal">NULL</span>, session_begin_params, &amp;errcode); <span class="comment">//听写不需要语法，第一个参数为NULL</span></div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">        retstr = <span class="string">"[Error] QISRSessionBegin 失败"</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRSessionBegin failed! error code:%d\n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">10</span> * FRAME_LEN; <span class="comment">// 每次写入200ms音频(16k，16bit)：1帧音频20ms，10帧=200ms。16k采样率的16位音频，一帧的大小为640Byte</span></div><div class="line">		<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (pcm_size &lt; <span class="number">2</span> * len) </div><div class="line">			len = pcm_size;</div><div class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		aud_stat = MSP_AUDIO_SAMPLE_CONTINUE;</div><div class="line">		<span class="keyword">if</span> (<span class="number">0</span> == pcm_count)</div><div class="line">			aud_stat = MSP_AUDIO_SAMPLE_FIRST;</div><div class="line"></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;"</span>);</div><div class="line">		ret = QISRAudioWrite(session_id, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;p_pcm[pcm_count], len, aud_stat, &amp;ep_stat, &amp;rec_stat);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != ret)</div><div class="line">		&#123;</div><div class="line">            retstr = <span class="string">"[Error] QISRAudioWrite 失败"</span>;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d\n"</span>, ret);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">			</div><div class="line">		pcm_count += (<span class="keyword">long</span>)len;</div><div class="line">		pcm_size  -= (<span class="keyword">long</span>)len;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (MSP_REC_STATUS_SUCCESS == rec_stat) <span class="comment">//已经有部分听写结果</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">			<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">			&#123;</div><div class="line">                retstr = <span class="string">"QISRGetResult failed"</span>;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed! error code: %d\n"</span>, errcode);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">				total_len += rslt_len;</div><div class="line">				<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">					retstr = <span class="string">"[Error] Buffer 太小"</span>;</div><div class="line">                    <span class="keyword">goto</span> iat_exit;</div><div class="line">				&#125;</div><div class="line">				<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (MSP_EP_AFTER_SPEECH == ep_stat)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		usleep(<span class="number">200</span>*<span class="number">1000</span>); <span class="comment">//模拟人说话时间间隙。200ms对应10帧的音频</span></div><div class="line">	&#125;</div><div class="line">	errcode = QISRAudioWrite(session_id, <span class="literal">NULL</span>, <span class="number">0</span>, MSP_AUDIO_SAMPLE_LAST, &amp;ep_stat, &amp;rec_stat);</div><div class="line">	<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\nQISRAudioWrite failed! error code:%d \n"</span>, errcode);</div><div class="line">		<span class="keyword">goto</span> iat_exit;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (MSP_REC_STATUS_COMPLETE != rec_stat) </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *rslt = QISRGetResult(session_id, &amp;rec_stat, <span class="number">0</span>, &amp;errcode);</div><div class="line">		<span class="keyword">if</span> (MSP_SUCCESS != errcode)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\nQISRGetResult failed, error code: %d\n"</span>, errcode);</div><div class="line">			<span class="keyword">goto</span> iat_exit;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != rslt)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> rslt_len = <span class="built_in">strlen</span>(rslt);</div><div class="line">			total_len += rslt_len;</div><div class="line">			<span class="keyword">if</span> (total_len &gt;= BUFFER_SIZE)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"\nno enough buffer for rec_result !\n"</span>);</div><div class="line">				<span class="keyword">goto</span> iat_exit;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">strncat</span>(rec_result, rslt, rslt_len);</div><div class="line">		&#125;</div><div class="line">		usleep(<span class="number">150</span>*<span class="number">1000</span>); <span class="comment">//防止频繁占用CPU</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n语音听写结束\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,rec_result);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</div><div class="line"></div><div class="line">    retstr = rec_result;</div><div class="line"></div><div class="line">iat_exit:</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != f_pcm)</div><div class="line">	&#123;</div><div class="line">		fclose(f_pcm);</div><div class="line">		f_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != p_pcm)</div><div class="line">	&#123;	<span class="built_in">free</span>(p_pcm);</div><div class="line">		p_pcm = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	QISRSessionEnd(session_id, hints);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> retstr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们来看看对 C SDK 的封装，这里采用了 cgo 的方案，具体的不展开，我们直接上 <code>xf.go</code> 的代码（很短，没想到吧，另外 <code>import &quot;C&quot;</code> 这句和上面的注释之间不能有空行）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> xf</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">#cgo CFLAGS:-g -Wall -I ./include</div><div class="line">#cgo LDFLAGS:-L./lib -lmsc -lrt -ldl -lpthread</div><div class="line"></div><div class="line">#include "convert.h"</div><div class="line"></div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	loginParams := <span class="string">"appid = your_app_id, work_dir = ."</span></div><div class="line">	ret := C.MSPLogin(<span class="literal">nil</span>, <span class="literal">nil</span>, C.CString(loginParams))</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"登录失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"登录成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logout</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	ret := C.MSPLogout()</div><div class="line">	<span class="keyword">if</span> ret != C.MSP_SUCCESS &#123;</div><div class="line">		fmt.Println(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"注销失败，错误码: %d"</span>, <span class="keyword">int</span>(ret))</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"注销成功"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpeechToText</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// https://golang.org/cmd/cgo/</span></div><div class="line">	<span class="comment">// 需要在执行前 export LD_LIBRARY_PATH=/usr/local/lib</span></div><div class="line">	<span class="comment">// 如果改动了 c++ 文件，需要改动这个调用 C 的文件，才会进行重新编译，不然一直是老的</span></div><div class="line">	<span class="comment">// 官方例子中是支持 wav 的（不需要转换了）</span></div><div class="line">	<span class="comment">// ffmpeg -i output.wav -f s16be -acodec pcm_s16be output.pcm</span></div><div class="line">	fmt.Println(<span class="string">"004"</span>)</div><div class="line">	retstr := C.run_iat(C.CString(filename))</div><div class="line">	<span class="keyword">return</span> C.GoString(retstr), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 Go 的 <code>string</code> 到 C 的 <code>char*</code> 可以使用 <code>C.CString()</code>，反过来可以使用 <code>C.GoString()</code> 来转换。转换完成之后，把结果返回给前端即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像游戏评测一样，来个打分，满分十分</p>
<ul>
<li>接入方便程度<ul>
<li>腾讯: 9.0</li>
<li>百度: 8.5</li>
<li>讯飞: 5.0</li>
</ul>
</li>
<li>用户体验<ul>
<li>百度: 9.0</li>
<li>腾讯: 8.0</li>
<li>讯飞: 6.0</li>
</ul>
</li>
<li>识别效果（基于小样本的主观判断）<ul>
<li>讯飞: 8.0</li>
<li>百度: 7.5</li>
<li>腾讯: 6.0</li>
</ul>
</li>
</ul>
<p>在这里希望讯飞能够更加互联网/接地气一些，不然用起来真的挺麻烦的（不知道大客户是不是有其他待遇）</p>
<h2 id="附录-音频格式知识"><a href="#附录-音频格式知识" class="headerlink" title="附录: 音频格式知识"></a>附录: 音频格式知识</h2><p>WAV：wav是一种无损的音频文件格式，WAV符合 PIFF(Resource Interchange File Format)规范。所有的WAV都有一个文件头，这个文件头音频流的编码参数。WAV对音频流的编码没有硬性规定，除了PCM之外，还有几乎所有支持ACM规范的编码都可以为WAV的音频流进行编码。</p>
<p>PCM:PCM（Pulse Code Modulation—-脉码调制录音)。所谓PCM录音就是将声音等模拟信号变成符号化的脉冲列，再予以记录。PCM信号是由[1]、[0]等符号构成的数字信号，而未经过任何编码和压缩处理。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的影响效果。</p>
<p>简单来说：wav是一种无损的音频文件格式，pcm是没有压缩的编码方式。</p>
<p>WAV可以使用多种音频编码来压缩其音频流，不过我们常见的都是音频流被PCM编码处理的WAV，但这不表示WAV只能使用PCM编码，MP3编码同样也可以运用在WAV中，和AVI一样，只要安装好了相应的Decode，就可以欣赏这些WAV了。在Windows平台下，基于PCM编码的WAV是被支持得最好的音频格式，所有音频软件都能完美支持，由于本身可以达到较高的音质的要求，因此，WAV也是音乐编辑创作的首选格式，适合保存音乐素材。因此，基于PCM编码的WAV被作为了一种中介的格式，常常使用在其他编码的相互转换之中，例如MP3转换成WMA。<a href="http://blog.csdn.net/u014434080/article/details/53261433" target="_blank" rel="external">来源</a></p>
<p>采样的位数指的是描述数字信号所使用的位数。8 位(8 bit)代表 2 的 8 次方即 256，16 位(16 bit)则代表 2 的 16 次方即 65536 / 1024 = 64K</p>
<p>采样率是一秒钟内对声音信号的采样次数</p>
<p>网络接收一个音频的时长是 20ms, 已知音频采样率是 8kHz，采样的位数是 16bit。<code>[时长]20ms * [采样率]8kHz * [采样的位数]16bit = 320 byte</code></p>
<p>例如，CD 采用16位的采样精度，44.1KHz 的采样频率，为双声道，它每秒所需要的数据量为 <code>16×44100×2÷8＝176400</code> 字节。这样算下来，比特率应该是 1400 多 Kbps，如果采用 MP3、WMA 编码格式，比特率能够更小。<a href="http://www.wuroom.com/post/122/" target="_blank" rel="external">来源</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.cnblogs.com/blqw/p/3782420.html" target="_blank" rel="external">HTML5网页录音和压缩,边猜边做..(附源码)</a></li>
<li><a href="https://www.v2ex.com/t/342898" target="_blank" rel="external">纯 HTML5 实现的录音功能，支持回放和上传</a></li>
<li><a href="https://github.com/imroc/ontts" target="_blank" rel="external">imroc/ontts - 科大讯飞语音linux在线语音合成后台服务</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语音识别哪家强，腾讯百度讯飞谁称王？如果想自己动手体验一下各家的语音识别服务却又不只从何入手，那么相信这篇文章就是你需要的。废话不多说，我们直接开动吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="Web" scheme="http://wdxtub.com/tags/Web/"/>
    
      <category term="语音" scheme="http://wdxtub.com/tags/%E8%AF%AD%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用操作指南</title>
    <link href="http://wdxtub.com/2017/07/10/linux-operation-guide/"/>
    <id>http://wdxtub.com/2017/07/10/linux-operation-guide/</id>
    <published>2017-07-10T01:04:50.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.10: 完成初稿</li>
</ul>
<h2 id="压缩解压-tar"><a href="#压缩解压-tar" class="headerlink" title="压缩解压 tar"></a>压缩解压 tar</h2><p>如果要在服务器之间发送大量数据，肯定少不了压缩和解压这两步，但是 <code>tar</code> 这个命令的参数之多，让我很绝望，于是我发明了一个简单的记忆方法。</p>
<p>使用 <code>tar</code> 命令只要记得参数是『必选+自选+<code>f</code>』即可，我们先来看看『必选！五选一』:</p>
<ol>
<li><code>-c</code> 意为 create，表示创建压缩包</li>
<li><code>-x</code> 意为 extract，表示解压</li>
<li><code>-t</code> 表示查看内容</li>
<li><code>-r</code> 给压缩包追加文件</li>
<li><code>-u</code> 意为 update，更新压缩包中的文件</li>
</ol>
<p>注意了，上面是一定要五选一的，不能一个都不选，也不能同时选俩。但是自选的部分就可以按照需要挑选了，比如：</p>
<ul>
<li><code>-z</code> 使用 gzip 属性</li>
<li><code>-j</code> 使用 bz2 属性</li>
<li><code>-Z</code> 使用 compress 属性</li>
<li><code>-v</code> 意为 verbose，显示详细的操作过程</li>
<li><code>-O</code> 将文件输出到标准输出</li>
</ul>
<p>然后最后一个一定要是 <code>f</code> 后面跟压缩包名（无论是要解压还是要压缩，都是指压缩包的名字）。接下来我们看看具体实例，就很容易理解具体的用法了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 假设我们有很多 .md 文件需要打包，那么可以使用</span></div><div class="line">tar -cf posts.tar *.md <span class="comment"># c 是创建压缩包，也就是压缩，然后是 f，给出压缩包名，最后是要压缩的文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现还有一些 .txt 文件也需要打包进去，那么可以使用</span></div><div class="line">tar -rf posts.tar *.txt <span class="comment"># r 是追加文件</span></div><div class="line"></div><div class="line"><span class="comment"># 然后我们发现 hello.md 弄错了，修正后需要更新到压缩包中，可以使用</span></div><div class="line">tar -uf post.tar hello.md <span class="comment"># u 是更新</span></div><div class="line"></div><div class="line"><span class="comment"># 压缩好了，我们来看看压缩包的内容，可以使用</span></div><div class="line">tar -tf posts.tar <span class="comment"># t 是列出文件内容</span></div><div class="line"></div><div class="line"><span class="comment"># 把压缩包发送到其他位置之后，需要解压，可以使用</span></div><div class="line">tar -xf posts.tar <span class="comment"># x 是解压</span></div></pre></td></tr></table></figure>
<p>加入自选参数后的用法（要不要加 v 可以看个人喜好）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># tar.gz 相关</span></div><div class="line">tar -czf posts.tar.gz *.md <span class="comment"># 压缩</span></div><div class="line">tar -xzf posts.tar.gz <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.bz2 相关</span></div><div class="line">tar -cjf posts.tar.bz2 *.md <span class="comment"># 压缩</span></div><div class="line">tar -xjf posts.tar.bz2 <span class="comment"># 解压</span></div><div class="line"></div><div class="line"><span class="comment"># tar.Z 相关</span></div><div class="line">tar -cZf posts.tar.Z *.md <span class="comment"># 压缩</span></div><div class="line">tar -xZf posts.tar.Z <span class="comment"># 解压</span></div></pre></td></tr></table></figure>
<p>总结一波，遇到不同类型的文件，请用不同的套路来应对：</p>
<ul>
<li><code>*.tar</code> -&gt; <code>tar -xf</code></li>
<li><code>*.tar.gz</code> -&gt; <code>tar -xzf</code></li>
<li><code>*.tar.bz2</code> -&gt; <code>tar -xjf</code></li>
<li><code>*.tar.Z</code> -&gt; <code>tar -xZf</code></li>
<li><code>*.gz</code> -&gt; <code>gzip -d</code></li>
<li><code>*.rar</code> -&gt; <code>unrar e</code></li>
<li><code>*.zip</code> -&gt; <code>unzip</code></li>
</ul>
<h2 id="空间占用-du"><a href="#空间占用-du" class="headerlink" title="空间占用 du"></a>空间占用 du</h2><p>很多时候磁盘被写满了是各种奇怪错误的源头，所以如何快速找到问题所在就很重要了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 显示当前文件下 Top 10 空间占用的文件/目录，</span></div><div class="line"><span class="comment"># s 表示不显示每个子目录或文件的大小</span></div><div class="line"><span class="comment"># h 表示用更加自然的方式显示（比如 K/M/G 这样）</span></div><div class="line">du -sh * | sort -nr | head</div></pre></td></tr></table></figure>
<h2 id="系统状态-top"><a href="#系统状态-top" class="headerlink" title="系统状态 top"></a>系统状态 top</h2><p>了解系统状态一般少不了 <code>top</code> 命令，虽然基本上不需要做任何操作，但是还是有一些可以自定义的内容的，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看某用户的进程</span></div><div class="line">top -u wdxtub</div><div class="line"></div><div class="line"><span class="comment"># 进入系统状态显示后，具体值代表的意思是</span></div><div class="line"><span class="comment"># PR    进程优先级，越小优先级越高</span></div><div class="line"><span class="comment"># VIRT  占用的虚拟内存</span></div><div class="line"><span class="comment"># RES   占用的物理内存</span></div><div class="line"><span class="comment"># SHR   占用的共享内存</span></div><div class="line"><span class="comment"># S     进程状态（S - 休眠，R - 正在运行，Z - 僵死状态，N - 优先级为负数）</span></div><div class="line"><span class="comment"># TIME+ 进程启动后占用的总 CPU 时间</span></div><div class="line"></div><div class="line"><span class="comment"># 可以按照不同的指标排序显示，按对应键即可</span></div><div class="line"><span class="comment"># P 按照 CPU 使用率排序</span></div><div class="line"><span class="comment"># T 按照 MITE+ 排序</span></div><div class="line"><span class="comment"># M 按内存使用占比排序</span></div></pre></td></tr></table></figure>
<p>其他查看进程相关信息的命令有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看进程内存分布</span></div><div class="line">pmap <span class="_">-d</span> 12345 <span class="comment"># 12345 是进程号</span></div><div class="line"></div><div class="line"><span class="comment"># 按照内存排序，这里的 grep 可以过滤特定的用户</span></div><div class="line">ps <span class="_">-e</span> -o <span class="string">'pid,comm,srgs,pcpu,rsz,vsz,stime,user,uid'</span> | grep wdxtub | sort nrk5</div></pre></td></tr></table></figure>
<h2 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 find"></a>查找 find</h2><p>在命令行界面中进行查找是每个需要在服务器上执行操作的同学都必备的技能，这里用实例来说明常见的实用用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 找出七天前的文件</span></div><div class="line">find / -type f -mtime +7 -print</div><div class="line"><span class="comment"># / 表示从根目录中查找</span></div><div class="line"><span class="comment"># -type f 表示找出系统普通文件，不包含目录</span></div><div class="line"><span class="comment"># -mtime +n 表示寻找 n 天前的数据</span></div><div class="line"><span class="comment"># -print 打印文件名称</span></div><div class="line"></div><div class="line"><span class="comment"># 找出并删除七天前的文件</span></div><div class="line">find /temp/ -type f -mtime +7 -print -exec rm <span class="_">-f</span> &#123;&#125; \;</div><div class="line"><span class="comment"># -exec 表示后面执行系统命令</span></div><div class="line"><span class="comment"># &#123;&#125; 只有该符号能跟在命令你后面</span></div><div class="line"><span class="comment"># \; 结束符号</span></div><div class="line">find /temp/ -type f -mtime +7 -print | xargs rm <span class="_">-f</span></div><div class="line"><span class="comment"># 使用管道和 xargs = -exec</span></div><div class="line"></div><div class="line"><span class="comment"># 查找 /var 下最大的十个文件</span></div><div class="line">find /var -type f -ls | sort -k 7 -r -n | head</div><div class="line"></div><div class="line"><span class="comment"># 查找 /var/log 下大于 5GB 的文件</span></div><div class="line">find /var/<span class="built_in">log</span>/ -type f -size +5120M -exec ls -lh &#123;&#125; \;</div><div class="line"></div><div class="line"><span class="comment"># 找出今天所有文件并将它们拷贝到另一个目录</span></div><div class="line">find /home/wdxtub/ -ctime 0 -print -exec cp &#123;&#125; /mnt/backup/&#123;&#125; \;</div></pre></td></tr></table></figure>
<h2 id="远程登录-ssh"><a href="#远程登录-ssh" class="headerlink" title="远程登录 ssh"></a>远程登录 ssh</h2><ul>
<li><code>ssh -vvv username@ip</code> ssh 的 debug 模式</li>
<li><code>ssh -i key.pem username@ip</code> 用 pem key 登录 ssh</li>
</ul>
<h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>这里是一些比较零碎的命令行技巧</p>
<ul>
<li><code>openssl rand -hex n</code> 产生随机的十六进制数，n 是字符数 </li>
<li><code>source /path/to/filename</code> 在当前 shell 里执行一个文件里的命令</li>
<li><code>${variable:0:5}</code> 截取变量的前五个字符</li>
<li><code>wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs</code> 用 wget 抓取完整的网站目录结构，存放到本地目录中</li>
<li><code>mkdir -p /home/wdxtub/{test0,test1,test2}</code> 一次创建多个目录</li>
<li><code>dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img</code> 测试硬盘写入速度</li>
<li><code>hdparm -Tt /dev/sda</code> 测试硬盘读取速度</li>
<li><code>echo -n &quot;test&quot; | md5sum</code> 获取文本的 md5</li>
<li><code>curl -I http://wdxtub.com</code> 获取 HTTP 头信息</li>
<li><code>netstat -tln4 | awk &#39;{print $4}&#39; | cut -f2 -d: | grep -o &#39;[0-9]*&#39;</code> 显示所有 tcp4 监听端口</li>
<li><code>time command</code> 查看命令的运行时间</li>
<li><code>export</code> 查看所有的环境变量</li>
<li><code>cmp file1 file2</code> 文件内容对比</li>
<li><code>cat -n file</code> 内容前面会显示行号</li>
<li><code>lsof -i:22</code> 查看 22 端口现在运行的程序</li>
<li><code>lsof -c abc</code> 显示 abc 进程现在打开的文件</li>
<li><code>lsof -p 12</code> 看进程号为 12 的进程打开了哪些文件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在工作中肯定少不了跟服务器打交道，对于我来说，各种命令各种参数我常常是记不住的，与其每次上网搜，不如一边学一边记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="运维" scheme="http://wdxtub.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>大海啊都是水 - 马来西亚游记</title>
    <link href="http://wdxtub.com/2017/07/09/sea-all-water/"/>
    <id>http://wdxtub.com/2017/07/09/sea-all-water/</id>
    <published>2017-07-09T00:37:10.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>一四七、三六九、九九归一跟我走，上天下海不回头。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.09: 完成初稿</li>
</ul>
<p>转眼 2017 已经来到了下半年，我才开始动笔写今年的第一篇游记。工作之后，时间成了最稀缺的资源，尤其是少得可怜的年假，说走就走的旅行似乎变得那么遥不可及。幸好在同事的撺掇下，一行四人快速敲定了沙巴-仙本那的行程，才终于浮生偷得五日闲，远离平时上班的一亩三分地，真正践行了『世界这么大我想去看看』的豪言壮语。</p>
<p><img src="/images/14995667893620.jpg" alt=""></p>
<h2 id="具体行程"><a href="#具体行程" class="headerlink" title="具体行程"></a>具体行程</h2><p>为了方便想去玩的小伙伴，这里列出具体的行程，方便大家做攻略参考。</p>
<ul>
<li>第一天: 下午从香港飞到哥打基纳巴鲁，晚上入住住市中心离码头比较近的地方<ul>
<li>地点: 旺角、尖沙咀</li>
<li>饮食: 麦奀云吞面、佐敦咖喱饭、中村藤吉本店</li>
<li>交通: 步行，到机场的大巴（33 港币）</li>
</ul>
</li>
<li>第二天: 白天在码头买票游不同的岛，晚上从哥打基纳巴鲁飞到仙本那，晚上入住当地酒店</li>
<li>第三天: 在仙本那体验深潜，晚上继续住酒店</li>
<li>第四天: 在仙本那跳岛游，晚上从仙本那飞回哥打基纳巴鲁，入住 Airbnb 找到的公寓</li>
<li>第五天: 睡了一个上午，中午吃完饭，下午飞回香港，最后在深圳湾口岸回深圳</li>
</ul>
<p>其他事项</p>
<ul>
<li>机票是在穷游网打折的时候买的亚航往返，后来我才知道亚航也是马来西亚的，另一个当地航空叫做 - 马航</li>
<li>手机电力是极大的制约，充电宝有用，但毕竟不防水，所以大部分时间为了节约电力，我都是用纸笔记录</li>
<li>如果要潜水的话水下相机一定要准备好，gopro 可以搞一个，其他防水相机也很好，国产的请不要考虑，亲测渣渣</li>
<li>深潜会弄得满船都是水，最好不要携带任何贵重及怕水的物品</li>
<li>一件快干防晒风衣是非常重要的，不然动辄一个小时的海风，会让人生不如死</li>
<li>能吃饱一定要吃饱（不要管好不好吃），能睡好一定要睡好，不然巨大的体能消耗可以轻易胖子拖瘦瘦子拖垮</li>
<li>防晒基本是不够用的，请安心接受晒黑（可能还有脱皮）的结局</li>
<li>提前下载好 Uber 和 Google Map 并把重要地点标记好，出行会方便很多</li>
<li>当地电话卡信号一般，还是中国移动比较移得动（联通差评）。下了飞机拿到之前预订的当地电话卡，打 Uber 非常便宜，基本不会超过十马币（乘以 1.5 大概就是人民币）</li>
<li>离仙本那最近的机场是斗湖机场，那里只有两家航空公司：亚航与马航。机场很小（一共三个登机口）</li>
<li>东南亚口音英语比印度英语还要难听懂</li>
</ul>
<h2 id="旅途随想"><a href="#旅途随想" class="headerlink" title="旅途随想"></a>旅途随想</h2><p>以要点的形式来记录旅途随想，大部分取材于当时的文字。</p>
<p><img src="/images/14995678328174.jpg" alt=""></p>
<ul>
<li>时隔这么多年再到香港，感觉已有太大的不同。行千里路与读万卷书结合到一起之后，迸发出的新世界让我自己都有些诧异：这个世界没有那么好，但也没有那么糟。大家不过是过过日子，谁又能一直是圣人呢。</li>
<li>来到香港，大概就明白港产片和港星那种特别的气质，一种桀骜不驯的浪子今非昔比的感觉。黄金时代大幕落下后留下的回忆，需要很多时间和空间去消化。</li>
<li>不得不说香港的居民楼实在是太拥挤了，拥挤到看着就没有什么幸福感。山腰上的房子像一排屏障，有些突兀，要我说风水就不大好。现代社会一个奇怪的现象便是越拥挤反而人与人之间越生疏，这种生疏感最终撕裂了人群与社会，让很多很小的事情瞬间变得无法控制。</li>
<li>去美国之前觉得香港的路牌大约是很酷的，但在美国看久了之后就意识到，香港的一切不过是套着一层西方表皮，模仿得不能算拙劣，但却没多少特色特色。这样想来，大陆很多地方是有点土，但再土是自己的土，在我看来也要比洋人的洋要好。等什么时候洋成了一个普普通通的词汇，中国人民恐怕才算是真的站起来了。</li>
<li>飞机不出意外地晚点，预计起飞的时间已经过了一个小时，我却依然在地面上。我倒不是担心飞机晚点没办法好好睡觉，是担心子妍为了等我降落等得太久，而我又忘了让她别等早点睡。</li>
<li>快十一点的时候我们飞到了南山群岛上空，第一次离九段线和曾母暗沙如此近（水平方向上），飞了这么久还没有离开祖国，更加深刻地意识到，没有强大的海军，是无法承载这这一切的。</li>
<li>海边防晒是一个大工程，稍有不慎便会前功尽弃。但即使被晒黑了，也没必要太着急，急也变不白。比较好的方式是待在水里，毕竟比较凉快。</li>
<li>飞机晚点在哪里都是大概率事件，毕竟天气谁都说不准。不过去了其他国家再想想祖国的航空，用如此少的空域能达到如此的效率，也是挺不容易的。晚点最让人难过的是关心你的人会担心得无法入睡。</li>
<li>出来玩大家一般都是比较友好的（尤其是驴友，毕竟谁没有个需要帮助的时候呢），所以脸皮不能太薄。</li>
<li>因为在海边 + 热带，长了很多痘痘，这种情况和我上次去稻城亚丁类似，回来需要修身养性（看来我还是不太适合这种生活）。</li>
<li>深潜的体验是很奇妙的，和陆地上看到的东西完全不同（而这一切仅仅需要下潜十米），就和无人机一样，都是换一个视角来看我们的世界。不过潜水确实是一项危险的运动，我们有教练带着都感觉有点可怕（呼吸，尤其是进水之后如何处理，每个步骤都要冷静不能出错）。游泳还是要会的，在海里游泳和在游泳池里是有很大区别的。</li>
<li>出来旅行吃和住很重要，不要在这里省钱，不然肯定得不偿失。另外海鲜并没有想象中那么惊艳，正常水平而已。</li>
<li>有一个静电是水上木屋，一堆小朋友划着船过来要吃的，会说的只有 hello，抢了东西就跑。眼神中没有任何赶集，有的只是贪婪和理所当然。我感觉很悲哀，也许很多东西真的就是生来注定的，感谢祖国一波。</li>
<li>一望无际的大海第一次见，清澈的海水和珊瑚第一次见，一群小鱼从身边游过是第一次体验。</li>
<li>岛和岛之间的距离基本都需要半小时以上，在途中前不着村后不着店的无力感，只有看到镇定自若的老司机船长船员才能缓解。不然在食物和水都短缺的情况下，真不知道要如何生存。</li>
<li>夜晚的星空很美，应该是我看过最多星星的夜晚。但这其中任何一颗我们在有生之年都无法触及，有种沧海一粟的感觉，人类是多么渺小。</li>
<li>一个愿意在各方面的持续学习的人才是真正的人，这么说的意思是只会机械重复工作的人和机器本质上没有区别。</li>
<li>船员们和教练们虽然样貌有不同，但性格的内核是一样的，不然也不可能会选择这样一份职业，即开朗乐观，随遇而安。</li>
<li>要买一个能看气压等各类指标的手表，时尚款的并没有任何卵用。</li>
<li>本地人只吃冰冻海鲜，新鲜的给游客吃。</li>
<li>东南亚人有些真的挺像猴子的，尤其是那些又黑又瘦的，越离开钢筋水泥的现代社会，越会发现像动物才是最有效率的。</li>
<li>经济和文化上的政府真的很有效，大部分人都有微信，但支付宝的推广还需要时间。另外中文以后肯定在东南亚是通用语言（比如说二十年后？）</li>
<li>旅行还是要轻装要背包，拿行李箱真的不酷，当然，度假除外。</li>
<li>最好吃的一顿是叉烧和海南鸡饭，其他的除了海鲜和肉骨茶之外，基本是糟糕的回忆。</li>
<li>用脚蹼游泳是很有趣的体验，脚蹼对于水中的行动力起着决定性的作用，不过我还不得要领，需要学习。</li>
<li>被殖民很容易失去能动性，毕竟什么都被决定了，就慢慢有了奴性。</li>
<li>中国游客居多，不得不说这有好有坏，不过在中文环境中确实压力比较小。</li>
<li>回家有人在口岸等我，是这趟旅途最完美的句号。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>潜水证还是要抽时间去考一下的，去东南亚旅行是很累人的，出门在外安全最重要，吃好睡好了才能玩好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一四七、三六九、九九归一跟我走，上天下海不回头。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="旅行" scheme="http://wdxtub.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="马来西亚" scheme="http://wdxtub.com/tags/%E9%A9%AC%E6%9D%A5%E8%A5%BF%E4%BA%9A/"/>
    
      <category term="潜水" scheme="http://wdxtub.com/tags/%E6%BD%9C%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>第五十六周 - 醉酒癫歌</title>
    <link href="http://wdxtub.com/2017/07/07/drunk-song/"/>
    <id>http://wdxtub.com/2017/07/07/drunk-song/</id>
    <published>2017-07-07T11:30:26.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>莫说狂狂人心存厚道，莫笑痴因痴心难找，莫怕醉醉过海阔天高，且狂且痴且醉趁年少。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.06: 完成初稿</li>
</ul>
<p>深圳又是一个星期的雨雨晴晴雨雨雨雨，更可怕的是天气预报里十天依然是九天有雨。印象中去年并没有这样多雨，和匹兹堡相比，深圳的雨更加爽快，可以十五分钟完成倾盆到明媚的转变，仔细想想，倒也符合两座城市的风格。</p>
<p>上个周末终于跑了一次步，跑完之后就把手机里唯一的运动健身应用给卸载了，主要原因当然是新一轮的 app 极简计划又启动了，只有时不时断舍离，才能把真正重要的事物凸现出来。随着年龄的增大，更加意识到时间的宝贵，所以要把时间多花在重要的人和事上。于是把那些耗时间的数值积累类游戏都删了，都是泡沫，还是好好写博客比较靠谱。</p>
<p>在创业公司最有趣的地方在于永远不知道这种真的会做什么，比如说我的主线任务是深度学习平台，但是上周因为粗粮公司的业务，学着去用内部开发的 seq2bow 工具（不用在意这些细节，大概就是从日志中自动构建知识库的工具），这周要测试几家不同服务提供商的语音识别接口，留给主线任务的时间基本是零（因为每个新任务对我来说基本都是从零开始，一个星期要学要研究要开发要测试，还是很紧的）。</p>
<p>好在无论过程多么艰难，结果大约是好的，不断看别人的代码去学习理解别人的思路，代码读得多了，竟有种看书的感觉，仿佛可以还原出当时那个写代码的人所处的场景和内心的想法（即使用了代码格式化工具，这些痕迹也依然存在），莫名觉得很有趣，好像在和谜之拍档合作一样。有的人性如烈火，写出来的代码也是简单粗暴；有的人细致入微，文档会标出大部分需要注意的地方；还有人的深思熟虑，一看就是接受过系统编码训练的科班出身。有的服务提供商提供的是 Restful API 接口，从参数的命名、加密的方式和开发文档的风格也能看出不同人、不同团队和不同公司的风格。</p>
<p>因为我们公司和腾讯 AI 加速器深度合作，前些天两个团队一起拉着讨论了一波需求，感觉很不错。并不是说我们提什么要求对方就答应什么要求，而是双方在讨论的过程中逻辑分明，不同任务有不同的优先级，能做到的就做，能去推动的就去推动，但不能做到或者没有排期的也会如实相告，这种坦诚本身其实才是合作最重要的东西。更巧的是，后来发现其中一个小哥跟我同一天生日，有缘分，果然接口调试的也是非常顺利。</p>
<p>今天历尽艰辛终于通过 cgo 成功调用了讯飞的 linux sdk，时隔这么多年重新写 c，不得不说是很艰难的事情，但是 Go 作为 C/C++ 系列的传人，能够毫无压力（当然损失不少性能）互相调用，其实是非常取巧的做法（该处为褒义）。因为 C/C++ 的代码质量大浪淘沙，留下来的基本都是精华，能够拿来用，自然是非常省心的，如果轮子够好，那么一次就够，也是某种程度上的环保嘛。</p>
<p>现在想想，创业最难的就是找方向和找人，因为人多才能做大事，即使我效率很高能顶十个人，但如果这个活一定是要二十一个人才能完成的话，工作就会陷入困境。但是如果提前一些准备够三十个人，就能从容面对，慢工出细活了​​​​。</p>
<p>这周因为子妍要去市里集中办公，所以下班之后的主要任务就是坐地铁换乘然后散步。我还是挺喜欢两个人一路边走边聊的，雨后不太热，晚风正轻抚，除了在体育场被群众的运动热情吓到之外，其他的都和最温情的小说里写得差不多。尤其打动我的是两件事，一是我工作中攻坚受阻的时候，子妍给我买了一堆肠粉和粥（于是我吃了两天才吃完），二是我跟子妍分享了一个介绍分形的应用之后，我们一起看分形公式和图像一起感受数学之美。能够找到志趣相投积极上进热爱学习的另一半很不容易，我得好好珍惜。</p>
<p>我颠颠又倒倒好比浪涛，有万种的委屈我付之一笑；我一下低我一下高，摇摇晃晃不肯倒，酒里乾坤我最知道。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;莫说狂狂人心存厚道，莫笑痴因痴心难找，莫怕醉醉过海阔天高，且狂且痴且醉趁年少。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>留学生入户深圳指南</title>
    <link href="http://wdxtub.com/2017/07/03/oversea-student-return-guide/"/>
    <id>http://wdxtub.com/2017/07/03/oversea-student-return-guide/</id>
    <published>2017-07-03T00:50:37.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为个人的生活和工作的变动，需要入户深圳（以留学生身份），所以在这里记录一下整个过程（因为网上的其他资料都不够详细）。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.07.03: 开始更新</li>
</ul>
<p>声明：本文只是个人的参考备忘，不代表任何意见或建议（也不承担任何责任），具体以规定和文件为准，本人不回答任何相关问题，遇到问题请看官自行解决（当然我会尽量写得详细，不过毕竟不同人的情况不一样，所以最重要是有灵性）。</p>
<p><strong>注意：所有资料拿到手都多复印几份，确保自己有一份复印件留底</strong></p>
<h2 id="获取教育部国外学历学位认证书"><a href="#获取教育部国外学历学位认证书" class="headerlink" title="获取教育部国外学历学位认证书"></a>获取教育部国外学历学位认证书</h2><ul>
<li>总体流程：注册及在线申请 -&gt; 在线支付认证费用 -&gt; 递交认证申请材料 -&gt; 查询认证进程 -&gt; 领取认证结果</li>
<li>所需费用：￥360(认证费用) + ￥25(邮寄费用) = ￥385</li>
<li>获得资料：国外学历学位认证书（一式两份）</li>
</ul>
<p>除照片、翻译件和授权声明外，所有材料须交验证机构验看原件（原件经现场审验后即行退回），只收取复印件。需要提交的资料有：</p>
<ol>
<li>一张近期二寸（或小二寸）证件照片，底色不限</li>
<li>需认证的国外源语言（颁发证书院校国家的官方语言）学位证书或高等教育文凭正本原件和复印件</li>
<li>需认证的国外学位证书（高等教育文凭）的中文翻译件原件（须经正规翻译机构（公司）进行翻译，个人翻译无效），深圳人才园服务大厅里就有做翻译的（就在认证窗口对面），翻完直接就可以到窗口办理学历认证</li>
<li>申请者留学期间所有护照（含护照首页-个人信息页、末页-本人签字页、以及所有留学期间的所有签证记录和出入境记录）原件和复印件</li>
<li>申请者亲笔填写的<a href="http://www.cscse.edu.cn/Portals/0/hg/sqsm.doc" target="_blank" rel="external">授权声明</a></li>
<li>如果是合作办学，需要国内大学学位证书或高等教育文凭正本原件和复印件</li>
</ol>
<p>可选材料：</p>
<ol>
<li>成绩单原件及复印件</li>
</ol>
<p>具体的步骤为：</p>
<ol>
<li>访问教育部留学服务中心的<a href="http://renzheng.cscse.edu.cn/Login.aspx" target="_blank" rel="external">国（境）外学历学位认证系统</a>，注册帐号并登录系统</li>
<li>填写完个人信息后，点击『新建申请』在线填写认证申请，进行国外学历学位认证申请</li>
<li>把该填写的东西都填写完之后（尤其是邮寄地址），进行网上支付（银联在线），费用为 ￥360(认证费用) + ￥25(邮寄费用) = ￥385</li>
<li>到选择的验证机构递交认证申请材料，我选择的是<a href="http://www.szhrss.gov.cn/wsbs/bszn/xwrz/" target="_blank" rel="external">深圳市人事人才公共服务中心</a><ul>
<li>联系人: 谭剑成</li>
<li>电话: 0755-88123601</li>
<li>地址: 深圳市福田区深南大道 8005 号深圳人才园行政服务大厅 16、17 号窗口</li>
</ul>
</li>
<li>可登录系统查询认证进程及状态</li>
<li>鉴定通过后（大概需要一个月），会得到一式两份的国外学历学位认证书</li>
</ol>
<p>相关文件：</p>
<ul>
<li><a href="http://renzheng.cscse.edu.cn/Html/rz_xz.html" target="_blank" rel="external">认证须知</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info6388.htm" target="_blank" rel="external">验证机构联系方式</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info13479.htm" target="_blank" rel="external">学历学位认证申请材料</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info3081.htm" target="_blank" rel="external">国外学历学位认证申请材料</a></li>
<li><a href="http://www.cscse.edu.cn/publish/portal0/tab105/info6386.htm" target="_blank" rel="external">常见问题解答</a></li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>根据我自己的进度更新</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为个人的生活和工作的变动，需要入户深圳（以留学生身份），所以在这里记录一下整个过程（因为网上的其他资料都不够详细）。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="留学生" scheme="http://wdxtub.com/tags/%E7%95%99%E5%AD%A6%E7%94%9F/"/>
    
      <category term="流程" scheme="http://wdxtub.com/tags/%E6%B5%81%E7%A8%8B/"/>
    
      <category term="深圳" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%9C%B3/"/>
    
  </entry>
  
  <entry>
    <title>第五十五周 - 心的旅程</title>
    <link href="http://wdxtub.com/2017/06/30/heart-journey/"/>
    <id>http://wdxtub.com/2017/06/30/heart-journey/</id>
    <published>2017-06-30T02:47:08.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们要一起乘风追寻梦的旅程，一路上带着那些口袋里的天真，穿越了天空穿越阴霾，向前走，大不了转个弯。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.30: 完成初稿</li>
</ul>
<p>深圳继续维持了一晒就是一天的炎热，六月转眼也来到了最后一天，一眨眼半年就过去了。好在今年上半年无论是工作生活还是感情都有了不小的进展，总体来说是一个<del>不错</del>完美的上半年。</p>
<p>潜水归来也快两周了，工作又回到了充满压力和挑战的节奏，不断要尝试新东西学习新技能，总是有很多答案未知甚至问题本身都未知的难题等着我们。开发只有了解到用户的痛点，才能真正做出有价值的产品，而了解痛点就需要在相同或类似的场景下感受不同的工作流程，走几遍就知道问题出在哪里了。但毕竟是在创业公司，临时插入的高优先级工作与主线工作的时间、精力分配，如何把握好这个度，很需要效率和判断力。</p>
<p>这周的主题曲不由得让我想起『Journey』这款游戏，风之旅人，<a href="http://wdxtub.com/2015/08/30/journey/">风之旅途</a>，心的旅程，新的旅程。在这个游戏中除了可以通过不同的按键发出声音之外，没有其他任何方式跟玩家互动，当然，你会发现很长一段时间内，这段旅程只有你一个人走。但是当未知的玩家出现时，这个游戏立刻有了变化，两人同行，面对大风和黄沙，似乎也有了多一份力量。没有语言，也就没有谎言；目标都是山顶，也就没有欺骗与怀疑。</p>
<p>游戏前期场景开阔，大家各玩各的自由飞翔，到了后期冰天雪地有些压抑，两个人就会不自觉得靠在一起，一起躲避敌人，一起对抗暴风雪。当我流连忘返于壮观美景而和陌生人失散之后，游戏一开始的孤独感又聚拢了起来。可是当我走到出口的时候，远远看见陌生人在喊着音阶等我，真的很想摔手柄，因为我居然没办法认识这个陌生人，甚至也不知道他是谁。但也许这也就是最好的羁绊。很难用言语来形容与不认识的旅人一起度过艰难险阻最后登上山顶的心情。有相遇就有分别，哪怕只能一起走一段旅程，也是令人难忘的记忆。</p>
<p>准备周记提纲的时候，无意中看到了当年记录的《亲密关系：通往灵魂的桥梁》的<a href="http://wdxtub.com/2014/09/11/close-relation-clip/">书摘</a>。有的时候重新翻翻老书的摘录，会有非常不一样的感受。</p>
<p>书中把亲密关系的过程分为以下几个阶段：绚丽、幻灭、内省和启示。对大部分人来说，这四个阶段是这样的：</p>
<ul>
<li>绚丽：即热恋期，总体表现是什么都好你好我好我们好。这种感觉良好会逐渐积累，让我们把自己从小到大得不到的、未满足的需求，全部都投射在那个爱我们、让我们觉得特殊的人身上，觉得有了他/她，这些需求都会得到满足</li>
<li>幻灭：我们总是会做出各种匪夷所思毫无逻辑的情感判断与行动选择，会懊悔会内疚会有压力，一方面，我们希望伴侣让我们快乐，而让对方感到压力；另一方面，我们自己也承受着压力，因为我们也必须做对方的『一切』。两个人都对彼此做过度的情绪索求，会在脆弱的亲密关系的互动上，施加极大的压力</li>
<li>内省：本质是在内心找到自己真正需要的事物，或者说是意识到不再需要什么来让自己变得完整，也就逐渐能够学会放手（不把需求强加在伴侣身上）和接纳（认识和接纳本来的自我）。并最终认识到：我们原本就是一个完整的个体，所需要的一切，都存在于我们心中</li>
<li>启示：需要双方的共同努力，在一段亲密关系中，伴侣之间愈亲密，分享就愈多，我们就愈可能发现平时不易察觉的旧伤。用愤怒来保护自己也就意味着用痛苦去伤害伴侣，为自己的愤怒负责的最佳方式是充分去感受它并发现生气到底是为了逃避什么。如果我们愿意面对自己所逃避的感觉（不论这令我们多么不自在），我们就能发掘埋藏在更深处的、平静而充满爱的感觉</li>
</ul>
<p>但真正到生活中，有的时候就会发现还真是应了那句老话：尽信书不如无书。因为就我和子妍的相处情况来看，我们的亲密关系并不归于上面提到的四个阶段，反而用『赌书消得泼茶香』更能表达。</p>
<p>注：赌书消得泼茶香这一典故说得是，李清照和丈夫都是著名的学者，情投意合恩爱无比，更重要的是，他们的爱是有层次有情调的，因为两人都爱看书。书看得多了，两人就打起赌来，一个问书籍中一个典故或是什么内容，另外一个人就要回答这个典故在哪本书中记载的，甚至具体到这本书在书架的位置。回答错了的话，就要将杯中的茶水倒进自己的衣服里，以示惩罚。原词为：谁念西风独自凉，萧萧黄叶闭疏窗。沉思往事立残阳，被酒莫惊春睡重。赌书消得泼茶香，当时只道是寻常。（清）纳兰性德</p>
<p>换句话说，因为我们从小到大的家庭环境和成长经历都颇为相似，也都爱读书爱思考，所以这段感情从一开始就是严肃活泼的。我们没有太多得不到或未满足的需求，我们能够认识到双方都是完整的个体，因此我们不会对彼此做过度的情绪索求。如果两个人一开始就是『明辨 博学 慎思 笃行』的，那么消极情绪、倦怠感、迷思及冲动大约是不存在的，存在的只是两个人认定彼此的坚定。</p>
<p>不合理的期望是愤怒的前奏，但合理的期待则是共同进步的最佳动力。我们为达到彼此的小小期待而努力，我们为每一点每一次互相深入了解而喝彩。正因为两个人都有足够的深度，所以新鲜感不会消散，眼前的世界反而会越来越开阔。我们不会沉迷于二人世界而成为坐井观天的井底之蛙，而是两个人合二为一同心协力踏上探索发现世界和人生的旅程。（我是多么幸福的人呀）</p>
<p>这是我们心的旅程，一起登上那座山，一起飞过那片海。乌云已经散开，阳光已经盛开，睁开眼就是未来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要一起乘风追寻梦的旅程，一路上带着那些口袋里的天真，穿越了天空穿越阴霾，向前走，大不了转个弯。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>第五十四周 - 至我们的星辰大海</title>
    <link href="http://wdxtub.com/2017/06/23/for-our-dream/"/>
    <id>http://wdxtub.com/2017/06/23/for-our-dream/</id>
    <published>2017-06-23T09:11:10.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>曾经的我那么懦弱畏惧着一切，也曾向往外面如此美丽的世界。用力挣扎用力忘记身上的烙印，却压抑不了胸中的热血。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.23: 完成初稿</li>
</ul>
<p>从马来西亚回来，由烈日骄阳转为连日阴雨，凉快是凉快了，但湿答答粘糊糊总是不太舒服，好在临近周末天终于开始放晴。虽然这让已经晒得很黑的我黑(xue)上加墨(shuang)，但是能看到蓝天白云，总归是一件让人开心的事情。</p>
<p>本以为是度假的旅行变成了某种意义上的修炼，体力透支，精神疲惫，回到深圳后缓了两三天才恢复正常。好在走之前已经提前多做了一些工作，总归还是按计划在推进项目。写代码这个事情是非常需要『谋定而后动』的，不然大部分时间都会浪费在拆东墙补西墙上，只有先花大量的时间去探索调研，才能在转为开发阶段的时候稳准狠，效率高的同时，出错也少。所以这周也算是『收割』以前的劳动成果，我把深度学习平台的前后端框架搭好并部署到服务器上，接下来就进入一点一点上线新功能，一点一点打磨产品的阶段了。</p>
<p>回过头来想想，其实做任何事情都是一样的，旅行也好，写代码也罢，无非是从一个地方到另一个地方，执行一些动作，遇到一些困难，寻找一些方案，然后问题解决皆大欢喜。这里面有一些经验是可以总结的，比如：</p>
<ol>
<li>凡事预则立：在机场临时托运行李的价格要比网上提前预订贵一倍还有多，如果不想花冤枉钱，就要提前安排好</li>
<li>遇事莫慌张：在仙本那找不到 ATM 取钱（后来走了三公里找到了，但是排队的人实在太多），总有退而求其次的方法，多问问人就好。脸皮厚带笑容体力好，基本上出去玩问题不大</li>
<li>吃住很重要：不要因为这样那样的原因在吃和住上省钱，尤其是住，我依然记得在酒店厕所里见到蟑螂时的恐惧。最后一晚住了 airbnb，感觉就好很多</li>
<li>不如烂笔头：舟车劳顿后很容易忘事儿，手机也要省着电不能一直看着，所以最好的方法就是带一个小本子带一支笔，然后走到哪写到哪，不但可以打发时间，更重要的是有些感受是过了就不再的，只有在那时那地才有那种心境</li>
<li>防晒记心间：第一次感受热带的烈日，一个字 -『可怕』。擦了多少防晒都没啥用，最靠谱的办法就是 - 一直待在船上，中策是 - 一直泡在海水里，下策是 - 跑到海滩上照相</li>
</ol>
<p>还会另外写一篇的（毕竟我在飞机上都手写了十几页），这里就不再赘述，继续来说说写代码做工程。</p>
<p>看《乔布斯传》的时候，让我印象最深刻的情节是乔布斯的老爸言传身教让乔布斯领会到了工程之道，即『看不到的地方也要做得优雅简洁』，这并不是为了吹毛求疵，其实才是某种意义上的『捷径』，毕竟脚踏实地才是走得最快的。那么，别人看不到（或不会看）的代码为什么要写得一样好呢，因为简洁本身是一种标准，在这样标准的要求下各个模块出错的概率会大大降低，或者说出了问题需要修补的地方大大减少。而且糟糕的方案和优雅的方案可能看起来差不多，但用户真正开始用的时候，糟糕的方案就会出这样那样的问题，消耗用户对产品的信任；而优雅的方案会让用户感受到优雅简洁的力量，更重要的是用户会觉得这玩意儿靠谱，很多事情都是这样，用户对你有信心，那再难的事儿很可能也不是事儿了。</p>
<p>前些天在微博上看到西瓜大丸子汤说：程序员是一种罕见的从职业的极早期，就建立根深蒂固的协作思维的职业。代码要重用，文档要清晰，架构要考虑演化，数据要考虑用户容错。不但要和已知的队友合作，还要考虑和未知的人合作。所以程序员是特别开放的职业。在和其他一些职业对照后，就发现这种特质是多么难能可贵。合作才能改变世界。</p>
<p>确实，拥抱开源之后就会深深意识到程序员是一个多么理想主义又脚踏实地的群体（当然也有部分没有灵性的，略去不表）。在此之前我从未想过要以何种方式和全球各地并不认识的人合作，但通过群体智慧，我们真的让这个世界运行得更有效率也更加简洁了（隐藏复杂度是工程的一部分）。当然，能做要做的事情还有很多，我还要继续努力努力修行。</p>
<p>还记得很多年前我看过的一本杂志，里面提到了『<a href="http://wdxtub.com/2013/06/24/slow-net/">慢网</a>』这个概念，那时候就觉得这可能是未来的方向，毕竟随着智能设备逐渐吞噬我们的时间，总有一天会开始反转。最近我生活的重心也逐渐转向线下，下班后散散步逛逛街看看电影，去亲朋好友家拜访这些都是生活中很重要的一部分，网络不再是一个目的，最终成为了一个工具。</p>
<p>这周和子妍一起回广州，能够一起在大巴上晃悠，一起走在我走过无数次的街道上，非常开心。虽然街道年年变化感觉又熟悉又陌生，虽然天气捉摸不定几时晴几时雨，但只要一直在往前走，蓝天白云彩虹流星明月星空都会有的，我对此很有信心。虽然说从孩子身上可以看到整个家庭家族所施加的影响，但是真正去见一下，去感受一下也非常重要。一开始是两个人，后面是两个家庭，再后面是一个大家庭，整个融合交织的过程其实也是逐渐『共生』的过程，如果大家的 DNA 不匹配，这个磨合的过程就会很痛苦。但是一旦遇到了对的人，那这个碱基对就像 ATCG/ATGC/TACG/TACG 那样完美配对行云流水，组合出来超级水稻亩产一千八（一袋能顶两袋洒2333）。这个故事告诉我们，不要说找到，哪怕是遇到投缘的人，已经是很不容易；遇到，然后还要彼此欣赏喜欢，那就更是需要缘分和运气了（我终于明白了为什么我从小抽奖的手气都这么差了）。</p>
<p>挥舞双臂微笑面对我的明天，勇敢跨越我会迎风向前。努力飞吧，打破所有阻挡；飞吧，昂头冲上云霄。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经的我那么懦弱畏惧着一切，也曾向往外面如此美丽的世界。用力挣扎用力忘记身上的烙印，却压抑不了胸中的热血。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第五十三周 - 声律启蒙</title>
    <link href="http://wdxtub.com/2017/06/15/rhythm-inspiration-2/"/>
    <id>http://wdxtub.com/2017/06/15/rhythm-inspiration-2/</id>
    <published>2017-06-15T00:06:37.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>鬓皤对眉绿，齿皓对唇红。天浩浩，日融融，佩剑对弯弓。</p>
<p>注：本周周记因为要去沙巴旅游而不得不提前写完提前发</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.15: 完成初稿</li>
</ul>
<p>细心的读者估计会发现，这是我的周记系列第二次用『声律启蒙』这个标题了，第一次单纯是觉得歌词有意境，而这次更多的是意识到不经意间往往是命中注定。</p>
<p>先来说说工作，因为本周要和同事们一起去旅游，所以工作上主要是以完善现有代码和为回来之后的自己做好交接工作为主，具体来说就是打磨现有的模块，并且为未来的模块总体统筹规划。一个人负责这类偏预研的项目其实压力和风险都不小，一是因为在没有出成果之前，确实会处于『不足为外人道也』的状态，大家都很忙，所以没有人会细细听慢慢看项目的进展，更多时候是以结果为导向的，即只要事儿做好了，哪怕所有的代码都是复制粘贴完全不可维护，也无所谓（创业公司嘛）；二是因为这个项目本身就是一个非常前沿的方向，没有现成的解决方案不说，我还需要兼容公司原有的工作流，在设计和开发上都有些带着镣铐跳舞的意思。</p>
<p>不过困难和挑战越大，做出来的东西才越有价值，我能做的就是不断思考，边写边重构，优化设计思路，用最合适的工具完成任务，争取早日出成果。不过话说回来，今年第一次出游，也许回来之后一切就豁然开朗了，毕竟要努力工作痛快玩嘛！</p>
<p>然后接着上周的话题，继续来聊聊爱情（我发现原来朋友们更喜欢看情感话题）。</p>
<p>从博客里翻出两年前看《爱是光着脚的哲学》之后写的书评，便又一次意识到了『纸上得来终觉浅』。这本书其实并没有写太多新鲜的东西，是把柏拉图的《会饮篇》和《斐德罗篇》，以及莎士比亚的《奥赛罗》与《仲夏夜之梦》中关于爱情的内容串讲了一遍。我们在日常生活中总是会看到许许多多关于情感的困惑，但倘若我们回过头去看看前辈们的思考，就会发现那些历经千年的答案，很可能就是参考答案（但并不是正确答案，毕竟没有一个衡量对错的标准）：</p>
<ul>
<li><strong>斐德罗</strong>：情爱最伟大之处，在于它能使任何人都成为最好的勇士。爱情比其他任何人类关系更能够激发我们达到理想的状态。</li>
<li><strong>鲍萨尼亚</strong>：天上的阿佛洛狄忒主导着一种纯男性浪漫爱情的人生，只关注被爱之人的灵魂，而世俗的阿佛洛狄忒所支配的只是肉体的浪漫欲望，这种快感可以从男人身上获得，也可以从女人身上获得。有序的、属天的爱是完全关乎灵魂的，而无序的、属地的爱则完全是关乎肉体的</li>
<li><strong>厄律克西马库</strong>：核心理念是平衡或和谐。爱情这门艺术就是要找出灵魂和肉体中各种要素的正确平衡。爱是能够让凡人接触到神圣之物的载体。灵魂中有健康的爱也有邪恶的爱，同样地，肉体中也分健康的爱和不健康的爱</li>
<li><strong>阿里斯托芬</strong>：人类的情爱能力在多大程度上能尊重和融合男性和女性的体验，在理解爱情时，喜剧本身应该是我们必备的一个重要视角，如果我们太过严肃，最终可能会迷失双眼，无法真正看清我们所试图了解的真相。</li>
<li><strong>吕西亚斯</strong>：为什么最好避开对我们有爱情的人？因为一个有爱情的人从本质上来说是个疯狂之人，已经不能用头脑清醒地思考。由此，和一个有爱情的人相处，就必须要忍受他可能做的各种疯狂举动。爱你的人，对你有极强的占有欲，他会试图将你从亲朋好友身边拉走，因为他会嫉妒你和他们在一起的时间，他希望你所有的精力都集中在他身上，死心塌地地认为拥有他会让自己安心，得到保护。</li>
<li><strong>狄奥提玛</strong>：爱情和欲望暗含着需要和缺乏。爱智慧的哲人是情爱生活的模范榜样，因为他们一刻不停地寻求智慧，这种寻找从不会放弃，也不会满足。爱身上丰富和贫乏的结合，让他始终处于生气勃勃和贫乏衰败两种状态的交替之中。这种永不停息的循环就是情爱生活的本质所在。当我们一旦遇上美丽的爱人时，我们就会体验到，那种创造新生的冲动。正确的浪漫爱情，应该能鼓舞我们渴望成为一个更加完美的自己。</li>
<li><strong>苏格拉底</strong>：对于像我们这样终有一死的众生来说，我们期望情爱不朽，超过我们的生命长度。因此，情爱欲望的中心部分，就是某种战胜死亡、抵达永恒的渴望。爱是我们抵达不朽的阶梯。苏格拉底式的创造力是双性同体的，男子气概和女性气质，通过孕育而完美融合——身体和精神双重意义上的。</li>
<li><strong>柏拉图</strong>：当我们坠入爱河，我们没有像有些人说的那样“安定下来”，而是变得不安分，以我们以前从来不敢想象的方式去追寻。因此，浪漫生活是一种充满渴望、不断追求的生活，而不是一种简单满足的生活：是一种舍弃。浪漫让我们体会到，生活并不完美。通过哲学，我们学到一个艰难的事实：我们常常害怕并且躲避现实。但是，当我们坠入爱河并开始作为爱人和被爱之人的崭新自我时，这种害怕反而没有之前来得强烈。</li>
</ul>
<p>不知道大家认同哪一位先贤的观点？当年的我首推柏拉图（注：和我们现在理解的柏拉图式爱情还是有很大区别的），现在的我不会去在意爱情是什么形状，而更关注最终能发现怎么样的新世界。至今我还是心心念念《爱的艺术》中的这么一段话：</p>
<blockquote>
<p>爱情只能产生于这样两个人中间，这两个人都从他们生存的圈子里跳出来并互相结合，同时他们每个人都又能脱离自我中心去体验自己。只有这种『中心体验』才是人的现实，才是生活，才是爱情的基础。这样体验到的爱情是不断地挑战，这种爱情不是避风港，而是一种共同的努力、成长和劳动。如果两个人能从自己的生命的本质出发，体验到通过与自觉地一致，与对方结成一体，而不是逃离自我，那么在这样的基本事实面前，就连和谐、冲突、欢乐和悲伤这样的东西也就只能退居第二位了。“爱情的存在只有一个证明：那就是双方联系的深度和每个所爱之人的活力和生命力。这也是我们所能看到的爱情的唯一成果。</p>
</blockquote>
<p>每当看到这些充满憧憬的画面我都会想，一个人得是多么幸运，才能拥有这样的『中心体验』，才能在共同的努力、成长和劳动中，让双方联系的深度更深，让每个所爱之人的活力和生命力更强。</p>
<p>我也一直在想，阅读、写作和思考让我最终成为了我，却也让人孤独。我有了更为广阔的精神世界，却发现那片土地原没有现实中来得拥挤，甚至想要擦肩而过，很多时候都是一种奢望。但忽然有一天，我发现这么一个人，我想说的话也是她想说的，我看过的书也是她看过的，我爱听的歌也是她爱听的，我想走的路也是她想走的，我想看的风景也是她想看的。我也逐渐意识到这些巧合绝不是偶然，不经意间往往是命中注定。我也相信这样美好的巧合还会越来越多。</p>
<p>回过头去看看前人的观点，他们都很机智地没有提及时间这个变量，即两个人在一起要多久才能达到理想状态。这个其实和速度的公式是一样的，即  $v_t = v_0 + at$ ，如果初速度和加速度足够大，那么时间即使不长，也可以达到足够理想的境界。就好像两辆车一起公路旅行，如果都是慢车，自然走不快；如果一快一慢，如果要通行则只能迁就慢的；但如果都是好车，那自然可以一路驰骋，春风得意马蹄疾。</p>
<p>如果目标是星辰大海，那么只要前期准备完成，就不用去在意老黄历中的黄道吉日，对于探索者来说，每一天都是黄道吉日。</p>
<p>女子眉纤，额下现一弯新月；男儿气壮，胸中吐万丈长虹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鬓皤对眉绿，齿皓对唇红。天浩浩，日融融，佩剑对弯弓。&lt;/p&gt;
&lt;p&gt;注：本周周记因为要去沙巴旅游而不得不提前写完提前发&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="旅行" scheme="http://wdxtub.com/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第五十二周 - 君是山</title>
    <link href="http://wdxtub.com/2017/06/09/you-are-mountain/"/>
    <id>http://wdxtub.com/2017/06/09/you-are-mountain/</id>
    <published>2017-06-09T07:56:27.000Z</published>
    <updated>2017-08-03T14:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>君是君，山归山。明月石上，流连琴声晚。水千尺，双扶摇，倒影船。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.09: 完成初稿</li>
</ul>
<p>一整周的晴空万里一扫之前的阴霾，让人心旷神怡。还记得多年前在五道口过街通道中透过玻璃看到的蓝天，大约北方的天空就是和南方的有些不同吧。</p>
<p>如果把时间倒回到 09 年，那天的我终于考完了最后一科 - 物理，也标志着我在执信的生活要划上一个句号了。我一直觉得执信给我的不仅仅是三年高中，而是一群志同道合同时又充满灵性的朋友，让我得以真正开始自己的人生。但我未曾想过的是，高考那年，直到今天仍旧以各种意想不到的方式影响着我，改变着我。</p>
<p>我还清楚得记得中考的时候妈妈跟我说过，华附有全省招生的班，里面可汇聚着全广东最厉害的学生（那时候华附是全省招生，而执信只限于广州市）。我当时想着『我才不要到压力那么大的地方去呢』，便带着所有的憧憬来到了执信（这里得插一句，那年中考我的总分是广州市的第 35 名，所以理论上我想去哪就去哪）。</p>
<p>而如今，我遇到一个人，我来自执信她来自华附，我学物理她学化学，我们同年高考，她比我高一分。我们都去了中山大学，甚至也许在明德园到至善园的路上擦肩而过，毕业后兜兜转转最后此时此刻在深圳相遇。我不禁想引用来自漳州大儿童的一名小朋友的诗（并画蛇添足）：</p>
<blockquote>
<p>天空喜欢收集阳光，时钟喜欢收集数字，插座喜欢收集电，而我喜欢收集你。</p>
</blockquote>
<p>很多事情是第一眼就可以看出来的，比如说有没有灵性。就像前面三句出自小朋友之手的诗歌，只要看一眼，就能意识到孩子观察世界的角度与表达方式是多么有趣。天空与阳光，时钟与数字，插座与电，居然能用『收集』来联系到一起，仿佛透过文字都能看到那颗打量世界的好奇心。</p>
<p>但很多事情是很难第一眼就能看出来的，比如说识人。不同的人生像环绕的年轮与无言的大地，要细细品慢慢看才能琢磨一二。童年与成长，少年与叛逆，青年与选择，又如何能够在惊鸿一瞥之间一目了然呢？我们都想遇到另一个自己，却在不断的找寻中，发现这真的是太难了，太需要坚持，太需要努力，太需要缘分。没有坚持，路走不长；没有努力，路走不远；没有缘分，路走不到一起。</p>
<p>我开始感谢自己这些年来的写作，不但给了我自己一个跟过去对话的机会，也给了懂我的人一个参与我过去的机会。当我读着她五六年前的文字，仿佛又回到了当年的青葱激扬。我们的人生与记忆得以通过文字在更长的时间维度中交织，原来，我们已经认识那么久了。</p>
<p>我们一起跟弗洛姆探讨过爱的艺术，一起了解过上帝如何掷骰子，一起见证了一九八四的故事，一起等怪物来敲门，一起拯救今天拯救世界，一起狩猎鬼王，一起沐浴皎洁月色，一起喂蚊子。</p>
<p>终于能高兴的告诉自己，一个死理性派的人化，完成了。</p>
<p>最后照例还是要提一下工作，这段时间我的主要经历是设计和搭建深度学习平台，能够有机会仔细去琢磨一个问题，而且是在时代最前沿的还没有所谓最佳解答的问题，其实是特别幸运的事情。得跟其他所有敢于突破的探险家一样，跳出思维的桎梏，用全新的方式去解决问题。</p>
<p>所谓全新的方式，并不是说可以把原来的东西都抛诸脑后，把相关的文档，前人的积累捋清楚还是非常重要的，因为只有掌握了来龙去脉，遇到问题的时候才能对症下药，不然直接就上手做，反而欲速则不达。我的经验是项目开始的时候一定要慢，前面构思和调研的越清楚，后面走的弯路就越少。目的有多明确，项目就能做到多好，越是根基，越要慢，越要打好。</p>
<p>觉得自己很幸运，要更加努力，去配得上这份幸运。</p>
<p>君是山，山若水，飞雾流烟不懂琴声泪。情喝不干，一生长一梦短，相知不为红粉，相约只为来生再伴随。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;君是君，山归山。明月石上，流连琴声晚。水千尺，双扶摇，倒影船。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习平台设计指南</title>
    <link href="http://wdxtub.com/2017/06/05/deep-learning-platform-design/"/>
    <id>http://wdxtub.com/2017/06/05/deep-learning-platform-design/</id>
    <published>2017-06-05T01:18:40.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了更好理解深度学习平台的定位和作用，我先来讲两个小故事。</p>
<h3 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h3><p>一位侠客来到大师面前，有气无力地问到：『大师，我已拿到了各种极品装备，本人的属性值也超高，为什么我还是没办法行走江湖呢？』</p>
<p>大师头也不抬说：『因为你都快饿死了，身体已经撑不住，这些属性和装备又有什么用呢？』</p>
<h3 id="故事二"><a href="#故事二" class="headerlink" title="故事二"></a>故事二</h3><p>实验室最新打造了一台号称最智能的汽车，老板和研究组长在发布仪式后一起试乘。汽车开动之后体验了各种智能功能，老板觉得很满意，于是说：『来我们换个档飙一把』。</p>
<p>研究组长面露难色，语音操作车停下，然后下车打开前盖，开始把车里的芯片换成另一个档的芯片，之后再上车、启动。</p>
<p>老板说：『这不行，用户体验智能了，但是车的体验智障了』</p>
<h3 id="阅读理解"><a href="#阅读理解" class="headerlink" title="阅读理解"></a>阅读理解</h3><p>第一个故事说的是深度学习平台的建设一定是要基于公司目前的状况和未来的发展，不然用的技术再先进，没有对业务产生价值，那就是拿公司的未来做慈善了。毕竟公司都倒了，有这么个平台又有什么用呢？</p>
<p>第二个故事说的是深度学习目前落地的一些痛点，因为暂时没有一个成熟的流程体系，从研发到真正应用到产品上，中间的环节繁琐易出错不说，也没有一个统一的管理、监控的最佳实践。虽然交付给用户和客户的产品是『智能』的，但创造智能的过程是『智障』的，所以平台的作用在于探索和规范，把软件工程的成功实践应用到以深度学习为代表的人工智能技术上。</p>
<h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><p>因为深度学习的工程化远不如传统软件成熟，大部分时候小公司的训练流程是这样的：</p>
<ul>
<li>研究人员在本地测试算法</li>
<li>通过 SSH 和各类辅助工具把代码上传到服务器</li>
<li>修改代码进行各类数据配置</li>
<li>进行测试</li>
<li>测试后人工收集结果</li>
</ul>
<p>最开始只有一两台机器，一两张 GPU 卡的时候，这个方案是最简单粗暴，所需要的人工成本也较低。但随着单机多卡甚至多机多卡的全面铺开，随着在线流程和离线机器的不断增加，原来的方法难以为继，需要更有效率且更科学的方式来组织整个从研发到落地低流程，这也正是深度学习平台的价值所在。（感谢炳廷修改错别字）</p>
<h2 id="平台定位"><a href="#平台定位" class="headerlink" title="平台定位"></a>平台定位</h2><p>从前面的故事中我们可以把平台的具体定位细化一下，简单来说是：</p>
<ul>
<li>高效支持业务。提高业务的效率是第一位的<ul>
<li>包括业务的新增、调整、删除</li>
<li>各个步骤都应该是可以配置的，最好有 Web UI 来可视化编辑（避免通过改脚本，因为很容易出错）</li>
</ul>
</li>
<li>高效支持研发。尽量少侵入研发原有的流程，或提供外部工具支持<ul>
<li>研发过程是非结构化、敏捷的，需要有机制把测试好的算法规范化</li>
<li>结果验证和测试的自动化，版本化，便于跟踪对比算法效果</li>
<li>尽量给研发人员最大的自由度的同时，保证系统的鲁棒性</li>
<li>减少不必要的训练，根据业务的需求支持峰谷的利用</li>
</ul>
</li>
<li>连接已有系统。做信息中枢，用统一的架构提高资源利用率和信息的流转速度<ul>
<li>把原来单机的脚本改造成集群操作</li>
<li>利用分布式存储打通各台机器的存储，统一输入与输出</li>
<li>计算资源池化，考虑跨地区，跨云的解决方案</li>
</ul>
</li>
</ul>
<h2 id="需求分解"><a href="#需求分解" class="headerlink" title="需求分解"></a>需求分解</h2><p>不同用户角色对系统的需求也是不一样的，按照通常的分类方法，这里把系统需求以科研、后台、产品、运维四个角度来进行划分，具体如下：</p>
<h3 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h3><p>算法的研发人员最关心的只有一个事情：如何快速测试验证算法，查看算法效果。</p>
<p>在此基础上对其工作流程不能侵入太多，毕竟各有各的工作习惯，不能也没必要做太多要求，只要保证输入、运算和输出的接口一致即可（当然需要一定的修改，尽量简单或提供转换工具）。所以对于科研来说，难点在于如何在整合现有本地和服务器上的训练流程的同时，保持整个逻辑的简洁，并且让每个步骤都可配置。</p>
<h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>后台的开发人员最关心的只有一个问题：如何保证服务的高效稳定，如何缩短业务部署上线或做其他调整的时间。</p>
<p>这就意味着能自动化的流程要尽量自动化，因为深度学习平台主要关注于深度学习本身，所以只要和后台系统能够自动对接，并且整个过程可以监控，能够容错（比如自动重试）。这部分其实跟传统的软件工程联系比较紧密，只要有老司机把关，基本问题不大，对好接口即可。（打个小广告，我司来自腾讯的老司机后台团队非常靠谱，有想写 C++ 的同学请联系我）</p>
<p>对于小公司来说，很多时候运维的工作也会逐步转为 DevOps 模式，在我看来，运维的核心就是有一种方法能够清晰快速了解系统的运行状态，出了问题能够在自动修复的基础上进行一定的通知和告警，这些都是能够集成到系统中的。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>产品最关心的是功能和交互是否达到了用户期待以及如何去跟踪各个功能点的表现。</p>
<p>虽说看起来这个跟深度学习关系不大，但实际上产品经理对深度学习（至少是流程）需要有一定的了解，这样才能做到『量体裁衣』，用合适的形式展示最智能的功能给用户提供最完美的体验（无论是 2B 还是 2C 都是如此）。</p>
<p>那么深度学习平台需要提供的是有实效性且可参考的模型训练及测试数据，这样无论是产品经理还是项目经理心理都更有数，在和客户沟通的时候更有把握。说白了这是一个期待值管理的问题，心里有底，自然不一样。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文简单从设计的角度介绍了我对深度学习平台的一些想法（因为是公司的项目，所以只能讲一下思路，具体就不展开了）。感谢 glen 总、杨老师、文博和 jelly 的指导和检查，除了设计指南，之后还会写一下技术实现上的难点和重点，希望大家喜欢。</p>
<hr>
<p>最后依然是一波招聘小广告</p>
<ul>
<li>能力要求：全栈 + Docker + K8S + Tensorflow + Spark</li>
<li>任务目标：搭建深度学习平台，开发深度学习算法</li>
<li>如果不甘心当个螺丝钉，为什么不来一起搞点事情呢？</li>
<li>联系方式：老读者都知道的，这里就不赘述了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在人工智能浪潮汹涌袭来的时候，如果有一个好的深度学习平台，就像弄潮儿拥有了一块顶级冲浪板，只要技术好，没有乘不了的风和破不了的浪。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 学习笔记</title>
    <link href="http://wdxtub.com/2017/06/05/k8s-note/"/>
    <id>http://wdxtub.com/2017/06/05/k8s-note/</id>
    <published>2017-06-05T01:06:25.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.05: 开始学习</li>
</ul>
<h2 id="Kubernetes-基础"><a href="#Kubernetes-基础" class="headerlink" title="Kubernetes 基础"></a>Kubernetes 基础</h2><p>先来看一段来自<a href="http://www.paddlepaddle.org/doc_cn/howto/usage/k8s/k8s_basis_cn.html" target="_blank" rel="external">这里</a>的简介（我更新了一下链接）：</p>
<p>Kubernetes 是 Google 开源的容器集群管理系统，其提供应用部署、维护、扩展机制等功能，利用Kubernetes 能方便地管理跨机器运行容器化的应用。Kubernetes 可以在物理机或虚拟机上运行，且支持部署到 AWS，Azure，GCE 等多种公有云环境。介绍分布式训练之前，需要对 Kubernetes 有一个基本的认识，下面先简要介绍一下本文用到的几个 Kubernetes 概念。</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="external">Node</a> 表示一个 Kubernetes 集群中的一个工作节点，这个节点可以是物理机或者虚拟机，Kubernetes 集群就是由 node 节点与 master 节点组成的。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="external">Pod</a> 是一组(一个或多个)容器，pod 是 Kubernetes 的最小调度单元，一个 pod 中的所有容器会被调度到同一个 node 上。Pod 中的容器共享 NET，PID，IPC，UTS 等 Linux namespace。由于容器之间共享 NET namespace，所以它们使用同一个 IP 地址，可以通过 localhost 互相通信。不同 pod 之间可以通过IP地址访问。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="external">Job</a> 描述 Kubernetes 上运行的作业，一次作业称为一个 job，通常每个 job 包括一个或者多个pods，job 启动后会创建这些 pod 并开始执行一个程序，等待这个程序执行成功并返回 0 则成功退出，如果执行失败，也可以配置不同的重试机制。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="external">Volume</a> 存储卷，是 pod 内的容器都可以访问的共享目录，也是容器与 node 之间共享文件的方式，因为容器内的文件都是暂时存在的，当容器因为各种原因被销毁时，其内部的文件也会随之消失。通过 volume，就可以将这些文件持久化存储。Kubernetes 支持多种 volume，例如 hostPath(宿主机目录)，gcePersistentDisk，awsElasticBlockStore等。</li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="external">Namespaces</a> 命名空间，在 kubernetes 中创建的所有资源对象(例如上文的 pod，job)等都属于一个命名空间，在同一个命名空间中，资源对象的名字是唯一的，不同空间的资源名可以重复，命名空间主要为了对象进行逻辑上的分组便于管理。本文只使用了默认命名空间。</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolume</a>: 和 <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="external">PersistentVolumeClaim</a> 结合，将外部的存储服务在 Kubernetes 中描述成为统一的资源形式，便于存储资源管理和 Pod 引用。</li>
</ul>
<p>如果看不懂，也没有关系，接下来会更详细介绍。PS. 官方文档很有灵性，建议有英文阅读能力的同学去通读一遍，这里只是我的一些学习笔记，不如原版这么有逻辑性。</p>
<p>Kubernetes 集群让多台机器像一个单一组件一样运行，但是有一个前提条件，就是应用需要被打包到容器里。打包好之后 Kubernetes 会自动化地以一种高效的形式去调度容器们。一个 Kubernetes 集群有两种类型的资源：</p>
<ul>
<li><strong>Master</strong> 负责调度集群，维护应用状态，扩展应用和滚动更新</li>
<li><strong>Nodes</strong> 负责运行各个应用。每个节点有一个 <code>Kubelet</code>，是在每个节点上的客户端，负责与 master 交流。一个 Kubernetes 集群至少需要 3 个 node。<ul>
<li>如果想要体验一下，可以使用 Minikube，会在单机上创建虚拟机来搭建集群（本文的教程也是用这个来展示的）</li>
</ul>
</li>
</ul>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; minikube version</div><div class="line">minikube version: v0.15.0-katacoda</div><div class="line"></div><div class="line"><span class="comment"># 启动集群</span></div><div class="line">$&gt; minikube start</div><div class="line">Starting <span class="built_in">local</span> Kubernetes cluster...</div><div class="line"></div><div class="line"><span class="comment"># 查看版本</span></div><div class="line">$&gt; kubectl version</div><div class="line">Client Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"2017-01-12T04:57:25Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.4"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line">Server Version: version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"5"</span>, GitVersion:<span class="string">"v1.5.2"</span>, GitCommit:<span class="string">"08e09955</span></div><div class="line">4f3c31f6e6f07b448ab3ed78d0520507", GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"1970-01-01T00:00:00Z"</span>,</div><div class="line">GoVersion:<span class="string">"go1.7.1"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># 查看集群状态</span></div><div class="line">$&gt; kubectl cluster-info</div><div class="line">Kubernetes master is running at http://host01:8080</div><div class="line">heapster is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/services/heap</div><div class="line">ster</div><div class="line">kubernetes-dashboard is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/s</div><div class="line">ervices/kubernetes-dashboard</div><div class="line">monitoring-grafana is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/ser</div><div class="line">vices/monitoring-grafana</div><div class="line">monitoring-influxdb is running at http://host01:8080/api/v1/proxy/namespaces/kube-system/se</div><div class="line">rvices/monitoring-influxdb</div><div class="line"></div><div class="line"><span class="comment"># 获取可用的 node</span></div><div class="line">$&gt; kubectl get nodes</div><div class="line">NAME      STATUS    AGE</div><div class="line">host01    Ready     15m</div></pre></td></tr></table></figure>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>Kubernetes 集群启动之后，就可以在这之上部署应用了。部署应用的时候 master 会进行调度并选择合适的 node，启动之后仍旧会继续监控，一旦出问题，就会自动重新启用。</p>
<p>我们可以使用 Kubernetes 命令行工具 <code>Kubectl</code> 通过 Kubernetes API 来管理部署。创建部署的时候需要指定镜像和要运行的副本个数（当然也可以后面更新），然后们就实际来部署一波，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 部署应用</span></div><div class="line">$&gt; kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080</div><div class="line">mp:v1 --port=8080ubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootca</div><div class="line">deployment <span class="string">"kubernetes-bootcamp"</span> created</div><div class="line"></div><div class="line"><span class="comment"># 列出部署</span></div><div class="line">$&gt; kubectl get deployments</div><div class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">kubernetes-bootcamp   1         1         1            1           1m</div><div class="line"></div><div class="line"><span class="comment"># 查看部署</span></div><div class="line"><span class="comment"># 先通过 proxy 连接到正在运行的容器</span></div><div class="line">$&gt; kubectl proxy</div><div class="line">Starting to serve on 127.0.0.1:8001</div><div class="line"></div><div class="line"><span class="comment"># 然后打开一个新 tab，输出 Pod 名字</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-n7q3n</div><div class="line"></div><div class="line"><span class="comment"># 获取这个 pod 的输出</span></div><div class="line">$&gt; curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/<span class="variable">$POD_NAME</span>/</div><div class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-390780338-n7q3n | v=1</div></pre></td></tr></table></figure>
<h3 id="查看应用"><a href="#查看应用" class="headerlink" title="查看应用"></a>查看应用</h3><p>每个应用会在一个 Pod 中运行，一个 Pod 里可以有一个或多个应用（相当于给这些应用创建了一个共有的 localhost 环境，每个 pod 里的网络等环境是共享的）。</p>
<p>每个 Pod 都会运行在一个 Node 上，每个 Node 都由 Master 来管理。其中，每个 Node 都必须要有：</p>
<ul>
<li><code>Kubelet</code>，负责与 Master 通讯，管理 node 上运行的 pods 和 containers</li>
<li>一个容器的 runtime，比如 docker，用来从 registry 拉取镜像，解压与运行应用</li>
</ul>
<p>常用的 <code>kubectl</code> 命令有</p>
<ul>
<li><code>kubectl get</code> 列出所有的资源</li>
<li><code>kubectl describe</code> 显示资源的详细信息</li>
<li><code>kubectl logs</code> 输出一个 pod 中一个 container 的日志</li>
<li><code>kubectl exec</code> 在一个 pod 中的一个 container 中执行命令</li>
</ul>
<p>例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-6b9n3   1/1       Running   0          41m</div><div class="line"></div><div class="line"><span class="comment"># 查看 pods 详细信息</span></div><div class="line"><span class="comment"># 包括 镜像、IP 等各类信息，describe 不仅可以用于 pods，node 和 deployment 都可以</span></div><div class="line">$&gt; kubectl describe pods</div><div class="line">Name:           kubernetes-bootcamp-390780338-6b9n3</div><div class="line">Namespace:      default</div><div class="line">Node:           host01/172.17.0.41</div><div class="line">Start Time:     Mon, 05 Jun 2017 03:05:07 +0000</div><div class="line">Labels:         pod-template-hash=390780338</div><div class="line">                run=kubernetes-bootcamp</div><div class="line">Status:         Running</div><div class="line">IP:             172.18.0.2</div><div class="line">Controllers:    ReplicaSet/kubernetes-bootcamp-390780338</div><div class="line">Containers:</div><div class="line">  kubernetes-bootcamp:</div><div class="line">    Container ID:       docker://9308ecb7bb592255b5fb517ec7caa13703f7b5bb41a24145ba1eeb670693a60d</div><div class="line">    Image:              docker.io/jocatalin/kubernetes-bootcamp:v1</div><div class="line">    Image ID:           docker-pullable://jocatalin/kubernetes-bootcamp@sha256:0d6b8ee63bb5</div><div class="line">7c5f5b6156f446b3bc3b3c143d233037f3a2f00e279c8fcc64af</div><div class="line">    Port:               8080/TCP</div><div class="line">    State:              Running</div><div class="line">      Started:          Mon, 05 Jun 2017 03:05:08 +0000</div><div class="line">    Ready:              True</div><div class="line">    Restart Count:      0</div><div class="line">    Volume Mounts:</div><div class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-74qlr (ro)</div><div class="line">    Environment Variables:      &lt;none&gt;</div><div class="line">Conditions:</div><div class="line">  Type          Status</div><div class="line">  Initialized   True</div><div class="line">  Ready         True</div><div class="line">  PodScheduled  True</div><div class="line">Volumes:</div><div class="line">  default-token-74qlr:</div><div class="line">    Type:       Secret (a volume populated by a Secret)</div><div class="line">    SecretName: default-token-74qlr</div><div class="line">QoS Class:      BestEffort</div><div class="line">Tolerations:    &lt;none&gt;</div><div class="line">Events:</div><div class="line">  FirstSeen     LastSeen        Count   From                    SubObjectPath             Type             Reason          Message</div><div class="line">  ---------     --------        -----   ----                    -------------             -------- ------          -------</div><div class="line">  41m           41m             1       &#123;default-scheduler &#125;                              Normal           Scheduled       Successfully assigned kubernetes-bootcamp-390780338-6b9n3 to host01</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Pulled          Container image <span class="string">"docker.io/jocatalin/kubernetes-bootcamp:v1"</span> already present on machine</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Created         Created container with docker id 9308ecb7bb59; Security:[seccomp=unconfined]</div><div class="line">  41m           41m             1       &#123;kubelet host01&#125;        spec.containers&#123;kubernetes-bootcamp&#125;       Normal          Started         Started container with docker id 9308ecb7bb</div><div class="line">59</div><div class="line"></div><div class="line"><span class="comment"># 获取 pod 信息</span></div><div class="line">$&gt; <span class="built_in">export</span> POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</div><div class="line">$&gt; <span class="built_in">echo</span> Name of the Pod: <span class="variable">$POD_NAME</span></div><div class="line">Name of the Pod: kubernetes-bootcamp-390780338-6b9n3</div><div class="line"></div><div class="line"><span class="comment"># 查看 pod 日志</span></div><div class="line">$&gt; kubectl logs <span class="variable">$POD_NAME</span></div><div class="line">Kubernetes Bootcamp App Started At: 2017-06-05T03:05:08.494Z | Running On:  kubernetes-bootcamp-390780338-6b9n3</div></pre></td></tr></table></figure>
<h3 id="使用服务暴露应用"><a href="#使用服务暴露应用" class="headerlink" title="使用服务暴露应用"></a>使用服务暴露应用</h3><p>Pods 是有生命周期的，也有独立的 IP 地址，随着 Pods 的创建与销毁，一个必不可少的工作就是保证各个应用能够感知这种变化。这就要提到 Service 了，Service 是 YAML 或 JSON 定义的由 Pods 通过某种策略的逻辑组合。更重要的是，Pods 的独立 IP 需要通过 Service 暴露到网络中，有以下几种方式：</p>
<ul>
<li><code>ClusterIP</code>(默认)：只在集群内部可见的地址</li>
<li><code>NodePort</code>：可在集群外访问，需要指定端口</li>
<li><code>LoadBalancer</code>：创建一个负载均衡器，IP 是固定的</li>
<li><code>ExternalName</code>：使用任意的名字暴露服务</li>
</ul>
<p>依然是通过实例来感受一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看 pods 信息</span></div><div class="line">$&gt; kubectl get pods</div><div class="line">NAME                                  READY     STATUS    RESTARTS   AGE</div><div class="line">kubernetes-bootcamp-390780338-76skz   1/1       Running   0          6s</div><div class="line"></div><div class="line"><span class="comment"># 查看服务信息</span></div><div class="line">$&gt; kubectl get services</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</div><div class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP   47s</div><div class="line"></div><div class="line"><span class="comment"># 暴露服务</span></div><div class="line">$&gt; kubectl expose deployment/kubernetes-bootcamp --type=<span class="string">"NodePort"</span> --port 8080</div><div class="line">service <span class="string">"kubernetes-bootcamp"</span> exposed</div></pre></td></tr></table></figure>
<h3 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h3><p>当业务流量暴涨，就需要根据需要扩展应用（多几个 pods），具体的原理比较简单，我们直接来看例子：</p>
<p>TODO</p>
<h3 id="更新应用"><a href="#更新应用" class="headerlink" title="更新应用"></a>更新应用</h3><p>滚动更新可以保证 0 停机时间，其实逻辑和前面的扩展差不多，可以认为是用新版本的扩展，也直接来看例子：</p>
<p>TODO</p>
<h2 id="Hello-Minikube"><a href="#Hello-Minikube" class="headerlink" title="Hello Minikube"></a>Hello Minikube</h2><p>一个简单的教程，学习如何把本机的代码转换成 Kubernetes 可以使用的镜像</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hosted solution</p>
<p>turnkey cloud solutions</p>
<p>CentOS Version</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="external">Official Kubernetes Tutorial</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要来源于官网的教程，从基础入手，循序渐进，还有在线实验，非常友好&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="集群" scheme="http://wdxtub.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Kubernetes" scheme="http://wdxtub.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>第五十一周 - 随缘</title>
    <link href="http://wdxtub.com/2017/06/02/let-it-be/"/>
    <id>http://wdxtub.com/2017/06/02/let-it-be/</id>
    <published>2017-06-02T13:22:22.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>刀光剑影不是我门派，天空海阔自有我风采。双手一推非黑也非白，不好也不坏，没有胜又何来败。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.06.02: 完成初稿</li>
</ul>
<p>随团建拉开的端午假期的序幕在这周三戛然而止，除了国庆没有任何假期的下半年就这么猝不及防地来了。端午哪都人多，妈妈去北京参加同学聚会，老爸、发小和我就约着去南沙自驾游了一圈。主题当然就是逛吃逛吃，无奈天公不作美，一面很晒，一面有霾，于是所有的航拍照片，只有俯视角+去雾滤镜是可以看的。不过能让我的俩哥们儿（我爸和我发小）一起感受刚买的飞行眼镜，再晒再累也值得。</p>
<p>飞无人机的时候在想，如果它有自己的感受，恐怕只有在飞的时候，无人机才真正是无人机，不然只是趟在橱窗里的咸鱼而已。人也是这样，只有真正做到自己想做的事情，成为自己的时候，才是人本身，不然也就是吃喝拉撒的咸鱼而已。</p>
<p>没有人喜欢做脏活累活，但是如果脏活累活都做不好（因为一般来说这种活都比较简单），是没有机会去做其他看起来不脏不累的活的（其实只是看起来，很多时候看起来越轻松，所肩挑的担子越大，负的责任也越大）。所以那些本职工作没做好，却总觉得自己怀才不遇的同学其实很可能得一直做脏活累活。反倒是那种有些随遇而安，做什么都踏踏实实做好，还有点灵性的同学，有机会做更大的事情。</p>
<p>有的同学确实做事情踏踏实实，确实也完成了任务，但是在完成任务的过程中不懂脑筋，把工作当差事而不是当艺术，很多时候也只能成为类似小组长的角色。比如说同样是写代码，有的人的代码干净整洁井井有条，一看就能意识到个中蕴含的思考和智慧；但有的人的代码就是简单粗暴的复制粘贴，一看就是有了锤子满眼都是钉子。不是说满眼都是钉子不好，而是这种观察事物的角度本身是狭隘的，没有创新的，也就使得自己丧失了面对未知挑战的能力。</p>
<p>现实世界是复杂的，即使是建筑在 01 基础之上的软件工程，因为越来越跟现实纠缠在一起，也不得不去面对这些复杂性。我们也不得不绞尽脑汁用最优雅的方式去解决繁琐复杂的问题。今天下午给公司技术老大和算法老大做的深度学习平台的技术方案设计基本顺利通过，除了部分细节需要细化之外，老大们基本认同的我的方案，也让我放手去做，如果人不够就继续招（所以这里继续招人，想一起搞事情的一定要留意文末的招聘信息）。这其实是让我特别开心的，毕竟在这个领域现在还没有现成的解决方案，能和所有人一起在同一个起跑线上竞赛，如果还能凭借自己的努力弯道超车的话，就很有灵性了。</p>
<p>今天在处理家里的杂事儿时候真正按照自己劝别人的做了一次即：在对方情绪不好的事情，注意说话的态度，把事情往好的方向引导，不要埋怨而把事情弄得更糟。很多事情都是说起来容易做起来难，但真正做到了，其实就会发现往往关键就在于那一念之间。</p>
<p>读书和游戏都是很重要的，都是体验生活的方式，从某种角度来说，只要想象力够，这两者很多时候是一个事情，即去体验那些自己可能没有办法体验的一切。而如果能找到在这两方面都非常聊得来的伙伴，的确是非常开心的事情。</p>
<p>没有去哪有来，手中无剑心中无尘，才是我胸怀。随缘而去乘风而来，才是我胸怀。</p>
<hr>
<p>附：招聘信息</p>
<ul>
<li>能力要求：全栈 + Docker + K8S + Tensorflow + Spark</li>
<li>任务目标：搭建深度学习平台，开发深度学习算法</li>
<li>如果不甘心当个螺丝钉，为什么不来一起搞点事情呢？</li>
<li>联系方式：老读者都知道的，这里就不赘述了</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刀光剑影不是我门派，天空海阔自有我风采。双手一推非黑也非白，不好也不坏，没有胜又何来败。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="转变" scheme="http://wdxtub.com/tags/%E8%BD%AC%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之数据科学】TensorFlow 学习笔记</title>
    <link href="http://wdxtub.com/2017/05/31/tensorflow-learning-note/"/>
    <id>http://wdxtub.com/2017/05/31/tensorflow-learning-note/</id>
    <published>2017-05-31T09:05:32.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 开始更新</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>TensorFlow 是一个基于图计算的通用系统，常常被用于进行机器学习等任务。</p>
<p>TensorFlow 由<strong>张量</strong>(tensor)而得名，张量是多维的数组。一个向量是一维数组，我们称为一阶张量；一个矩阵是二维数组，我们称为二阶张量。名字中的 flow 表示计算的过程是基于图的，数据在图中流动。神经网络的训练和推断包含计算图中许多节点的矩阵计算的传播(propagation)</p>
<p>在 TensorFlow 中搞事的流程大概是：创建张量 -&gt; 添加计算操作 -&gt; 执行。很重要的一点是定义这些操作时，计算并不会立即执行，TensorFlow 在所有的操作添加完成后，会优化计算图，决定如何计算，最后才生成各种数据。正因如此，TensorFlow 中的 tensor 可以看作是一个占位符，等数据到来，然后执行计算。</p>
<p>我们来看看如何用 TensorFlow 做向量相加，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中的操作都需要在 Session 的上下文中进行，Session 本身保存计算图的信息（张量和操作）</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant([<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>])</div><div class="line">    input2 = tf.constant(<span class="number">2.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    input3 = tf.constant(<span class="number">3.0</span>, shape=[<span class="number">4</span>])</div><div class="line">    output = tf.add(tf.add(input1, input2), input3)</div><div class="line">    <span class="comment"># 具体的计算在执行这一句时进行，因为 result 的值需要计算才可以得到，前面都是在定义计算图</span></div><div class="line">    result = output.eval()</div><div class="line">    print(<span class="string">"result: "</span>, result)</div></pre></td></tr></table></figure>
<p>处理完向量，我们来看看矩阵，其实也差不多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 矩阵相加</span></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input1 = tf.constant(<span class="number">1.0</span>, shape=[<span class="number">2</span>, <span class="number">3</span>])</div><div class="line">    input2 = tf.constant(np.reshape(np.arange(<span class="number">1.0</span>, <span class="number">7.0</span>, dtype=np.float32), (<span class="number">2</span>, <span class="number">3</span>)))</div><div class="line">    output = tf.add(input1, input2)</div><div class="line">    print(output.eval())</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session():</div><div class="line">    input_features = tf.constant(np.reshape([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], (<span class="number">1</span>, <span class="number">4</span>)).astype(np.float32))</div><div class="line">    weights = tf.constant(np.random.randn(<span class="number">4</span>, <span class="number">2</span>).astype(np.float32))</div><div class="line">    output = tf.matmul(input_features, weights)</div><div class="line">    print(<span class="string">"Input:"</span>)</div><div class="line">    print(input_features.eval())</div><div class="line">    print(<span class="string">"Weights:"</span>)</div><div class="line">    print(weights.eval())</div><div class="line">    print(<span class="string">"Output:"</span>)</div><div class="line">    print(output.eval())</div></pre></td></tr></table></figure>
<p>前面我们都是用的 constant 常量，接下来我们搞一搞变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#@test &#123;"output": "ignore"&#125;</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置俩变量 total 和 weights，会不停变化</span></div><div class="line">    total = tf.Variable(tf.zeros([<span class="number">1</span>, <span class="number">2</span>]))</div><div class="line">    weights = tf.Variable(tf.random_uniform([<span class="number">1</span>,<span class="number">2</span>]))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化刚才定义的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 更新数值，但是这里并不会真的计算</span></div><div class="line">    update_weights = tf.assign(weigths, tf.random_uniform([<span class="number">1</span>, <span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</div><div class="line">    update_total = tf.assign(total, tf.add(total, weights))</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        <span class="comment"># 这里要先更新 weights 再更新 total</span></div><div class="line">        sess.run(update_weights)</div><div class="line">        sess.run(update_total)</div><div class="line">        </div><div class="line">        print(weights.eval(), total.eval())</div></pre></td></tr></table></figure>
<p>这里我们注意是先建模再计算这个流程即可。</p>
<h2 id="一个简单的神经网络"><a href="#一个简单的神经网络" class="headerlink" title="一个简单的神经网络"></a>一个简单的神经网络</h2><p>我们来构造一个非常简单的神经网络，来计算 x 和 y 这两个变量的线性回归。这个函数会为我们随机生成的带噪声的线性数据找到最合适的  $w_1$ 和 $w_2$，即满足 $y = w_2x+w_1$ 。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 设置带噪声的线性数据</span></div><div class="line">num_examples = <span class="number">50</span></div><div class="line"><span class="comment"># 这里会生成一个完全线性的数据</span></div><div class="line">X = np.array([np.linspace(<span class="number">-2</span>, <span class="number">4</span>, num_examples), np.linspace(<span class="number">-6</span>, <span class="number">6</span>, num_examples)])</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 这里给数据增加噪声</span></div><div class="line">X += np.random.randn(<span class="number">2</span>, num_examples)</div><div class="line"><span class="comment"># 数据展示</span></div><div class="line"><span class="comment"># plt.figure(figsize=(4,4))</span></div><div class="line"><span class="comment"># plt.scatter(X[0], X[1])</span></div><div class="line"><span class="comment"># plt.show</span></div><div class="line"></div><div class="line"><span class="comment"># 我们的目标就是通过学习，找到一条拟合曲线，去还原最初的线性数据</span></div><div class="line"><span class="comment"># 把数据分离成 x 和 y</span></div><div class="line">x, y = X</div><div class="line"><span class="comment"># 添加固定为 1 的 bias</span></div><div class="line">x_with_bias = np.array([(<span class="number">1.</span>, a) <span class="keyword">for</span> a <span class="keyword">in</span> x]).astype(np.float32)</div><div class="line"></div><div class="line"><span class="comment"># 用来记录每次迭代的 loss，之后用于展示结果</span></div><div class="line">losses = []</div><div class="line"><span class="comment"># 迭代次数</span></div><div class="line">training_steps = <span class="number">50</span></div><div class="line"><span class="comment"># 学习率，也叫做步长，表示我们在梯度下降时每次迭代所前进的长度，过大则学不到准确的值，过小则训练太慢</span></div><div class="line">learning_rate = <span class="number">0.002</span></div><div class="line"></div><div class="line"><span class="comment"># TensorFlow 中所有的代码都需要在 session 中</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># 设置所有的张量，变量和操作</span></div><div class="line">    <span class="comment"># 输入层是 x 值和 bias 节点</span></div><div class="line">    input = tf.constant(x_with_bias)</div><div class="line">    <span class="comment"># target 是 y 的值，需要被调整成正确的尺寸（就是转置一下）</span></div><div class="line">    target = tf.constant(np.transpose([y]).astype(np.float32))</div><div class="line">    <span class="comment"># weights 是变量，每次循环都会变，这里直接随机初始化（高斯分布，均值 0，标准差 0.1）</span></div><div class="line">    weights = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">1</span>], <span class="number">0</span>, <span class="number">0.1</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># 初始化所有的变量</span></div><div class="line">    tf.global_variables_initializer().run()</div><div class="line">    </div><div class="line">    <span class="comment"># 设置循环中所要做的全部操作</span></div><div class="line">    <span class="comment"># 对于所有的 x，根据现有的 weights 来产生对应的 y 值，也就是计算 y = w2 * x + w1 * bias</span></div><div class="line">    yhat = tf.matmul(input, weights)</div><div class="line">    <span class="comment"># 计算误差，也就是预计的 y 和真实的 y 的区别</span></div><div class="line">    yerror = tf.subtract(yhat, target)</div><div class="line">    <span class="comment"># 我们想要最小化 L2 损失，是误差的平方，会惩罚大误差，放过小误差</span></div><div class="line">    loss = tf.nn.l2_loss(yerror)</div><div class="line">    <span class="comment"># 上面的 loss 函数相当于</span></div><div class="line">    <span class="comment"># loss = 0.5 * tf.reduce_sum(tf.multiply(yerror, yerror))</span></div><div class="line">    </div><div class="line">    <span class="comment"># 执行梯度下降</span></div><div class="line">    <span class="comment"># 更新 weights，比如 weights += grads * learning_rate</span></div><div class="line">    <span class="comment"># 使用偏微分更新 weights</span></div><div class="line">    update_weights = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)</div><div class="line">    <span class="comment"># 上面的梯度下降相当于</span></div><div class="line">    <span class="comment"># gradient = tf.reduce_sum(tf.transpose(tf.multiply(input, yerror)), 1, keep_dims=True)</span></div><div class="line">    <span class="comment"># update_weights = tf.assign_sub(weights, learning_rate * gradient)</span></div><div class="line">    </div><div class="line">    <span class="comment"># 现在我们定义了所有的张量，也初始化了所有操作（每次执行梯度下降优化）</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(training_steps):</div><div class="line">        <span class="comment"># 重复跑，更新变量</span></div><div class="line">        update_weights.run()</div><div class="line">        <span class="comment"># 如果没有用 tf.train.GradientDescentOptimizer，就要用下面的方式</span></div><div class="line">        <span class="comment"># sess.run(update_weights)</span></div><div class="line">        </div><div class="line">        <span class="comment"># 记录每次迭代的 loss</span></div><div class="line">        losses.append(loss.eval())</div><div class="line">    </div><div class="line">    <span class="comment"># 训练结束</span></div><div class="line">    betas = weights.eval()</div><div class="line">    yhat = yhat.eval()</div><div class="line"></div><div class="line"><span class="comment"># 展示训练趋势</span></div><div class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">plt.subplots_adjust(wspace=<span class="number">.3</span>)</div><div class="line">fig.set_size_inches(<span class="number">10</span>, <span class="number">4</span>)</div><div class="line">ax1.scatter(x, y, alpha=<span class="number">.7</span>)</div><div class="line">ax1.scatter(x, np.transpose(yhat)[<span class="number">0</span>], c=<span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">line_x_range = (<span class="number">-4</span>, <span class="number">6</span>)</div><div class="line">ax1.plot(line_x_range, [betas[<span class="number">0</span>] + a * betas[<span class="number">1</span>] <span class="keyword">for</span> a <span class="keyword">in</span> line_x_range], <span class="string">"g"</span>, alpha=<span class="number">.6</span>)</div><div class="line">ax2.plot(range(<span class="number">0</span>, training_steps), losses)</div><div class="line">ax2.set_ylabel(<span class="string">"Loss"</span>)</div><div class="line">ax2.set_xlabel(<span class="string">"Training steps"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="从零开始上手-MNIST-数据集"><a href="#从零开始上手-MNIST-数据集" class="headerlink" title="从零开始上手 MNIST 数据集"></a>从零开始上手 MNIST 数据集</h2><p>这是 Tensorflow 官方 Docker 镜像中的最后一篇教程，主要介绍如何利用 tf 完成手写数字的识别，这里我把 jupyter 的代码稍加改动（并加了些注释），方便大家在本地使用。</p>
<p>注：详细的解释都在注释里了，这里就不再赘述。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> gzip, binascii, struct, numpy</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> six.moves.urllib.request <span class="keyword">import</span> urlretrieve</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># 这里需要翻墙，不然下载巨慢</span></div><div class="line">SOURCE_URL = <span class="string">'http://yann.lecun.com/exdb/mnist/'</span></div><div class="line">WORK_DIRECTORY = <span class="string">"./mnist-data"</span></div><div class="line"></div><div class="line"><span class="comment"># 如果下载好了，那么就不会再次下载</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybe_download</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">"""A helper to download the data files if not present."""</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(WORK_DIRECTORY):</div><div class="line">        os.mkdir(WORK_DIRECTORY)</div><div class="line">    filepath = os.path.join(WORK_DIRECTORY, filename)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath):</div><div class="line">        filepath, _ = urlretrieve(SOURCE_URL + filename, filepath)</div><div class="line">        statinfo = os.stat(filepath)</div><div class="line">        print(<span class="string">'Successfully downloaded'</span>, filename, statinfo.st_size, <span class="string">'bytes.'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Already downloaded'</span>, filename)</div><div class="line">    <span class="keyword">return</span> filepath</div><div class="line"></div><div class="line"><span class="comment"># 这里把所有的训练数据都搞下来</span></div><div class="line">train_data_filename = maybe_download(<span class="string">'train-images-idx3-ubyte.gz'</span>)</div><div class="line">train_labels_filename = maybe_download(<span class="string">'train-labels-idx1-ubyte.gz'</span>)</div><div class="line">test_data_filename = maybe_download(<span class="string">'t10k-images-idx3-ubyte.gz'</span>)</div><div class="line">test_labels_filename = maybe_download(<span class="string">'t10k-labels-idx1-ubyte.gz'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 如果遇到 MacOS 的 Python as a framework 的问题，参考</span></div><div class="line"><span class="comment"># https://stackoverflow.com/questions/29433824/unable-to-import-matplotlib-pyplot-as-plt-in-virtualenv</span></div><div class="line"><span class="comment"># 这里我们先看看数据集里有什么，只是一个展示，并不会对图片进行预处理</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sanity_check</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_data_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'image count'</span>, <span class="string">'rows'</span>, <span class="string">'columns'</span>]:</div><div class="line">            <span class="comment"># struct.unpack reads the binary data provided by f.read.</span></div><div class="line">            <span class="comment"># The format string '&gt;i' decodes a big-endian integer, which</span></div><div class="line">            <span class="comment"># is the encoding of the data.</span></div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        <span class="comment"># Read the first 28x28 set of pixel values. </span></div><div class="line">        <span class="comment"># Each pixel is one byte, [0, 255], a uint8.</span></div><div class="line">        buf = f.read(<span class="number">28</span> * <span class="number">28</span>)</div><div class="line">        image = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    </div><div class="line">        <span class="comment"># Print the first few values of image.</span></div><div class="line">        print(<span class="string">'First 10 pixels:'</span>, image[:<span class="number">10</span>])</div><div class="line"></div><div class="line">        <span class="comment"># We'll show the image and its pixel value histogram side-by-side.</span></div><div class="line">        <span class="comment"># 输出原始图片和直方图，来看看具体的样子</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># To interpret the values as a 28x28 image, we need to reshape</span></div><div class="line">        <span class="comment"># the numpy array, which is one dimensional.</span></div><div class="line">        ax1.imshow(image.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(image, bins=<span class="number">20</span>, range=[<span class="number">0</span>,<span class="number">255</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里是把 [0, 255] 映射到 [-0.5, 0.5] 之后的展示</span></div><div class="line">        <span class="comment"># Let's convert the uint8 image to 32 bit floats and rescale </span></div><div class="line">        <span class="comment"># the values to be centered around 0, between [-0.5, 0.5]. </span></div><div class="line">        <span class="comment"># </span></div><div class="line">        <span class="comment"># We again plot the image and histogram to check that we </span></div><div class="line">        <span class="comment"># haven't mangled the data.</span></div><div class="line">        scaled = image.astype(numpy.float32)</div><div class="line">        scaled = (scaled - (<span class="number">255</span> / <span class="number">2.0</span>)) / <span class="number">255</span></div><div class="line">        _, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        ax1.imshow(scaled.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">        ax2.hist(scaled, bins=<span class="number">20</span>, range=[<span class="number">-0.5</span>, <span class="number">0.5</span>])</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># 这里读取 Label，也是一个测试而已</span></div><div class="line">    <span class="keyword">with</span> gzip.open(test_labels_filename) <span class="keyword">as</span> f:</div><div class="line">        <span class="comment"># Print the header fields.</span></div><div class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> [<span class="string">'magic number'</span>, <span class="string">'label count'</span>]:</div><div class="line">            print(field, struct.unpack(<span class="string">'&gt;i'</span>, f.read(<span class="number">4</span>))[<span class="number">0</span>])</div><div class="line"></div><div class="line">        print(<span class="string">'First label:'</span>, struct.unpack(<span class="string">'B'</span>, f.read(<span class="number">1</span>))[<span class="number">0</span>]) </div><div class="line"></div><div class="line"><span class="comment"># 简单显示一下，然后进行之后的步骤</span></div><div class="line">sanity_check()</div><div class="line"></div><div class="line"><span class="comment"># 处理图片数据</span></div><div class="line">IMAGE_SIZE = <span class="number">28</span></div><div class="line">PIXEL_DEPTH = <span class="number">255</span></div><div class="line"></div><div class="line"><span class="comment"># 这个函数会提取并处理数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_data</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the images into a 4D tensor [image index, y, x, channels].</span></div><div class="line">  </div><div class="line">    For MNIST data, the number of channels is always 1.</div><div class="line"></div><div class="line">    Values are rescaled from [0, 255] down to [-0.5, 0.5].</div><div class="line">    """</div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and dimensions; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">16</span>)</div><div class="line"></div><div class="line">        buf = bytestream.read(IMAGE_SIZE * IMAGE_SIZE * num_images)</div><div class="line">        data = numpy.frombuffer(buf, dtype=numpy.uint8).astype(numpy.float32)</div><div class="line">        data = (data - (PIXEL_DEPTH / <span class="number">2.0</span>)) / PIXEL_DEPTH</div><div class="line">        data = data.reshape(num_images, IMAGE_SIZE, IMAGE_SIZE, <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> data</div><div class="line"></div><div class="line">train_data = extract_data(train_data_filename, <span class="number">60000</span>)</div><div class="line">test_data = extract_data(test_data_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这里把处理后的输出展示下</span></div><div class="line">print(<span class="string">'Training data shape'</span>, train_data.shape)</div><div class="line">_, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">ax1.imshow(train_data[<span class="number">0</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">ax2.imshow(train_data[<span class="number">1</span>].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=plt.cm.Greys)</div><div class="line">plt.show()</div><div class="line"></div><div class="line"><span class="comment"># 接下来处理标签，我们需要把类别处理成向量，如果是第二类，那么对应 [0,1,0,...,0]，即第二个位置为 1</span></div><div class="line">NUM_LABELS = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_labels</span><span class="params">(filename, num_images)</span>:</span></div><div class="line">    <span class="string">"""Extract the labels into a 1-hot matrix [image index, label index]."""</span></div><div class="line">    print(<span class="string">'Extracting'</span>, filename)</div><div class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> bytestream:</div><div class="line">        <span class="comment"># Skip the magic number and count; we know these values.</span></div><div class="line">        bytestream.read(<span class="number">8</span>)</div><div class="line">        buf = bytestream.read(<span class="number">1</span> * num_images)</div><div class="line">        labels = numpy.frombuffer(buf, dtype=numpy.uint8)</div><div class="line">    <span class="comment"># Convert to dense 1-hot representation.</span></div><div class="line">    <span class="keyword">return</span> (numpy.arange(NUM_LABELS) == labels[:, <span class="keyword">None</span>]).astype(numpy.float32)</div><div class="line"></div><div class="line">train_labels = extract_labels(train_labels_filename, <span class="number">60000</span>)</div><div class="line">test_labels = extract_labels(test_labels_filename, <span class="number">10000</span>)</div><div class="line"></div><div class="line"><span class="comment"># 同样测试一下数据</span></div><div class="line">print(<span class="string">'Training labels shape'</span>, train_labels.shape)</div><div class="line">print(<span class="string">'First label vector'</span>, train_labels[<span class="number">0</span>])</div><div class="line">print(<span class="string">'Second label vector'</span>, train_labels[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 这里我们把数据分成训练、测试和验证集</span></div><div class="line">VALIDATION_SIZE = <span class="number">5000</span></div><div class="line"></div><div class="line">validation_data = train_data[:VALIDATION_SIZE, :, :, :]</div><div class="line">validation_labels = train_labels[:VALIDATION_SIZE]</div><div class="line">train_data = train_data[VALIDATION_SIZE:, :, :, :]</div><div class="line">train_labels = train_labels[VALIDATION_SIZE:]</div><div class="line"></div><div class="line">train_size = train_labels.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(<span class="string">'Validation shape'</span>, validation_data.shape)</div><div class="line">print(<span class="string">'Train size'</span>, train_size)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 这里开始定义模型</span></div><div class="line"><span class="comment"># 从原始输入开始，进行卷积(convolution)和池化(max pooling)处理，在全连接层之前会用 ReLU </span></div><div class="line"><span class="comment"># 作为激活函数，最后用 softmax 来处理输出，把类别信息转化成概率，训练的时候使用 Dropout</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># 准备模型可以分三步</span></div><div class="line"><span class="comment"># 1. 定义变量，来保存我们要训练的权重 weights</span></div><div class="line"><span class="comment"># 2. 定义模型的图结构</span></div><div class="line"><span class="comment"># 3. 把模型的图分别用于训练、测试和验证（复制几份）</span></div><div class="line"></div><div class="line"><span class="comment"># 先处理好变量</span></div><div class="line"><span class="comment"># 从效率的角度考虑，我们会把样本分组，这里是一个组的样本数量</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"><span class="comment"># 因为是灰度图，所以只有一个通道 channel</span></div><div class="line">NUM_CHANNELS = <span class="number">1</span></div><div class="line"><span class="comment"># 固定随机种子，保证每次的结果一致（不然没办法验证数据和模型）</span></div><div class="line">SEED = <span class="number">42</span></div><div class="line"></div><div class="line"><span class="comment"># 我们在这里把训练数据和类别标签『喂』给模型，不过这里只是一个占位符(placeholder)</span></div><div class="line"><span class="comment"># 真正训练的时候，这些节点在每一步会获取批量数据</span></div><div class="line">train_data_node = tf.placeholder(</div><div class="line">  tf.float32,</div><div class="line">  shape=(BATCH_SIZE, IMAGE_SIZE, IMAGE_SIZE, NUM_CHANNELS))</div><div class="line">train_labels_node = tf.placeholder(tf.float32,</div><div class="line">                                   shape=(BATCH_SIZE, NUM_LABELS))</div><div class="line"></div><div class="line"><span class="comment"># 对于验证和测试数据，直接保存到一个常量节点里即可（不存在训练的过程，不需要是变量）</span></div><div class="line">validation_data_node = tf.constant(validation_data)</div><div class="line">test_data_node = tf.constant(test_data)</div><div class="line"></div><div class="line"><span class="comment"># 下面的变量保存着所有的需要训练的权重。后面的参数定义了这些变量的初始化条件</span></div><div class="line"><span class="comment"># 用高斯分布初始化卷积的 weights</span></div><div class="line">conv1_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, NUM_CHANNELS, <span class="number">32</span>],  <span class="comment"># 5x5 filter, depth 32.</span></div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 初始的 bias 为 0</span></div><div class="line">conv1_biases = tf.Variable(tf.zeros([<span class="number">32</span>]))</div><div class="line"><span class="comment"># 第二层的卷积权重，32 个输入（对应上面的 32），然后下面是 64 维</span></div><div class="line">conv2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line"><span class="comment"># 同理，bias 也是 64 维，但是这里用 0.1</span></div><div class="line">conv2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">64</span>]))</div><div class="line"><span class="comment"># 然后是一个全连接的网络，共 512 维，为什么呢，因为我们有卷积和池化的存在，所以是 32*64/4</span></div><div class="line"><span class="comment"># (?这里我也不是很确定)</span></div><div class="line">fc1_weights = tf.Variable(  <span class="comment"># fully connected, depth 512.</span></div><div class="line">  tf.truncated_normal([IMAGE_SIZE // <span class="number">4</span> * IMAGE_SIZE // <span class="number">4</span> * <span class="number">64</span>, <span class="number">512</span>],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc1_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[<span class="number">512</span>]))</div><div class="line">fc2_weights = tf.Variable(</div><div class="line">  tf.truncated_normal([<span class="number">512</span>, NUM_LABELS],</div><div class="line">                      stddev=<span class="number">0.1</span>,</div><div class="line">                      seed=SEED))</div><div class="line">fc2_biases = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[NUM_LABELS]))</div><div class="line"></div><div class="line">print(<span class="string">'变量设置完毕'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义好了各种需要训练的变量，我们可以在 TensorFlow 图中把这些变量连起来了</span></div><div class="line"><span class="comment"># 这里我们用一个函数来返回我们需要的 tf graph，这里有一个参数来控制是训练还是其他</span></div><div class="line"><span class="comment"># 如果是训练，我们需要使用 dropout</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(data, train=False)</span>:</span></div><div class="line">    <span class="string">"""模型定义"""</span></div><div class="line">    <span class="comment"># 2D 卷积，使用相同 padding，意思是输入的 feature 大小和输出的一致，</span></div><div class="line">    <span class="comment"># strides 是一个四维数组 [image index, y, x, depth]</span></div><div class="line">    conv = tf.nn.conv2d(data,</div><div class="line">                        conv1_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 对卷积和偏置做 ReLU 操作</span></div><div class="line">    <span class="comment"># Bias and rectified linear non-linearity.</span></div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv1_biases))</div><div class="line"></div><div class="line">    <span class="comment"># 池化，这里我们的 pooling window 是 2，每个 stride 是 2</span></div><div class="line">    <span class="comment"># Max pooling. The kernel size spec ksize also follows the layout of</span></div><div class="line">    <span class="comment"># the data. Here we have a pooling window of 2, and a stride of 2.</span></div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line">    conv = tf.nn.conv2d(pool,</div><div class="line">                        conv2_weights,</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">                        padding=<span class="string">'SAME'</span>)</div><div class="line">    relu = tf.nn.relu(tf.nn.bias_add(conv, conv2_biases))</div><div class="line">    pool = tf.nn.max_pool(relu,</div><div class="line">                          ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                          padding=<span class="string">'SAME'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 把 feature map 转为 2D 矩阵，并传给全连接网络</span></div><div class="line">    pool_shape = pool.get_shape().as_list()</div><div class="line">    reshape = tf.reshape(</div><div class="line">        pool,</div><div class="line">        [pool_shape[<span class="number">0</span>], pool_shape[<span class="number">1</span>] * pool_shape[<span class="number">2</span>] * pool_shape[<span class="number">3</span>]])</div><div class="line">  </div><div class="line">    <span class="comment"># Fully connected layer. Note that the '+' operation automatically</span></div><div class="line">    <span class="comment"># broadcasts the biases.</span></div><div class="line">    hidden = tf.nn.relu(tf.matmul(reshape, fc1_weights) + fc1_biases)</div><div class="line"></div><div class="line">    <span class="comment"># Add a 50% dropout during training only. Dropout also scales</span></div><div class="line">    <span class="comment"># activations such that no rescaling is needed at evaluation time.</span></div><div class="line">    <span class="keyword">if</span> train:</div><div class="line">        hidden = tf.nn.dropout(hidden, <span class="number">0.5</span>, seed=SEED)</div><div class="line">    <span class="keyword">return</span> tf.matmul(hidden, fc2_weights) + fc2_biases</div><div class="line"></div><div class="line"><span class="comment"># 定义了图的基本结构，我们就可以分别为 训练、测试和验证来提取模型了（也会根据不同的类型做一些自定义）</span></div><div class="line"><span class="comment"># train_prediction 保存训练的图，使用 cross-entropy loss 和 weight regularization</span></div><div class="line"><span class="comment"># 我们也会在训练的过程中调整学习率（通过 exponential_decay 操作来完成，会使用 MomentumOptimizer）</span></div><div class="line"></div><div class="line"><span class="comment"># 验证和测试的图比较简单，我们只需要使用验证和测试集作为输入，用 softmax 分类器作为输出</span></div><div class="line"></div><div class="line"><span class="comment"># 训练的计算</span></div><div class="line"><span class="comment"># Training computation: logits + cross-entropy loss.</span></div><div class="line">logits = model(train_data_node, <span class="keyword">True</span>)</div><div class="line">loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(</div><div class="line">  labels=train_labels_node, logits=logits))</div><div class="line"></div><div class="line"><span class="comment"># L2 正则化</span></div><div class="line"><span class="comment"># L2 regularization for the fully connected parameters.</span></div><div class="line">regularizers = (tf.nn.l2_loss(fc1_weights) + tf.nn.l2_loss(fc1_biases) +</div><div class="line">                tf.nn.l2_loss(fc2_weights) + tf.nn.l2_loss(fc2_biases))</div><div class="line"><span class="comment"># Add the regularization term to the loss.</span></div><div class="line">loss += <span class="number">5e-4</span> * regularizers</div><div class="line"></div><div class="line"><span class="comment"># Optimizer: set up a variable that's incremented once per batch and</span></div><div class="line"><span class="comment"># controls the learning rate decay.</span></div><div class="line">batch = tf.Variable(<span class="number">0</span>)</div><div class="line"><span class="comment"># Decay once per epoch, using an exponential schedule starting at 0.01.</span></div><div class="line">learning_rate = tf.train.exponential_decay(</div><div class="line">  <span class="number">0.01</span>,                <span class="comment"># Base learning rate.</span></div><div class="line">  batch * BATCH_SIZE,  <span class="comment"># Current index into the dataset.</span></div><div class="line">  train_size,          <span class="comment"># Decay step.</span></div><div class="line">  <span class="number">0.95</span>,                <span class="comment"># Decay rate.</span></div><div class="line">  staircase=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># Use simple momentum for the optimization.</span></div><div class="line">optimizer = tf.train.MomentumOptimizer(learning_rate,</div><div class="line">                                       <span class="number">0.9</span>).minimize(loss,</div><div class="line">                                                     global_step=batch)</div><div class="line"></div><div class="line"><span class="comment"># Predictions for the minibatch, validation set and test set.</span></div><div class="line">train_prediction = tf.nn.softmax(logits)</div><div class="line"><span class="comment"># We'll compute them only once in a while by calling their &#123;eval()&#125; method.</span></div><div class="line">validation_prediction = tf.nn.softmax(model(validation_data_node))</div><div class="line">test_prediction = tf.nn.softmax(model(test_data_node))</div><div class="line"></div><div class="line"><span class="comment"># 准备好了训练、测试和验证的模型之后，我们就可以来真正执行训练了。</span></div><div class="line"><span class="comment"># 所有的操作都需要在 session 中，在 python 中像是</span></div><div class="line"><span class="comment"># with tf.Session() as s:</span></div><div class="line"><span class="comment"># ...training / test / evaluation loop...</span></div><div class="line"></div><div class="line"><span class="comment"># 但是我们这里想要保持 session 方便我们去探索训练的过程，使用 InteractiveSession</span></div><div class="line"></div><div class="line"><span class="comment"># 我们先创建一个 session 并初始化我们刚才定义的变量</span></div><div class="line">s = tf.InteractiveSession()</div><div class="line"></div><div class="line"><span class="comment"># Use our newly created session as the default for subsequent operations.</span></div><div class="line">s.as_default()</div><div class="line"></div><div class="line"><span class="comment"># 初始化刚才定义的变量</span></div><div class="line">tf.global_variables_initializer().run()</div><div class="line"></div><div class="line"><span class="comment"># 我们现在可以开始训练了，这里我们用 minibatch 的方法（而不是一次只训练一个样本）</span></div><div class="line">BATCH_SIZE = <span class="number">60</span></div><div class="line"></div><div class="line"><span class="comment"># 提取第一个 batch 的数据和标签</span></div><div class="line"><span class="comment"># Grab the first BATCH_SIZE examples and labels.</span></div><div class="line">batch_data = train_data[:BATCH_SIZE, :, :, :]</div><div class="line">batch_labels = train_labels[:BATCH_SIZE]</div><div class="line"></div><div class="line"><span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line"><span class="comment"># node in the graph it should be fed to.</span></div><div class="line">feed_dict = &#123;train_data_node: batch_data,</div><div class="line">             train_labels_node: batch_labels&#125;</div><div class="line"></div><div class="line"><span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">_, l, lr, predictions = s.run(</div><div class="line">  [optimizer, loss, learning_rate, train_prediction],</div><div class="line">  feed_dict=feed_dict)</div><div class="line"></div><div class="line">print(predictions[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="comment"># The highest probability in the first entry.</span></div><div class="line">print(<span class="string">'First prediction'</span>, numpy.argmax(predictions[<span class="number">0</span>]))</div><div class="line"></div><div class="line"><span class="comment"># But, predictions is actually a list of BATCH_SIZE probability vectors.</span></div><div class="line">print(predictions.shape)</div><div class="line"></div><div class="line"><span class="comment"># So, we'll take the highest probability for each vector.</span></div><div class="line">print(<span class="string">'All predictions'</span>, numpy.argmax(predictions, <span class="number">1</span>))</div><div class="line"></div><div class="line">print(<span class="string">'Batch labels'</span>, numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"></div><div class="line">correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line">total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">print(float(correct) / float(total))</div><div class="line"></div><div class="line">confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(batch_labels, <span class="number">1</span>))</div><div class="line"><span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">  confusions[predicted, actual] += <span class="number">1</span></div><div class="line"></div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_rate</span><span class="params">(predictions, labels)</span>:</span></div><div class="line">    <span class="string">"""Return the error rate and confusions."""</span></div><div class="line">    correct = numpy.sum(numpy.argmax(predictions, <span class="number">1</span>) == numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    total = predictions.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">    error = <span class="number">100.0</span> - (<span class="number">100</span> * float(correct) / float(total))</div><div class="line"></div><div class="line">    confusions = numpy.zeros([<span class="number">10</span>, <span class="number">10</span>], numpy.float32)</div><div class="line">    bundled = zip(numpy.argmax(predictions, <span class="number">1</span>), numpy.argmax(labels, <span class="number">1</span>))</div><div class="line">    <span class="keyword">for</span> predicted, actual <span class="keyword">in</span> bundled:</div><div class="line">        confusions[predicted, actual] += <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> error, confusions</div><div class="line"></div><div class="line"><span class="comment"># 这里训练 n 轮，每轮都是 minibatch</span></div><div class="line">train_round = <span class="number">3</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_round):</div><div class="line">    print(<span class="string">"Training Round "</span>, i+<span class="number">1</span> )</div><div class="line">    <span class="comment"># Train over the first 1/4th of our training set.</span></div><div class="line">    steps = train_size // BATCH_SIZE</div><div class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps):</div><div class="line">        <span class="comment"># Compute the offset of the current minibatch in the data.</span></div><div class="line">        <span class="comment"># Note that we could use better randomization across epochs.</span></div><div class="line">        offset = (step * BATCH_SIZE) % (train_size - BATCH_SIZE)</div><div class="line">        batch_data = train_data[offset:(offset + BATCH_SIZE), :, :, :]</div><div class="line">        batch_labels = train_labels[offset:(offset + BATCH_SIZE)]</div><div class="line">        <span class="comment"># This dictionary maps the batch data (as a numpy array) to the</span></div><div class="line">        <span class="comment"># node in the graph it should be fed to.</span></div><div class="line">        feed_dict = &#123;train_data_node: batch_data,</div><div class="line">                    train_labels_node: batch_labels&#125;</div><div class="line">        <span class="comment"># Run the graph and fetch some of the nodes.</span></div><div class="line">        _, l, lr, predictions = s.run(</div><div class="line">        [optimizer, loss, learning_rate, train_prediction],</div><div class="line">        feed_dict=feed_dict)</div><div class="line">        </div><div class="line">        <span class="comment"># Print out the loss periodically.</span></div><div class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            error, _ = error_rate(predictions, batch_labels)</div><div class="line">            print(<span class="string">'Step %d of %d'</span> % (step, steps))</div><div class="line">            print(<span class="string">'Mini-batch loss: %.5f Error: %.5f Learning rate: %.5f'</span> % (l, error, lr))</div><div class="line">            print(<span class="string">'Validation error: %.1f%%'</span> % error_rate(</div><div class="line">                validation_prediction.eval(), validation_labels)[<span class="number">0</span>])</div><div class="line"></div><div class="line">test_error, confusions = error_rate(test_prediction.eval(), test_labels)</div><div class="line">print(<span class="string">'Test error: %.1f%%'</span> % test_error)</div><div class="line"></div><div class="line">plt.xlabel(<span class="string">'Actual'</span>)</div><div class="line">plt.ylabel(<span class="string">'Predicted'</span>)</div><div class="line">plt.grid(<span class="keyword">False</span>)</div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.yticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.imshow(confusions, cmap=plt.cm.jet, interpolation=<span class="string">'nearest'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, cas <span class="keyword">in</span> enumerate(confusions):</div><div class="line">    <span class="keyword">for</span> j, count <span class="keyword">in</span> enumerate(cas):</div><div class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</div><div class="line">            xoff = <span class="number">.07</span> * len(str(count))</div><div class="line">            plt.text(j-xoff, i+<span class="number">.2</span>, int(count), fontsize=<span class="number">9</span>, color=<span class="string">'white'</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">plt.xticks(numpy.arange(NUM_LABELS))</div><div class="line">plt.hist(numpy.argmax(test_labels, <span class="number">1</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="官方文档阅读笔记"><a href="#官方文档阅读笔记" class="headerlink" title="官方文档阅读笔记"></a>官方文档阅读笔记</h2><p>使用 TensorFlow，你必须明白 TensorFlow</p>
<ul>
<li>使用<strong>图</strong>(graph)来表示计算任务</li>
<li>在被称之为<strong>会话</strong>(Session)的<strong>上下文</strong>(context)中执行图</li>
<li>使用 tensor 表示数据</li>
<li>通过<strong>变量</strong>(Variable)维护状态</li>
<li>使用 feed 和 fetch 可以为<strong>任意的操作</strong>(arbitrary operation)赋值或者从其中获取数据</li>
</ul>
<p>TensorFlow 是一个编程系统，使用图来表示计算任务。图中的节点被称之为 op (operation 的缩写)。一个 op 获得 0 个或多个 Tensor，执行计算，产生 0 个或多个 Tensor。每个 Tensor 是一个类型化的多维数组。例如，你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是 <code>[batch, height, width, channels]</code>。</p>
<p>一个 TensorFlow 图描述了计算的过程。为了进行计算，图必须在<strong>会话</strong>里被启动。<strong>会话</strong>将图的 op 分发到诸如 CPU 或 GPU 之类的设备上，同时提供执行 op 的方法。这些方法执行后，将产生的 tensor 返回。在 Python 语言中, 返回的 tensor 是 numpy ndarray 对象；在 C 和 C++ 语言中，返回的 tensor 是 <code>tensorflow::Tensor</code> 实例。</p>
<ul>
<li>计算图<ul>
<li>TensorFlow 程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，op 的执行步骤被描述成一个图。在执行阶段，使用会话执行执行图中的 op。例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练 op。</li>
<li>TensorFlow 支持 C, C++, Python 编程语言。目前，TensorFlow 的 Python 库更加易用，它提供了大量的辅助函数来简化构建图的工作，这些函数尚未被 C 和 C++ 库支持.</li>
<li>三种语言的会话库 (session libraries) 是一致的。</li>
</ul>
</li>
<li>构建图<ul>
<li>构建图的第一步，是创建源 op (source op)。源 op 不需要任何输入，例如<strong>常量</strong>(Constant)。源 op 的输出被传递给其它 op 做运算</li>
<li>Python 库中，op 构造器的返回值代表被构造出的 op 的输出，这些返回值可以传递给其它 op 构造器作为输入</li>
<li>TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了</li>
</ul>
</li>
</ul>
<p>在实现上，TensorFlow 将图形定义转换成分布式执行的操作，以充分利用可用的计算资源(如 CPU 或 GPU). 一般你不需要显式指定使用 CPU 还是 GPU，TensorFlow 能自动检测。如果检测到 GPU，TensorFlow 会尽可能地利用找到的第一个 GPU 来执行操作。</p>
<p>如果机器上有超过一个可用的 GPU，除第一个外的其它 GPU 默认是不参与计算的。为了让 TensorFlow 使用这些 GPU，你必须将 op 明确指派给它们执行。<code>with...Device</code> 语句用来指派特定的 CPU 或 GPU 执行操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">  <span class="keyword">with</span> tf.device(<span class="string">"/gpu:1"</span>):</div><div class="line">    matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</div><div class="line">    matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</div><div class="line">    product = tf.matmul(matrix1, matrix2)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>设备用字符串进行标识。目前支持的设备包括:</p>
<ul>
<li>“/cpu:0”: 机器的 CPU</li>
<li>“/gpu:0”: 机器的第一个 GPU，如果有的话</li>
<li>“/gpu:1”: 机器的第二个 GPU，以此类推</li>
</ul>
<p>具体可见 <a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/how_tos/using_gpu.html" target="_blank" rel="external">使用 GPUs</a></p>
<p>文档的其他部分涉及到具体的算法细节，这里不再深究。</p>
<h2 id="GPU-相关"><a href="#GPU-相关" class="headerlink" title="GPU 相关"></a>GPU 相关</h2><ul>
<li>最合适测试 CUDA 的代码是使用 <code>log_device_placement</code> 参数<ul>
<li><code>sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))</code></li>
<li><code>print sess.run(c)</code></li>
<li>观察日志输出是否有 gpu0, gpu1</li>
</ul>
</li>
<li>检测 GPU 的使用率 <code>nvidia-smi -q -g 0 -d UTILIZATION -1</code></li>
<li><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Nvidia Docker</a><ul>
<li>TODO 需要看如何配置 docker 所能分配的 gpu</li>
</ul>
</li>
<li>tensorflow 在训练时默认占用所有 GPU 的显存，配置的方式有<ul>
<li>构造 <code>tf.Session()</code> 时配置参数（这里是按照百分比来选择），如<ul>
<li><code>gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.333)</code></li>
<li><code>sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</code></li>
<li><code>per_process_gpu_memory_fraction</code> 指定每个 GPU 进程中使用显存的上限，但只能作用于所有 GPU，不能根据不同 GPU 单独配置</li>
</ul>
</li>
<li>设置显存根据需求增长<ul>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.allow_growth=True</code></li>
<li><code>sess = tf.Session(config=config)</code></li>
</ul>
</li>
<li>在执行训练脚本前使用 <code>export CUDA_VISIBLE_DEVICES=1</code> 来限制可见的 GPU 数目，如果是 python 脚本，可以用 <code>CUDA_VISIBLE_DEVICES=1 python my_script.py</code>，如果想用两个卡，则是 <code>CUDA_VISIBLE_DEVICES=0,1</code>，如果禁用 GPU，则是 <code>CUDA_VISIBLE_DEVICES=&quot;&quot;</code><ul>
<li>可以参考 <a href="https://stackoverflow.com/questions/34775522/tensorflow-mutiple-sessions-with-mutiple-gpus" target="_blank" rel="external">Tensorflow multiple sessions with multiple GPUs</a></li>
</ul>
</li>
<li>也可以在 Python 代码中进行设置<ul>
<li><code>import os</code></li>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;</code></li>
</ul>
</li>
<li>如果需要同时限制显存大小，也按需增长，那么可以这样<ul>
<li><code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0&#39;</code> 指定第一块 GPU 可用</li>
<li><code>config = tf.ConfigProto()</code></li>
<li><code>config.gpu_options.per_process_gpu_memory_fraction = 0.5</code> 最多只能占用指定 gpu 50% 显存</li>
<li><code>config.gpu_options.allow_growth = True</code> 程序按需申请内存</li>
<li><code>sess = tf.Session(config = config)</code></li>
</ul>
</li>
<li>需要注意的是，虽然代码或配置层面设置了对显存占用百分比阈值，但实际中如果达到了，程序有需要的话还是会突破的，以上的显存限制仅仅为了跑小数据集时避免对显存的浪费</li>
</ul>
</li>
</ul>
<h2 id="Nvidia-Docker"><a href="#Nvidia-Docker" class="headerlink" title="Nvidia Docker"></a>Nvidia Docker</h2><ul>
<li><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Github</a></p>
</li>
<li><p>在 Nvidia Docker 层限制 GPU 资源</p>
<ul>
<li><code>NV_GPU=0,1 nvidia-docker run -it nvidia/cuda nvidia-smi</code></li>
<li>弄清楚 <code>nvidia_uvm</code> 是个啥</li>
<li><code>nvidia-docker</code> 相当于 <code>docker run --device=/dev/nvidiactl --device=/dev/nvidia-utm --device=/dev/nvidia0</code></li>
</ul>
</li>
<li>可以做到资源隔离，具体要测试下，看看提供了什么工具</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/Machine-Learning-Project" target="_blank" rel="external">项目源代码</a></li>
<li><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="external">TensorFlow 官方文档中文版（比较老）</a></li>
<li><a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">Awesome TensorFlow</a></li>
<li><a href="https://github.com/fluxcapacitor/pipeline" target="_blank" rel="external">PipelineIO - 收费</a></li>
<li><a href="https://github.com/polyaxon/polyaxon" target="_blank" rel="external">Polyaxon</a></li>
<li><a href="http://www.cnblogs.com/darkknightzh/p/6591923.html" target="_blank" rel="external">http://www.cnblogs.com/darkknightzh/p/6591923.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23250782" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23250782</a></li>
<li><a href="http://www.cnblogs.com/wangxiaocvpr/p/5902086.html" target="_blank" rel="external">http://www.cnblogs.com/wangxiaocvpr/p/5902086.html</a></li>
<li><a href="http://blog.csdn.net/luodongri/article/details/52596780" target="_blank" rel="external">http://blog.csdn.net/luodongri/article/details/52596780</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我学习深度学习的笔记，来自网上的各类 jupyter notebook。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="深度学习" scheme="http://wdxtub.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="http://wdxtub.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>【科学革命的结构】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/"/>
    <id>http://wdxtub.com/2017/05/31/structure-of-science-revolution-clip/</id>
    <published>2017-05-30T23:32:11.000Z</published>
    <updated>2017-08-03T14:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这本书主要是强调范式对于科学的指导作用</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.31: 完成初稿</li>
</ul>
<h2 id="历史的作用"><a href="#历史的作用" class="headerlink" title="历史的作用"></a>历史的作用</h2><p>如果我们主要是寻求和考察那些从科学教科书中得出的、不含历史的旧规老套的问题的回答贰继续使用历史资料的话，那么，新科学观就不可能从历史中产生。</p>
<h2 id="通向常规科学之路"><a href="#通向常规科学之路" class="headerlink" title="通向常规科学之路"></a>通向常规科学之路</h2><p>在本书中，『常规科学』是指坚实地建立在一种或多种过去科学成就基础上的研究，这些科学成就为某个学科共同体在一段时期内公认为是进一步实践的基础。这些著作之所以能起到这样的做用，就在于它们共同具有两个基本特征：</p>
<ul>
<li>它们的成就空前地吸引一批坚定的拥护者，使他们脱离科学活动的其他竞争形式。</li>
<li>这些成就足以无限制地为重新组成的一批实践者留下有待解决的种种问题</li>
</ul>
<p>凡是共有这两个特征的成就，我此后便称之为『范式』，这是一个与『常规科学』密切有关的术语。</p>
<p>一种范式通过革命向另一种范式的过渡便是成熟科学通常的发展模式。</p>
<h2 id="常规科学的本质"><a href="#常规科学的本质" class="headerlink" title="常规科学的本质"></a>常规科学的本质</h2><p>如果不是一门成熟科学的实际实践者，就很少有人会认识到一种范式给人们留下非常多的扫尾工作要做，而完成这些扫尾工作又是多么地令人迷醉。这两个要点人们必须理解到。大多数科学家倾其全部科学生涯所从事的正是这些扫尾工作。这些工作构成了我在这里所称的常规科学。</p>
<h2 id="常规科学即是解谜"><a href="#常规科学即是解谜" class="headerlink" title="常规科学即是解谜"></a>常规科学即是解谜</h2><p>一个科学家必须致力于理解世界，并扩展这种使世界有序化的精度和广度。这种承诺反过来又必定会导致科学家自己或他的同事以丰富的经验细致地考察自然界的某个方面。如果这种考察发现明显的无序(disorder)，那就迫使他精练他的观测技巧，或者迫使他进一步阐明他的理论。</p>
<p>常规科学是一种高度确定性的活动，但它又不必要完全由规则所确定。这就是为什么在本文开始时我引进共有范式而不用共有规则、假定和观点作为常规研究传统连贯性源泉的原因。我认为，规则导源于范式，但即使没有规则，范式仍能指导研究。</p>
<h2 id="反常与科学发现的突破"><a href="#反常与科学发现的突破" class="headerlink" title="反常与科学发现的突破"></a>反常与科学发现的突破</h2><p>在任何一门科学的发展过程中，最先接受的范式，通常会让人感觉到它对于科学研究者容易理解的大多数观察和实验，能给予相当成功的说明。因此，进一步的发展通产高要求建构精巧的装置，发展出一套深奥的词汇和技巧，精练概念，使之不断地减少与它们通常的常识原型(prototypes)之间的相似性。</p>
<h2 id="科学革命的本质与必然性"><a href="#科学革命的本质与必然性" class="headerlink" title="科学革命的本质与必然性"></a>科学革命的本质与必然性</h2><p>科学革命也起源于科学共同体中某一小部分人逐渐感觉到：他们无法利用现有范式有效地探究自然界的某一方面，而以前范式在这方面的研究是起引导作用的。</p>
<p>原则上，只有三类现象可以引发新理论。第一类是那些现存范式已妥为解释的现象，但它们很少成为科学家创建新理论的动机或出发点。第二类现象是指那些其本质已为现有范式所表明，但其细节的理解却有待范式的完善的现象，它们是科学家常规研究的对象。但是这种研究的目的在于完善现有范式，而非发明新范式。只有当这种完善工作失败后，科学家才会遭遇第三类现象，即公认的反常现象，其特征是无法被现有范式同化。只有这类现象才会促成新理论的发明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书主要是强调范式对于科学的指导作用&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="读书" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="科学" scheme="http://wdxtub.com/tags/%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【别让我思考】读书笔记</title>
    <link href="http://wdxtub.com/2017/05/30/dont-make-me-think-clip/"/>
    <id>http://wdxtub.com/2017/05/30/dont-make-me-think-clip/</id>
    <published>2017-05-30T08:45:46.000Z</published>
    <updated>2017-08-03T14:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.05.30: 完成初稿</li>
</ul>
<h2 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h2><p>Krug 可用性第一定律</p>
<p>设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。</p>
<h2 id="我们实际上是如何使用-Web-的"><a href="#我们实际上是如何使用-Web-的" class="headerlink" title="我们实际上是如何使用 Web 的"></a>我们实际上是如何使用 Web 的</h2><p>扫描，满意即可，勉强应付</p>
<p>我们一旦发现某个事物能够用（不管有多难用），我们也不太会去找一种更好的方法。，如果偶然发现一种更好的方法，我们会换用这种更好的方法，但很少会主动寻找更好的方法。</p>
<h2 id="广告牌设计-101-法则"><a href="#广告牌设计-101-法则" class="headerlink" title="广告牌设计 101 法则"></a>广告牌设计 101 法则</h2><p>为扫描设计，不为阅读设计</p>
<ul>
<li>在每个页面上建立清楚的视觉层次。</li>
<li>尽量利用习惯用法</li>
<li>把页面划分成明确定义的区域</li>
<li>明显标识可以点击的地方。</li>
<li>最大限度降低干扰</li>
</ul>
<h3 id="建立清楚的视觉层次"><a href="#建立清楚的视觉层次" class="headerlink" title="建立清楚的视觉层次"></a>建立清楚的视觉层次</h3><ul>
<li>越重要的部分越突出</li>
<li>逻辑上相关的部分在视觉上也相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ul>
<h2 id="动物、植物、无机物"><a href="#动物、植物、无机物" class="headerlink" title="动物、植物、无机物"></a>动物、植物、无机物</h2><p>为什么用户喜欢无须思考的选择</p>
<p>如果我们需要一直在网络上进行选择，那么让这些选择变得无须思考是让一个网站容易使用的主要因素。</p>
<h2 id="省略不必要的文字"><a href="#省略不必要的文字" class="headerlink" title="省略不必要的文字"></a>省略不必要的文字</h2><p>不要在 Web 上写作的艺术</p>
<ul>
<li>去掉那些没有人会看的文字</li>
<li>欢迎词必须消灭</li>
<li>指示说明必须消灭</li>
</ul>
<h2 id="街头指示牌和面包屑"><a href="#街头指示牌和面包屑" class="headerlink" title="街头指示牌和面包屑"></a>街头指示牌和面包屑</h2><p>设计导航</p>
<p>关于页面名称，需要注意：</p>
<ul>
<li>每个页面都需要一个名称</li>
<li>页面名称要出现在合适的位置</li>
<li>名称要引人注目</li>
<li>名称要和点击的链接一致</li>
</ul>
<h2 id="首先要承认，主页不由你控制"><a href="#首先要承认，主页不由你控制" class="headerlink" title="首先要承认，主页不由你控制"></a>首先要承认，主页不由你控制</h2><p>设计主页</p>
<p>主页要完成的任务：</p>
<ul>
<li>站点的标识和使命</li>
<li>站点层次</li>
<li>搜索</li>
<li>导读</li>
<li>内容更新</li>
<li>友情链接</li>
<li>快捷方式</li>
<li>注册</li>
</ul>
<p>没有什么比得上一个好口号</p>
<ul>
<li>好的口号要清楚、言之有物</li>
<li>不好的口号含混不清</li>
<li>好的口号长度适中</li>
<li>好的口号能表述出网站的特点和显而易见的好处</li>
<li>不好的口号听起来太笼统</li>
<li>好的口号应该有个性、生动，有时候还很俏皮</li>
</ul>
<h2 id="农场主和牧牛人应该是朋友"><a href="#农场主和牧牛人应该是朋友" class="headerlink" title="农场主和牧牛人应该是朋友"></a>农场主和牧牛人应该是朋友</h2><p>为什么 Web 设计团队讨论可用性是在浪费时间，如何避免这种情况</p>
<p>争辩人们喜欢什么既浪费时间又消耗团队的经历，而通过测试将讨论对错转移到什么有效、什么无效上，更容易缓和争论、打破僵局，而且，测试会让我们看到用户的动机、理解、反应的不同，从而让我们不会再坚持认为用户的想法和我们的想法一样</p>
<h2 id="一天-10-美分的可用性测试"><a href="#一天-10-美分的可用性测试" class="headerlink" title="一天 10 美分的可用性测试"></a>一天 10 美分的可用性测试</h2><p>让测试简答 —— 这样你能进行充分的测试</p>
<ul>
<li>如果想建立一个优秀的网站，一定要测试</li>
<li>测试一个用户比不做测试好一倍</li>
<li>在项目中，早点测试一位用户好过最后测试 50 位用户</li>
<li>人们对招募用户代表的重要性估计过高</li>
<li>测试的关键不是要证明什么或者反驳什么，而是了解你的判断力</li>
<li>测试是一个迭代的过程</li>
<li>没有什么比现场用户的反应更重要</li>
</ul>
<h2 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h2><p>为什么你的网站应该让人尊敬</p>
<p>降低好感的几种方式</p>
<ul>
<li>隐藏我想要的信息</li>
<li>因为没有按照你们的方式行事而惩罚我</li>
<li>向我询问不必要的信息</li>
<li>敷衍我，欺骗我</li>
<li>给我设置障碍</li>
<li>你的网站看上去不专业</li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li>知道人们在你网站上想做什么，并让它们明白简单</li>
<li>高速我我想知道的</li>
<li>尽量减少步骤</li>
<li>花点心思</li>
<li>知道我可能有哪些疑问，并且给予解答</li>
<li>为我提供协助，例如打印友好页面</li>
<li>容易从错误中恢复</li>
<li>如有不确定，记得道歉</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计者应该尽量做到，当我看到一个页面时，它应该是不言而喻，一目了然，自我解释的。我应该能明白它是什么，怎样使用它，而不需要花费精力思考。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="网页" scheme="http://wdxtub.com/tags/%E7%BD%91%E9%A1%B5/"/>
    
  </entry>
  
</feed>
